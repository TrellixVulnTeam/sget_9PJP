import { HttpParams, HttpClient, HttpClientModule, HTTP_INTERCEPTORS, HttpResponse } from '@angular/common/http';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, Component, Input, Output, Directive, ContentChildren, ContentChild, TemplateRef, ViewEncapsulation, ChangeDetectorRef, ViewChild, NgModule, CUSTOM_ELEMENTS_SCHEMA, InjectionToken, Inject, ElementRef, Injector, forwardRef, Renderer2, IterableDiffers, Pipe } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ButtonModule } from 'primeng/button';
import { TooltipModule } from 'primeng/tooltip';
import { BlockUIModule } from 'primeng/blockui';
import { ProgressSpinnerModule } from 'primeng/progressspinner';
import { SplitButtonModule } from 'primeng/splitbutton';
import { InputTextModule } from 'primeng/inputtext';
import { PaginatorModule } from 'primeng/paginator';
import { Table, TableModule } from 'primeng/table';
import { Authorization, NotificationProvider, BlockUiService, BlockUiInterceptor, FormNotificationComponentSuperclass, FormNotificationBaseModule, ErrorStackService, ClipboardModule, ErrorProvider, ErrorStackProviderService, WrappedFormControlSuperclass, provideValueAccessor, FieldFormNotification, FormNotificationService, AccessbilityService } from '@nuvem/angular-base';
import { PrimeTemplate, MessageService, ConfirmationService } from 'primeng/api';
import { DropdownModule } from 'primeng/dropdown';
import { FormsModule, ReactiveFormsModule, ControlContainer, NG_VALUE_ACCESSOR } from '@angular/forms';
import { CheckboxModule } from 'primeng/checkbox';
import { MultiSelectModule } from 'primeng/multiselect';
import { Subject, forkJoin } from 'rxjs';
import { debounceTime, tap, filter, distinctUntilChanged } from 'rxjs/operators';
import { ToastModule } from 'primeng/toast';
import { ActivatedRoute, Router, RouterModule, NavigationEnd } from '@angular/router';
import { CalendarModule } from 'primeng/calendar';
import { InputTextareaModule } from 'primeng/inputtextarea';
import { InputMaskModule } from 'primeng/inputmask';
import { RadioButtonModule } from 'primeng/radiobutton';
import { ConfirmDialogModule } from 'primeng/confirmdialog';
import { AutoComplete, AutoCompleteModule } from 'primeng/autocomplete';
import { ScrollingModule } from '@angular/cdk/scrolling';
import { BreadcrumbModule as BreadcrumbModule$1 } from 'primeng/breadcrumb';
import { trigger, state, style, transition, animate } from '@angular/animations';

/**
 * Class DatatableService
 * @class
 */
class DatatableService {
    /**
     * constructor method
     * @constructor
     * @param {HttpClient} http
     */
    constructor(http) {
        this.http = http;
    }
    /**
     * search method
     * @param {LazyLoadEvent} event
     * @param {String} url
     * @param {number} rows
     * @param {boolean} orderInSort
     * @param {any} query
     * @return Observable
     */
    search(event, url, rows, orderInSort, query) {
        let page = 0;
        if (event !== undefined && event.first > 0) {
            page = Math.floor(event.first / rows);
        }
        let order = event.sortOrder === 1 ? 'asc' : 'desc';
        let params = new HttpParams()
            .set('page', page.toString())
            .set('size', rows.toString());
        if (orderInSort) {
            if (event.sortField !== undefined) {
                params = params.set('sort', event.sortField + ',' + order);
            }
        }
        else {
            if (event.sortField !== undefined) {
                params = params
                    .set('sort', event.sortField)
                    .set('order', order);
            }
        }
        if ('string' === typeof query) {
            params = params.set('query', query);
        }
        if ('object' === typeof query) {
            Object.keys(query).forEach(key => params = params.set(key, query[key]));
        }
        return this.http.get(`${url}?${params.toString()}`, { observe: 'response' });
    }
}
DatatableService.ɵprov = ɵɵdefineInjectable({ factory: function DatatableService_Factory() { return new DatatableService(ɵɵinject(HttpClient)); }, token: DatatableService, providedIn: "root" });
DatatableService.decorators = [
    { type: Injectable, args: [{
                providedIn: "root"
            },] }
];
DatatableService.ctorParameters = () => [
    { type: HttpClient }
];

/**
 * Class ServerDataProvider
 * @class
 */
class ServerDataProvider {
    /**
     * constructor method
     * @constructor
     * @param {DatatableService} datatableService
     * @param {DatatableComponent} component
     */
    constructor(datatableService, component) {
        this.datatableService = datatableService;
        this.component = component;
        this.component.pDatatableComponent.onLazyLoad.subscribe((event) => this.onLazyLoad(event));
        this.component.pDatatableComponent.lazy = true;
    }
    /**
     * onLazyLoad method
     * @param {LazyLoadEvent} onLazyLoad
     * @returns void
     */
    onLazyLoad(event) {
        this.currentLazyLoadEvent = event;
        this.load();
    }
    /**
     * load method
     * @param {any} query
     * @returns void
     */
    load(query) {
        query = this.retrieveAndSaveQuery(query);
        this.component.startedLoading.emit();
        this.datatableService.search(this.currentLazyLoadEvent, this.component.url, this.component.pDatatableComponent.rows, this.component.orderInSort, query)
            .toPromise()
            .then((response) => {
            this.treatLoadResponse(response);
            this.component.finishedLoading.emit();
        }, (error) => {
            this.component.finishedLoading.emit(error);
        });
    }
    /**
     * treatLoadResponse method
     * @param {any} response
     * @return void
     */
    treatLoadResponse(response) {
        const data = response.body;
        if (this.component.paginationParameters) {
            this.treatLoadResponseWithPaginationParameters(data);
        }
        else {
            this.treatLoadResponseWithoutPaginationParameters(response, data);
        }
    }
    /**
     * treatLoadResponseWithPaginationParameters method
     * @param {any} data
     * @returns void
     */
    treatLoadResponseWithPaginationParameters(data) {
        let contentIndex = this.component.paginationParameters.contentIndex;
        let totalIndex = this.component.paginationParameters.totalElementsIndex;
        this.component.value = (data[contentIndex]) ? data[contentIndex] : data;
        this.component.pDatatableComponent.totalRecords = (data[totalIndex]) ? data[totalIndex] : this.component.value.length;
    }
    /**
     * treatLoadResponseWithoutPaginationParameters method
     * @param {any} response
     * @param {any} data
     * @returns void
     */
    treatLoadResponseWithoutPaginationParameters(response, data) {
        if (response.headers.has('x-total-count')) {
            this.component.pDatatableComponent.totalRecords = parseInt(response.headers.get('x-total-count'), 10);
            this.component.value = data;
        }
        else {
            this.component.pDatatableComponent.totalRecords = data.totalElements;
            this.component.value = data.content;
        }
    }
    /**
     * retrieveAndSaveQuery method
     * @param {any} query
     * @returns any
     */
    retrieveAndSaveQuery(query) {
        const oldQuery = this._query;
        const currentQuery = this.doRetrieveAndSaveQuery(query);
        this.resetToFirstPageIfQueryChanged(oldQuery, currentQuery);
        return currentQuery;
    }
    /**
     * doRetrieveAndSaveQuery method
     * @param {any} query
     * @returns any
     */
    doRetrieveAndSaveQuery(query) {
        if ('object' === typeof query && query.value) {
            this._query = query.value;
        }
        else if (query) {
            this._query = query;
        }
        return this._query;
    }
    /**
     * resetToFirstPageIfQueryChanged method
     * @param {any} oldQuery
     * @param {any} currentQuery
     * @returns void
     */
    resetToFirstPageIfQueryChanged(oldQuery, currentQuery) {
        if (oldQuery !== currentQuery) {
            this.currentLazyLoadEvent.first = 0;
            this.component.pDatatableComponent.first = 0;
        }
    }
    /**
     * reset method
     * @returns void
     */
    reset() {
        this._query = undefined;
    }
}

/**
 * Class MemoryDataProvider
 * @class
 */
class MemoryDataProvider {
    /**
     * constructor method
     * @param {DatatableComponent} component
     * @constructor
     */
    constructor(component) {
        this.component = component;
    }
    /**
     * load method
     * @param {any} query
     * @returns void
     */
    load(query) {
        this.component.pDatatableComponent.reset();
        for (let prop in query) {
            let matchMode = 'contains';
            if (query[prop] instanceof Array) {
                matchMode = 'in';
            }
            this.component.pDatatableComponent.filter(query[prop], prop, matchMode);
        }
        this.component.pDatatableComponent.globalFilterFields = query;
        this.component.pDatatableComponent._filter();
    }
    /**
     * reset method
     * @returns void
     */
    reset() {
        this.component.pDatatableComponent.globalFilterFields = undefined;
    }
}

/**
 * Enum DataProviderType
 * @enum
 */
var DataProviderType;
(function (DataProviderType) {
    DataProviderType["Memory"] = "memory";
    DataProviderType["Server"] = "server";
})(DataProviderType || (DataProviderType = {}));
/**
 * Class DataProviderFactory
 * @class
 */
class DataProviderFactory {
    /**
     * constructor method
     * @constructor
     * @param {DatatableService} datatableService
     */
    constructor(datatableService) {
        this.datatableService = datatableService;
    }
    /**
     * create method
     * @param {DataProviderType} type
     * @param {DatatableComponent} component
     * @public
     * @returns DataProvider
     */
    create(type, component) {
        if (DataProviderType.Server === type) {
            return new ServerDataProvider(this.datatableService, component);
        }
        if (DataProviderType.Memory === type) {
            return new MemoryDataProvider(component);
        }
    }
}
DataProviderFactory.ɵprov = ɵɵdefineInjectable({ factory: function DataProviderFactory_Factory() { return new DataProviderFactory(ɵɵinject(DatatableService)); }, token: DataProviderFactory, providedIn: "root" });
DataProviderFactory.decorators = [
    { type: Injectable, args: [{
                providedIn: "root"
            },] }
];
DataProviderFactory.ctorParameters = () => [
    { type: DatatableService }
];

/**
 * Class DatatableButtonComponent
 * @class
 */
class DatatableButtonComponent {
    constructor() {
        /**
         * allowMultipleSelection property
         * @type {boolean}
         */
        this.allowMultipleSelection = true;
        /**
         * disabled property
         * @type boolean
         */
        this.disabled = false;
        /**
         * click property
         * @type {EventEmitter<any>}
         */
        this.click = new EventEmitter();
    }
    /**
     * onClick method
     * @param {any} event
     * @return void
     */
    onClick(event) {
        this.click.emit(event);
        event.stopPropagation();
    }
}
DatatableButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-datatable-button',
                template: "<p pTooltip=\"{{ bTooltip }}\">\n    <button pRipple\n        (click)=\"onClick($event)\" \n        [disabled]=\"disabled\" \n        pButton \n        type=\"button\" \n        icon=\"{{ icon }}\" \n        class=\"p-button-rounded p-mr-2 p-mb-2 {{ class }}\">\n    </button>\n</p>\n"
            },] }
];
DatatableButtonComponent.propDecorators = {
    icon: [{ type: Input }],
    class: [{ type: Input }],
    bTooltip: [{ type: Input }],
    name: [{ type: Input }],
    allowMultipleSelection: [{ type: Input }],
    disabled: [{ type: Input }],
    click: [{ type: Output }]
};

/**
 * Class DatatableClickEvent
 * @class
 */
class DatatableClickEvent {
    /**
     * constructor method
     * @constructor
     * @param {string} button
     * @param {any} selection
     */
    constructor(button, selection) {
        this.button = button;
        this.selection = selection;
    }
}

class Column {
    constructor() {
        this.filterType = 'text';
        this.exportable = true;
        this.resizable = true;
        this.sortFunction = new EventEmitter();
    }
    ngAfterContentInit() {
        this.templates.forEach((item) => {
            switch (item.getType()) {
                case 'header':
                    this.headerTemplate = item.template;
                    break;
                case 'body':
                    this.bodyTemplate = item.template;
                    break;
                case 'footer':
                    this.footerTemplate = item.template;
                    break;
                case 'filter':
                    this.filterTemplate = item.template;
                    break;
                case 'editor':
                    this.editorTemplate = item.template;
                    break;
                case 'input':
                    this.inputTemplate = item.template;
                    break;
                case 'output':
                    this.outputTemplate = item.template;
                    break;
                default:
                    this.bodyTemplate = item.template;
                    break;
            }
        });
    }
}
Column.decorators = [
    { type: Directive, args: [{
                selector: 'p-column'
            },] }
];
Column.propDecorators = {
    field: [{ type: Input }],
    colId: [{ type: Input }],
    sortField: [{ type: Input }],
    filterField: [{ type: Input }],
    header: [{ type: Input }],
    footer: [{ type: Input }],
    sortable: [{ type: Input }],
    editable: [{ type: Input }],
    filter: [{ type: Input }],
    filterMatchMode: [{ type: Input }],
    filterType: [{ type: Input }],
    excludeGlobalFilter: [{ type: Input }],
    rowspan: [{ type: Input }],
    colspan: [{ type: Input }],
    scope: [{ type: Input }],
    style: [{ type: Input }],
    styleClass: [{ type: Input }],
    exportable: [{ type: Input }],
    headerStyle: [{ type: Input }],
    headerStyleClass: [{ type: Input }],
    bodyStyle: [{ type: Input }],
    bodyStyleClass: [{ type: Input }],
    footerStyle: [{ type: Input }],
    footerStyleClass: [{ type: Input }],
    hidden: [{ type: Input }],
    expander: [{ type: Input }],
    selectionMode: [{ type: Input }],
    filterPlaceholder: [{ type: Input }],
    filterMaxlength: [{ type: Input }],
    frozen: [{ type: Input }],
    resizable: [{ type: Input }],
    sortFunction: [{ type: Output }],
    templates: [{ type: ContentChildren, args: [PrimeTemplate,] }],
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/**
 * Class DatatableComponent
 * @class
 */
class DatatableComponent {
    /**
     * constructor method
     * @constructor
     * @param {ChangeDetectorRef} changeDetectorRef
     * @param {DataProviderFactory} dataProviderFactory
     * @param {Authorization} authorizationService
     */
    constructor(changeDetectorRef, dataProviderFactory, authorizationService) {
        this.changeDetectorRef = changeDetectorRef;
        this.dataProviderFactory = dataProviderFactory;
        this.authorizationService = authorizationService;
        this.isShowGlobalFilter = false;
        this.isShowFilterRow = false;
        /**
         * filterParams property
         * @type {any}
         */
        this.filterParams = {};
        /**
         * footerMsg property
         * @type {string}
         */
        this.footerMsg = '';
        /**
         * orderInSort property
         * @type {boolean}
         */
        this.orderInSort = false;
        /**
         * value property
         * @type {any}
         */
        this.value = [];
        /**
         * type property
         * @type DataProviderType
         */
        this.type = DataProviderType.Server;
        /**
         * rows property
         * @type {number}
         */
        this.rows = 5;
        /**
         * showPaginationFooter property
         * @type {boolean}
         */
        this.showPaginationFooter = false;
        /**
         * disableEdit property
         * @type {boolean}
         */
        this.disableEdit = false;
        /**
         * disableView property
         * @type {boolean}
         */
        this.disableView = false;
        /**
         * disableDelete property
         * @type {boolean}
         */
        this.disableDelete = false;
        /**
         * selectionMode property
         * @type {string}
         */
        this.selectionMode = 'single';
        /**
         * enableButtonsScroll property
         * @type {boolean}
         */
        this.enableButtonsScroll = false;
        /**
         * emptyMessage property
         * @type {string}
         */
        this.emptyMessage = 'Nenhum registro encontrado.';
        /**
         * verticalButtons property
         * @type {boolean}
         */
        this.verticalButtons = true;
        /**
         * defaultButtons property
         * @type {boolean}
         */
        this.defaultButtons = true;
        /**
         * enableScroll property
         * @type {boolean}
         */
        this.enableScroll = false;
        /**
         * disableLoadingBlockUI property
         * @type {boolean}
         */
        this.disableLoadingBlockUI = false;
        /**
         * filterOnColumn property
         */
        this.filterOnColumn = false;
        /**
         * filterSelectOptions property
         */
        this.filterSelectOptions = [];
        /**
         * updateFiltroHistorico property
         */
        this.updateFilterColumn = false;
        /**
         * customFilterOptions property
         */
        this.customFilterOptions = {};
        /**
         * buttonClick property
         * @type {EventEmitter<any>}
         */
        this.buttonClick = new EventEmitter();
        /**
         * startedLoading property
         * @type {EventEmitter<void>}
         */
        this.startedLoading = new EventEmitter();
        /**
         * finishedLoading property
         * @type {EventEmitter<HttpErrorResponse>}
         */
        this.finishedLoading = new EventEmitter();
        /**
         * onRowSelected property
         * @type {EventEmitter<any>}
         */
        this.onRowSelected = new EventEmitter();
        /**
         * showHorizontalButtonsHeader property
         * @type {boolean}
         */
        this.showHorizontalButtonsHeader = false;
        /**
         * blockContent
         * @type {boolean}
         */
        this.blockContent = false;
        /**
         * visibleColumns property
         * @type {Object}
         */
        this.visibleColumns = {};
        /**
         * showVisibleColumnsControl property
         * @type {boolean}
         */
        this.showVisibleColumnsControl = false;
        /**
         * dataKey property
         * Identificador único para cada registro da tabela
         * @type {string}
         */
        this.dataKey = 'id';
        /**
         * onRowEditEvent property
         * Evento disparado quando o usuário realiza ações de edição em uma linha da tabela
         * @type {EventEmitter<void>}
         */
        this.onRowEditEvent = new EventEmitter();
        this.clonedRowData = {};
        /**
         * errorMessage property
         * @type {string}
         */
        this.errorMessage = 'Ocorreu um erro ao carregar os dados da tabela. Tente novamente.';
        this.editingRow = false;
    }
    get showGlobalFilter() {
        return this.isShowGlobalFilter;
    }
    set showGlobalFilter(showGlobalFilter) {
        this.isShowGlobalFilter = showGlobalFilter;
    }
    get showFilterRow() {
        return this.isShowFilterRow;
    }
    set showFilterRow(ShowFilterRow) {
        this.isShowFilterRow = ShowFilterRow;
    }
    /**
     * ngOnInit method
     * @returns void
     */
    ngOnInit() {
        this.dataProvider = this.dataProviderFactory.create(this.type, this);
        this.pDatatableComponent.rows = this.rows;
        this.subscribeToLoadingEvents();
        this.initRowsPerPageOptionsIfPresent();
        this.defineIfShouldShowHorizontalButtonsHeader();
        this.updateOnValueChange();
        this.finishedLoading.subscribe(() => {
            this.updateOnValueChange();
        });
    }
    /**
     * subscribeFromValueChange method
     * @returns void
     */
    updateOnValueChange() {
        this.filterSelectOptions = [];
        if (this.value) {
            this.value.map((item) => {
                this.filterSelectOptions.push(item);
            });
        }
    }
    /**
     * subscribeToLoadingEvents method
     * @returns void
     */
    subscribeToLoadingEvents() {
        if (!this.disableLoadingBlockUI) {
            this.originalEmptyMessage = this.emptyMessage;
            this.startedLoading.subscribe(() => this.onStartedLoading());
            this.finishedLoading.subscribe(error => this.onFinishedLoading(error));
        }
    }
    /**
     * onStartedLoading method
     * @returns void
     */
    onStartedLoading() {
        this.blockContent = true;
        this.emptyMessage = this.originalEmptyMessage;
    }
    /**
     * onFinishedLoading method
     * @param {HttpErrorResponse} error
     * @returns void
     */
    onFinishedLoading(error) {
        this.blockContent = false;
        if (error) {
            this.emptyMessage = this.errorMessage;
        }
    }
    /**
     * initRowsPerPageOptionsIfPresent method
     * @returns void
     */
    initRowsPerPageOptionsIfPresent() {
        if (this.rowsPerPageOptions) {
            this.pDatatableComponent.rowsPerPageOptions = this.rowsPerPageOptions;
        }
    }
    /**
     * defineIfShouldShowHorizontalButtonsHeader method
     * @returns void
     */
    defineIfShouldShowHorizontalButtonsHeader() {
        if (this.horizontalButtonsHeader) {
            this.showHorizontalButtonsHeader = true;
        }
    }
    /**
     * ngAfterViewInit method
     * @returns void
     */
    ngAfterViewInit() {
        this.setExtraParams();
        this.pDatatableComponent.columns = this.columns;
        this.pDatatableComponent.ngAfterContentInit();
        this.setAllColumnsVisible();
        this.changeDetectorRef.detectChanges();
    }
    /**
     * setExtraParams method
     * @returns void
     */
    setExtraParams() {
        for (let i in this.extraParams) {
            this.pDatatableComponent[i] = this.extraParams[i];
        }
    }
    /**
     * ngAfterContentInit method
     * @returns void
     */
    ngAfterContentInit() {
        this.extraButtons.forEach(button => {
            button.click.subscribe(event => {
                this.onClick(button.name, event);
            });
        });
    }
    /**
     * onClick method
     * @param {string} button
     * @param {any} event
     * @return void
     */
    onClick(button, event) {
        this.buttonClick.emit(new DatatableClickEvent(button, this.selectedRow));
        event.stopPropagation();
        this.resetSelectedRow(button);
    }
    /**
     * onSelectChange method
     * @param {any} event
     * @returns void
     */
    onSelectChange(event) {
        this.onRowSelected.emit(this.selectedRow);
        if (Array.isArray(this.selectedRow) && this.selectedRow.length > 1) {
            this.updateMultipleButtonsStatus(true);
        }
        else {
            this.updateMultipleButtonsStatus(false);
        }
    }
    /**
     * updateMultipleButtonsStatus method
     * @param {boolean} hasMultipleSelection
     * @return void
     */
    updateMultipleButtonsStatus(hasMultipleSelection) {
        this.extraButtons.forEach(button => {
            if (hasMultipleSelection && !button.allowMultipleSelection) {
                button.disabled = true;
            }
            else {
                button.disabled = false;
            }
        });
    }
    /**
     * refresh method
     * @param query
     * @returns void
     */
    refresh(query) {
        this.dataProvider.load(query);
    }
    /**
     * resetSelectedRow method
     * @param button
     * @returns void
     */
    resetSelectedRow(button) {
        if (button === 'delete') {
            this.selectedRow = null;
        }
    }
    /**
     * reset method
     * @returns void
     */
    reset() {
        this.pDatatableComponent.first = 0;
        this.dataProvider.reset();
        this.refresh();
    }
    /**
     * paginationFooterText method
     * @param {string} msg
     * @returns string
     */
    paginationFooterText(msg) {
        const registros = this.totalRecords() === 1 ? 'registro' : 'registros';
        if (msg === '') {
            return `Exibindo: ${this.currentFirstIndex()} a ${this.currentLastIndex()} de ${this.totalRecords()} ${registros}`;
        }
        msg = msg.replace('{totalRecords}', this.totalRecords().toString());
        msg = msg.replace('{currentFirstIndex}', this.currentFirstIndex().toString());
        msg = msg.replace('{currentLastIndex}', this.currentLastIndex().toString());
        return msg;
    }
    /**
     * currentFirstIndex method
     * @returns number
     */
    currentFirstIndex() {
        return this.pDatatableComponent.first + 1;
    }
    /**
     * currentLastIndex method
     * @returns number
     */
    currentLastIndex() {
        const currentLastIndex = this.pDatatableComponent.first + this.pDatatableComponent.rows;
        if (currentLastIndex > this.totalRecords()) {
            return this.totalRecords();
        }
        return currentLastIndex;
    }
    /**
     * totalRecords method
     * @returns number
     */
    totalRecords() {
        return this.pDatatableComponent.totalRecords;
    }
    /**
     * checkRolesToButton method
     * @param {string} button
     * @return boolean
     */
    checkRolesToButton(button) {
        if (this[button]) {
            if (button === 'rulesToHide' ||
                button === 'rulesToShowEdit' ||
                button === 'rulesToShowDelete') {
                this.checkUseButtons(button);
                return this.authorizationService.hasRole(this[button]);
            }
            return !this.authorizationService.hasRole(this[button]);
        }
        return true;
    }
    /**
     * checkUseButtons method
     * @param {string} button
     * @returns void
     */
    checkUseButtons(button) {
        if (this[button] && this[button.replace('Show', 'Hide')]) {
            throw new Error('Não é possível definir dois valores de roles para os botões padrões.');
        }
    }
    /**
     * filter method
     * @returns void
     */
    filter() {
        for (let prop in this.filterParams) {
            if (this.filterParams[prop] === '' ||
                this.filterParams[prop].length === 0) {
                delete this.filterParams[prop];
            }
        }
        if (Object.getOwnPropertyNames(this.filterParams).length === 0) {
            this.reset();
        }
        else {
            this.refresh(this.filterParams);
        }
    }
    /**
     * Método para filtrar por colunas
     * @param column chave da coluna na tabela
     * @param filters valor do filtro
     */
    filterColumn(column, filters) {
        const values = [];
        if (filters instanceof Array) {
            values[column] = [];
            for (let item in filters) {
                let val = filters[item] instanceof Object
                    ? filters[item].value
                    : filters[item];
                values[column].push(val);
            }
        }
        else {
            values[column] = filters;
        }
        this.filterParams = Object.assign(Object.assign({}, this.filterParams), values);
        return this.filter();
    }
    /**
     * Inicia todas as colunas da tabela como visíveis
     */
    setAllColumnsVisible() {
        this.columns.forEach(col => {
            this.visibleColumns[col.field] = 'table-cell';
        });
    }
    /**
     * Verifica se uma coluna deve estar visível
     * @param column string
     * @param visibleColumns Array
     */
    visibleColumnCheck(column, visibleColumns) {
        return visibleColumns.some((item) => {
            return item.field ? item.field == column : true;
        });
    }
    /**
     * Atualzia os valores da variável 'visibleColuns' para mostrar ou não as colunas
     * @param columns array
     */
    updateVisibleColumns(columns) {
        for (let col in this.visibleColumns) {
            if (this.visibleColumnCheck(col, columns)) {
                this.visibleColumns[col] = 'table-cell';
            }
            else {
                this.visibleColumns[col] = 'none';
            }
        }
    }
    onRowEditInitEvent(event, rowData) {
        // const tr = event.srcElement.closest('tr');
        // setTimeout(() => {
        //     this.editingRow = true;
        //     const top = tr.offsetTop;
        //     const height = tr.offsetHeight;
        //     const editButtons = tr.querySelector('.editar-campos');
        //     editButtons.style.top = (top + height) + 'px';
        //     editButtons.style.height ='75px';
        //     editButtons.style.backgroundColor = '#d0d0d0';
        //     editButtons.style.opacity = 1;
        //     this.clonedRowData[rowData.id] = {...rowData};
        //     this.onRowEditEvent.emit({event: "init", data: rowData});
        // }, null , tr);
    }
    onRowEditSaveEvent(event, rowData) {
        this.onRowEditEvent.emit({ event: "save", data: rowData });
        this.resetEditingMode(event);
    }
    onRowEditCancelEvent(event, rowData, index) {
        this.value[index] = this.clonedRowData[rowData.id];
        delete this.clonedRowData[rowData[this.dataKey]];
        this.onRowEditEvent.emit({ event: "cancel", data: rowData });
        this.resetEditingMode(event);
    }
    resetEditingMode(event) {
        const editButtons = event.srcElement.closest('tr').querySelector('.editar-campos');
        editButtons.style.opacity = 0;
        editButtons.style.backgroundColor = '#0000006b';
        editButtons.style.display = 'none';
        this.editingRow = false;
    }
    editarLinhaOver(event) {
        // if (!this.editingRow && this.editMode == 'row') {
        //     const top = event.srcElement.closest('tr').offsetTop;
        //     const height = event.srcElement.closest('tr').offsetHeight;
        //     const editButtons = event.srcElement.closest('tr').querySelector('.editar-campos');
        //     editButtons.style.display = 'flex';
        //     editButtons.style.top = top + 'px';
        //     editButtons.style.height = height + 'px';
        //     editButtons.style.backgroundColor = '#0000006b';
        //     editButtons.style.opacity = 1;
        // }
    }
    editarLinhaOut(event) {
        // if (!this.editingRow) {
        //     const editButtons = event.srcElement.closest('tr').querySelector('.editar-campos');
        //     editButtons.style.display = 'none';
        //     editButtons.style.opacity = 0;
        // }
    }
}
DatatableComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-datatable',
                template: "<p-blockUI [blocked]=\"blockContent\">\n    <div class=\"center-spinner\">\n        <p-progressSpinner></p-progressSpinner>\n    </div>\n</p-blockUI>\n<div [ngClass]=\"(defaultButtons && verticalButtons) ? 'p-grid p-col-11' : 'p-grid p-col-12'\">\n    <div class=\"table-tools\">\n        <div class=\"p-col-8 nopad\">\n            <h3 class=\"\">{{ title }}</h3>\n        </div>\n        <div class=\"p-col-4 nopad tools\">\n            <basis-show-column *ngIf=\"showVisibleColumnsControl\" [columns]=\"columns\" (updateVisibleColumns)=\"updateVisibleColumns($event)\"></basis-show-column>\n            <button pButton \n                pRipple \n                type=\"button\" \n                icon=\"fas fa-sliders-h\"\n                class=\"p-button-rounded p-button-outlined p-mr-2 p-mb-2\" \n                [ngClass]=\"{'active':filterOnColumn}\"\n                (click)=\"filterOnColumn = !this.filterOnColumn\">\n            </button>\n            <button pButton \n                pRipple \n                type=\"button\" \n                icon=\"fas fa-columns\" \n                [ngClass]=\"{'active':showVisibleColumnsControl}\"\n                class=\"p-button-rounded p-button-outlined p-mr-2 p-mb-2\"\n                (click)=\"showVisibleColumnsControl = !this.showVisibleColumnsControl\">\n            </button>\n        </div>\n    </div>\n</div>\n<div class=\"p-grid\">\n    <div [ngClass]=\"{\n            'p-col-11' : (defaultButtons && verticalButtons),\n            'p-col-12' : (!defaultButtons || !verticalButtons),\n            'edicao-tabela' : editMode == 'row',\n            'editing-row': editingRow\n        }\">\n        <p-table\n            [value]=\"value\"\n            [rows]=\"rows\"\n            [paginator]=\"true\"\n            [selectionMode]=\"selectionMode\"\n            [responsive]=\"true\"\n            [scrollable]=\"enableScroll\"\n            [(selection)]=\"selectedRow\"\n            [editMode]=\"editMode\"\n            (onRowSelect)=\"onSelectChange($event)\"\n            (onRowUnselect)=\"onSelectChange($event)\"\n            styleClass=\"p-datatable-customers\" \n            [rowHover]=\"true\"\n            #datatable\n            [dataKey]=\"dataKey\">\n            <ng-template pTemplate=\"header\" let-columns>\n                <div class=\"p-g\" *ngIf=\"defaultButtons && !verticalButtons\">\n                    <div *ngIf=\"showHorizontalButtonsHeader\" class=\"p-g-4 p-sm-12\">\n                        <span class=\"horizontal-buttons-header\">{{ horizontalButtonsHeader }}</span>\n                    </div>\n                    <div [ngClass]=\"{\n                        'horizontal-buttons': true,\n                        'p-sm-12': true,\n                        'p-g-8': showHorizontalButtonsHeader,\n                        'p-g-12': !showHorizontalButtonsHeader}\">\n                        <ng-container *ngTemplateOutlet=\"defaultButtons\"></ng-container>\n                        <ng-content select=\"horizontalButtons\"></ng-content>\n                    </div>\n                </div>\n                <tr>\n                    <th *ngFor=\"let col of columns\"\n                        [pSortableColumn]=\"col.sortable ? col.field : null\"\n                        [ngStyle]=\"{'display': visibleColumns[col.field]}\">\n                        {{col.header}}\n                        <p-sortIcon *ngIf=\"col.sortable\" [field]=\"col.field\"></p-sortIcon>\n                    </th>\n                </tr>\n                <tr class=\"header-filter-column\" *ngIf=\"filterOnColumn\">\n                    <th *ngFor=\"let col of columns\" [ngStyle]=\"{'display': visibleColumns[col.field]}\">\n                        <basis-filter-column\n                            *ngIf=\"col.field != 'actions'\"\n                            [listaOriginal]=\"filterSelectOptions\"\n                            [lista]=\"filterSelectOptions\"\n                            [field]=\"col.field\"\n                            [updateFiltro]=\"updateFilterColumn\"\n                            (outputEvent)=\"filterColumn(col.field, $event)\"\n                            [filterType]=\"col.filterType\"\n                            [tableType]=\"type\"\n                            [customFilterOptions]=\"customFilterOptions\">\n                        </basis-filter-column>\n                    </th>\n                </tr>\n            </ng-template>\n            <ng-template pTemplate=\"body\" let-rowData let-columns=\"columns\" let-editing=\"editing\" let-ri=\"rowIndex\">\n                <tr [pSelectableRow]=\"rowData\"\n                    [pContextMenuRow]=\"rowData\"\n                    [pEditableRow]=\"rowData\"\n                    [ngClass]=\"{'editing': editing}\"\n                    (mouseover)=\"editarLinhaOver($event)\"\n                    (mouseleave)=\"editarLinhaOut($event)\">\n                    <ng-container *ngFor=\"let col of columns; last as isLast\">\n                        <td *ngIf=\"col.field != 'actions'\" [ngStyle]=\"{'display': visibleColumns[col.field]}\">\n                            <ng-container *ngIf=\"!editMode\">\n                                <span *ngIf=\"!col.bodyTemplate\" [innerHTML]=\"rowData[col.field]\"></span>\n                                <ng-container\n                                    *ngIf=\"col.bodyTemplate\"\n                                    [ngTemplateOutlet]=\"col.bodyTemplate\"\n                                    [ngTemplateOutletContext]=\"{ rowData: rowData, col: col }\">\n                                </ng-container>\n                            </ng-container>\n        \n                            <ng-container *ngIf=\"editMode\">\n                                <p-cellEditor>\n                                    <ng-template pTemplate=\"input\">\n                                        <span *ngIf=\"!col.outputTemplate && col.editable == false\" [innerHTML]=\"rowData[col.field]\"></span>\n                                        <div class=\"p-md-12\" *ngIf=\"!col.inputTemplate && col.editable != false\">\n                                            <div class=\"p-g form-group\">\n                                                <div class=\"p-md-12\">\n                                                    <span class=\"md-inputfield\">\n                                                        <input pInputText type=\"text\" [(ngModel)]=\"rowData[col.field]\" [style]=\"{'width':'100%'}\">\n                                                        <label>{{ col.header }}</label>\n                                                    </span>\n                                                </div>\n                                            </div>\n                                        </div>\n                                        <ng-container\n                                            *ngIf=\"col.inputTemplate\"\n                                            [ngTemplateOutlet]=\"col.inputTemplate\"\n                                            [ngTemplateOutletContext]=\"{ 'rowData': rowData, 'col': col }\">\n                                        </ng-container>\n                                    </ng-template>\n                                    <ng-template pTemplate=\"output\">\n                                        <span *ngIf=\"!col.outputTemplate\" [innerHTML]=\"rowData[col.field]\"></span>\n                                        <ng-container\n                                            *ngIf=\"col.outputTemplate\"\n                                            [ngTemplateOutlet]=\"col.outputTemplate\"\n                                            [ngTemplateOutletContext]=\"{ rowData: rowData, col: col }\">\n                                        </ng-container>\n                                    </ng-template>\n                                </p-cellEditor>\n                            </ng-container>\n                        </td>\n                        <td width=\"8%\" class=\"action-column\" *ngIf=\"col.field == 'actions'\">\n                            <basis-action-button>\n                                <ng-container\n                                    *ngIf=\"col.outputTemplate\"\n                                    [ngTemplateOutlet]=\"col.outputTemplate\"\n                                    [ngTemplateOutletContext]=\"{ rowData: rowData }\">\n                                </ng-container>\n                            </basis-action-button>\n                        </td>\n                        <!-- TODO: verificar implementa\u00E7\u00E3o -->\n                        <!-- <div *ngIf=\"isLast\" class=\"editar-campos\">\n                            <button *ngIf=\"!editing\" pButton type=\"button\" pInitEditableRow (click)=\"onRowEditInitEvent($event, rowData)\">Editar</button>\n                            <button *ngIf=\"editing\" pButton type=\"button\" pSaveEditableRow class=\"p-button-success\" style=\"margin-right: .5em\" (click)=\"onRowEditSaveEvent($event, rowData)\">Salvar</button>\n                            <button *ngIf=\"editing\" pButton type=\"button\" pCancelEditableRow class=\"p-button-danger\" (click)=\"onRowEditCancelEvent($event, rowData, ri)\">Cancelar</button>\n                        </div> -->\n                    </ng-container>\n                </tr>\n            </ng-template>\n            <ng-template *ngIf=\"emptyMessage\">\n                {{ emptyMessage }}\n            </ng-template>\n            <p-footer *ngIf=\"showPaginationFooter && totalRecords() > 0\">\n                {{ paginationFooterText(footerMsg) }}\n            </p-footer>\n        </p-table>\n    </div>\n    <div *ngIf=\"defaultButtons && verticalButtons\"\n        class=\"p-col-1\"\n        [style.position]=\"enableButtonsScroll ? 'sticky' : ''\"\n        [style.top]=\"enableButtonsScroll ? '15%' : ''\">\n            <ng-container *ngTemplateOutlet=\"defaultButtonsTemplate\"></ng-container>\n            <ng-content select=\"basis-datatable-button\"></ng-content>\n    </div>\n</div>\n<ng-template #defaultButtonsTemplate>\n    <basis-datatable-button [bTooltip]=\"selectedRow != null ? 'Editar' : 'Escolha um registro para editar.' \"\n        [class.horizontal-button]=\"!verticalButtons\" class=\"p-button-success\" icon=\"pi pi-pencil\" (click)=\"onClick('edit', $event)\"\n        *ngIf=\"!disableEdit && checkRolesToButton('rulesToShowView') && checkRolesToButton('rulesToHideView')\" [disabled]=\"selectedRow == null\">\n    </basis-datatable-button>\n\n    <basis-datatable-button [bTooltip]=\"selectedRow != null ? 'Visualizar' : 'Escolha um registro para visualizar.'\"\n        [class.horizontal-button]=\"!verticalButtons\" icon=\"pi pi-search-plus\" (click)=\"onClick('view', $event)\"\n        *ngIf=\"!disableView && checkRolesToButton('rulesToShowEdit') && checkRolesToButton('rulesToHideEdit')\" [disabled]=\"selectedRow == null\">\n    </basis-datatable-button>\n\n    <basis-datatable-button [bTooltip]=\"selectedRow != null ? 'Excluir' : 'Escolha um registro para excluir.'\"\n        [class.horizontal-button]=\"!verticalButtons\" class=\"p-button-danger\" icon=\"pi pi-trash\" (click)=\"onClick('delete', $event)\"\n        *ngIf=\"!disableDelete && checkRolesToButton('rulesToShowDelete') && checkRolesToButton('rulesToHideDelete')\" [disabled]=\"selectedRow == null\">\n    </basis-datatable-button>\n\n    <datatable-splitbutton\n        [icon]=\"splitButton.icon\"\n        [class]=\"splitButton.class\"\n        [items]=\"splitButton.itens\"\n        [label]=\"splitButton.label\"\n        [method]=\"splitButton.method\"\n        *ngIf=\"splitButton\">\n    </datatable-splitbutton>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["body .p-datatable .p-datatable-data tr td{word-wrap:break-word}.horizontal-buttons{display:flex;flex-flow:row wrap;justify-content:flex-end}.horizontal-button{padding:0 3px}.horizontal-buttons-header{font-size:1.3em;word-wrap:break-word}.center-spinner{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;min-height:100vh}.text-right{text-align:right}basis-show-column .p-multiselect-panel.p-widget{width:100%;max-width:100%}basis-show-column{padding-right:15px;border-right:1px solid #747474;margin-right:10px}.table-tools{width:100%;text-align:right;margin-bottom:-10px;display:flex;align-items:center}.table-tools h3{text-align:left;float:left;margin:0}.table-tools a{color:#16695c;border-radius:100px;width:20px;height:20px;padding:6px;display:inline-table;margin-left:3px;font-size:15px;text-align:center;line-height:20px}.table-tools a:hover{color:#1aa590;cursor:pointer}.table-tools a.active{color:#16695c;background-color:#e8e8e8;box-shadow:inset 0 2px 3px rgba(0,0,0,.4392156862745098)}.table-tools .tools{display:inline-flex;align-items:center;justify-content:flex-end}.edicao-tabela,.edita-linha{position:relative}tr.editing td{padding-bottom:75px!important}.editar-campos{opacity:0;position:absolute;width:100%;background-color:rgba(0,0,0,.4196078431372549);left:0;margin-top:0;display:flex;align-items:center;justify-content:center;min-height:35px;transition:all .3s ease-in-out;z-index:1}.editar-campos button{color:#fff;font-size:14px;padding:6px 30px 10px;border-radius:5px;height:28px;width:120px!important}.bt-cancelar,.bt-salvar{margin:0 10px}"]
            },] }
];
DatatableComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: DataProviderFactory },
    { type: Authorization }
];
DatatableComponent.propDecorators = {
    title: [{ type: Input }],
    splitButton: [{ type: Input }],
    value: [{ type: Input }],
    type: [{ type: Input }],
    rows: [{ type: Input }],
    rowsPerPageOptions: [{ type: Input }],
    url: [{ type: Input }],
    extraParams: [{ type: Input }],
    paginationParameters: [{ type: Input }],
    showPaginationFooter: [{ type: Input }],
    disableEdit: [{ type: Input }],
    disableView: [{ type: Input }],
    disableDelete: [{ type: Input }],
    selectionMode: [{ type: Input }],
    enableButtonsScroll: [{ type: Input }],
    emptyMessage: [{ type: Input }],
    verticalButtons: [{ type: Input }],
    defaultButtons: [{ type: Input }],
    enableScroll: [{ type: Input }],
    scrollHeight: [{ type: Input }],
    scrollWidth: [{ type: Input }],
    rulesToHide: [{ type: Input }],
    rulesToShowEdit: [{ type: Input }],
    rulesToShowDelete: [{ type: Input }],
    rulesToHideView: [{ type: Input }],
    rulesToHideEdit: [{ type: Input }],
    rulesToHideDelete: [{ type: Input }],
    disableLoadingBlockUI: [{ type: Input }],
    rowStyleClass: [{ type: Input }],
    filterOnColumn: [{ type: Input }],
    customFilterOptions: [{ type: Input }],
    buttonClick: [{ type: Output }],
    pDatatableComponent: [{ type: ViewChild, args: [Table, { static: true },] }],
    extraButtons: [{ type: ContentChildren, args: [DatatableButtonComponent,] }],
    columns: [{ type: ContentChildren, args: [Column,] }],
    startedLoading: [{ type: Output }],
    finishedLoading: [{ type: Output }],
    onRowSelected: [{ type: Output }],
    showVisibleColumnsControl: [{ type: Input }],
    editMode: [{ type: Input }],
    dataKey: [{ type: Input }],
    onRowEditEvent: [{ type: Output }]
};

/**
 * Class DatatableSplitbuttonComponent
 * @class
 */
class DatatableSplitbuttonComponent {
    /**
     * ngOnInit method
     * @returns void
     */
    ngOnInit() {
    }
}
DatatableSplitbuttonComponent.decorators = [
    { type: Component, args: [{
                selector: 'datatable-splitbutton',
                template: "<p-splitButton label=\"{{label}}\" icon=\"{{icon}}\" (onClick)=\"method\" [model]=\"items\" styleClass=\"{{class}}\">\n</p-splitButton>"
            },] }
];
DatatableSplitbuttonComponent.propDecorators = {
    items: [{ type: Input }],
    label: [{ type: Input }],
    class: [{ type: Input }],
    icon: [{ type: Input }],
    method: [{ type: Input }]
};

/**
 * Class DatatableSplitbuttonModule
 * @class
 */
class DatatableSplitbuttonModule {
}
DatatableSplitbuttonModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    SplitButtonModule
                ],
                declarations: [
                    DatatableSplitbuttonComponent
                ],
                providers: [],
                exports: [
                    DatatableSplitbuttonComponent,
                    SplitButtonModule
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

class FilterColumn {
    constructor() {
        this.listaOriginal = [];
        this.lista = [];
        this.labelDefaultImplementation = false;
        this.updateFiltro = false;
        this.customFilterOptions = {};
        this.template = 'filter_text';
        this.outputEvent = new EventEmitter();
        this.debouncer = new Subject();
        this.resultado = [];
        this.listaFields = [];
    }
    ngOnInit() {
        this.debouncer
            .pipe(debounceTime((this.tableType === 'memory') ? 300 : 1000))
            .subscribe((value) => this.outputEvent.emit(value));
        this.template = `filter_${this.filterType}`;
    }
    ngOnChanges(changes) {
        if (this.checkChanges(changes, 'listaOriginal')) {
            this.preencherFields();
        }
    }
    checkChanges(changes, property) {
        return changes[property] && changes[property].previousValue != changes[property].currentValue;
    }
    /**
     * Método para propagar o evento de filtragem
     * @param event filtro
     */
    filtrar(event) {
        this.debouncer.next(this.filtro);
    }
    /**
     * Preenche os itens que serão exibidos no multiselect, removendo duplicidades
     */
    preencherFields() {
        this.listaFields = [];
        this.listaOriginal.filter(pi => pi[this.field] !== null).forEach(row => {
            let item = { label: row[this.field], value: row[this.field] };
            if (!this.verificarSeExisteField(item)) {
                this.listaFields.push(item);
            }
        });
    }
    /**
     *
     * @param field Verifica duplicidade de fields nas opções de seleção
     */
    verificarSeExisteField(field) {
        return this.listaFields.some(item => {
            return item.value == field.value;
        });
    }
    /**
     * Caso o usuaŕio não forneça uma lista para o options, será criada uma lista com
     * os valores presentes na tabela
     */
    getCustomFilterOptions() {
        if (this.customFilterOptions.hasOwnProperty(this.field)) {
            return this.customFilterOptions[this.field];
        }
        return this.listaFields;
    }
}
FilterColumn.decorators = [
    { type: Component, args: [{
                selector: 'basis-filter-column',
                template: "<div [ngSwitch]=\"filterType\" >\n    <div *ngSwitchCase=\"'text'\">\n        <div class=\"p-g form-group\">\n            <div class=\"p-md-12\">\n                <span class=\"p-float-label\">\n                    <input type=\"text\" pInputText (input)=\"filtrar($event)\" [(ngModel)]=\"filtro\" [style]=\"{width: '100%'}\">\n                    <label>{{ (header) ? header : 'Filtro' }}</label>\n                </span>\n            </div>\n        </div>\n    </div>\n    <div *ngSwitchCase=\"'select'\">\n        <div class=\"p-g form-group\">\n            <div class=\"p-md-12\">\n                <p-multiSelect\n                    [options]=\"getCustomFilterOptions()\"\n                    [defaultLabel]=\"(header)? header: '&nbsp;'\"\n                    [optionLabel]=\"'label'\"\n                    appendTo=\"body\"\n                    [ngModelOptions]=\"{standalone: true}\"\n                    (onChange)=\"filtrar($event)\"\n                    [(ngModel)]=\"filtro\"\n                    [style]=\"{'width':'100%', 'vertical-align':'top'}\">\n                </p-multiSelect>\n            </div>\n        </div>\n    </div>\n</div>\n"
            },] }
];
FilterColumn.ctorParameters = () => [];
FilterColumn.propDecorators = {
    listaOriginal: [{ type: Input }],
    lista: [{ type: Input }],
    field: [{ type: Input }],
    header: [{ type: Input }],
    labelDefaultImplementation: [{ type: Input }],
    labelDefaultName: [{ type: Input }],
    updateFiltro: [{ type: Input }],
    filterType: [{ type: Input }],
    tableType: [{ type: Input }],
    customFilterOptions: [{ type: Input }],
    template: [{ type: Input }],
    outputEvent: [{ type: Output }]
};

class FilterColumnModule {
}
FilterColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MultiSelectModule,
                    ButtonModule,
                    CheckboxModule,
                    DropdownModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule
                ],
                declarations: [
                    FilterColumn
                ],
                exports: [
                    FilterColumn
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

/**
 * Class PageNotificationService
 * @class
 */
class PageNotificationService extends NotificationProvider {
    /**
     * constructor method
     * @constructor
     * @param {MessageService} messageService
     */
    constructor(messageService) {
        super();
        this.messageService = messageService;
        /**
         * successSeverity property
         * @type {string}
         */
        this.successSeverity = 'success';
        /**
         * infoSeverity property
         * @type {string}
         */
        this.infoSeverity = 'info';
        /**
         * warnSeverity property
         * @type {string}
         */
        this.warnSeverity = 'warn';
        /**
         * errorSeverity property
         * @type {string}
         */
        this.errorSeverity = 'error';
        /**
         * createMsg property
         * @type {string}
         */
        this.createMsg = 'Registro incluído com sucesso!';
        /**
         * updateMsg property
         * @type {string}
         */
        this.updateMsg = 'Registro alterado com sucesso!';
        /**
         * deleteMsg property
         * @type {string}
         */
        this.deleteMsg = 'Registro excluído com sucesso!';
    }
    /**
     * addCreateMsg method
     * @param {string} title
     */
    addCreateMsg(title) {
        this.addSuccessMessage(this.createMsg, title);
    }
    /**
     * addSuccessMessage method
     * @param {string} message
     * @param {string} title
     */
    addSuccessMessage(message, title) {
        this.addMsg(this.successSeverity, message, title);
    }
    /**
     * addMsg method
     * @param {string} severity
     * @param {string} msg
     * @param {string} title
     */
    addMsg(severity, msg, title) {
        this.messageService.add({
            severity: severity,
            summary: title,
            detail: msg
        });
    }
    /**
     * addUpdateMsg method
     * @param {string} title
     */
    addUpdateMsg(title) {
        this.addSuccessMessage(this.updateMsg, title);
    }
    /**
     * addDeleteMsg method
     * @param {string} title
     */
    addDeleteMsg(title) {
        this.addSuccessMessage(this.deleteMsg, title);
    }
    /**
     * addInfoMessage method
     * @param {string} message
     * @param {string} title
     */
    addInfoMessage(message, title) {
        this.addMsg(this.infoSeverity, message, title);
    }
    /**
     * addWarnMessage method
     * @param {string} message
     * @param {string} title
     */
    addWarnMessage(message, title) {
        this.addMsg(this.warnSeverity, message, title);
    }
    /**
     * addErrorMessage method
     * @param {string} message
     * @param {string} title
     */
    addErrorMessage(message, title) {
        this.addMsg(this.errorSeverity, message, title);
    }
    /**
     * addErrorProblem method
     * @param {ApplicationProblemType} problem
     */
    addErrorProblem(problem) {
        this.addMsg(this.errorSeverity, problem.detail, problem.title);
    }
}
PageNotificationService.ɵprov = ɵɵdefineInjectable({ factory: function PageNotificationService_Factory() { return new PageNotificationService(ɵɵinject(MessageService)); }, token: PageNotificationService, providedIn: "root" });
PageNotificationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PageNotificationService.ctorParameters = () => [
    { type: MessageService }
];

class ShowColumn {
    constructor(pageNotificationService) {
        this.pageNotificationService = pageNotificationService;
        /**
         * lista de colunas disponívels na tabela
         * @type {Array}
         */
        this.options = [];
        /**
         * Valores do select de colunas
         * @type {Array}
         */
        this.values = [];
        /**
         * Último valor válido para o select.
         * @type {Array}
         */
        this.lastValue = [];
        /**
         * Evento para atualizar a visibilidade das colunas da tabela
         * @type {EventEmitter}
         */
        this.updateVisibleColumns = new EventEmitter();
    }
    ngOnInit() {
        this.columns.forEach((column) => {
            const col = { field: column.field, filterType: column.filterType, header: column.header };
            this.options.push(col);
            this.values.push(col);
            this.lastValue.push(col);
        });
    }
    mostrarColunas(event) {
        if (this.values.length) {
            this.lastValue = event.value;
            this.updateVisibleColumns.emit(this.values);
        }
        else {
            this.lastValue.map((item) => this.values.push(item));
            this.pageNotificationService.addErrorMessage('Não é possível exibir menos de uma coluna');
        }
    }
}
ShowColumn.decorators = [
    { type: Component, args: [{
                selector: 'basis-show-column',
                template: "<p-multiSelect\n    class=\"column\"\n    defaultLabel=\"Selecionar colunas\"\n    [optionLabel]=\"'header'\"\n    [displaySelectedLabel]=\"false\"\n    [ngModelOptions]=\"{ standalone: true }\"\n    (onChange)=\"mostrarColunas($event)\"\n    [options]=\"options\"\n    [(ngModel)]=\"values\"\n    [style]=\"{ width: '100%' }\">\n</p-multiSelect>\n"
            },] }
];
ShowColumn.ctorParameters = () => [
    { type: PageNotificationService }
];
ShowColumn.propDecorators = {
    columns: [{ type: Input }],
    updateVisibleColumns: [{ type: Output }]
};

class ShowColumnModule {
}
ShowColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MultiSelectModule,
                    ButtonModule,
                    CheckboxModule,
                    DropdownModule,
                    FormsModule,
                    ReactiveFormsModule,
                    InputTextModule
                ],
                declarations: [
                    ShowColumn
                ],
                exports: [
                    ShowColumn
                ],
                schemas: [CUSTOM_ELEMENTS_SCHEMA]
            },] }
];

class ActionButtonComponent {
    constructor() {
        this.action = false;
    }
    ngOnInit() { }
}
ActionButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-action-button',
                template: "<div class=\"action-button\">\n    <a (click)=\"action = !this.action\"><i class=\"fas fa-ellipsis-v\"></i></a>\n    <div class=\"action-button-over\" *ngIf=\"action\">\n        <ng-content></ng-content>\n        <a class=\"action-button-close\" [ngClass]=\"{'rotate-90':action}\" (click)=\"action = !this.action\" pTooltip=\"Fechar\" tooltipPosition=\"top\"><i class=\"fas fa-ellipsis-v\"></i></a>\n    </div>\n</div>\n",
                styles: [".action-button{position:relative;display:inline-flex;width:20px;height:10px}.action-button>a{background-color:#557089;width:20px;height:20px;border-radius:60px;color:#fff;display:flex;align-items:center;justify-content:center;cursor:pointer;transform:rotate(0deg);transition:all .3s ease-in-out}.action-button>a:hover{background-color:#33a987}.action-button-over{background-color:#465b71;display:inline-flex;border-radius:60px;padding:0 35px 0 15px;position:absolute;right:-7px;top:-5px}.action-button-over a.action-button-close:hover{color:#fff}.action-button-over .action-button-close{background-color:#33a987;width:20px;height:20px;border-radius:60px;color:#fff;display:inline-flex;align-items:center;justify-content:center;cursor:pointer;transform:rotate(0deg);position:absolute;right:7px;top:5px;transition:all .3s ease-in-out}.action-button-over .action-button-close.rotate-90{transform:rotate(90deg)!important}:host ::ng-deep .action-button-over a{color:#fff;padding:6px;cursor:pointer}:host ::ng-deep .action-button-over a:hover{color:#bfd974}:host ::ng-deep .action-button-over a img{position:absolute;right:10px}"]
            },] }
];
ActionButtonComponent.ctorParameters = () => [];

/**
 * Class DatatableModule
 * @class
 */
class DatatableModule {
}
DatatableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ButtonModule,
                    SplitButtonModule,
                    TooltipModule,
                    TableModule,
                    BlockUIModule,
                    ProgressSpinnerModule,
                    DatatableSplitbuttonModule,
                    HttpClientModule,
                    PaginatorModule,
                    FilterColumnModule,
                    ShowColumnModule,
                    InputTextModule
                ],
                declarations: [
                    DatatableComponent,
                    DatatableButtonComponent,
                    Column,
                    ActionButtonComponent
                ],
                providers: [
                    { provide: DatatableService, useClass: DatatableService, deps: [HttpClient] },
                    DataProviderFactory
                ],
                exports: [
                    DatatableComponent,
                    DatatableButtonComponent,
                    FilterColumnModule,
                    ShowColumnModule,
                    Column
                ]
            },] }
];

/**
 * Class BlockUiComponent
 * @class
 */
class BlockUiComponent {
    /**
     * constructor method
     * @constructor
     * @param {BlockUiService} service
     */
    constructor(service) {
        this.service = service;
        /**
         * status property
         * @type {boolean}
         * @public
         */
        this.status = false;
    }
    /**
     * ngOnInit method
     * @returns void
     */
    ngOnInit() {
        this.subscription = this.service.loaderStatus.subscribe((blockui) => {
            this.status = blockui.status;
        });
    }
    /**
     * ngOnDestroy methods
     * @returns void
     */
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    /**
     * isBlocked method
     * @returns boolean
     */
    isBlocked() {
        return this.status;
    }
    /**
     * show method
     * @returns false
     */
    show() {
        this.status = true;
    }
    /**
     * hide methods
     * @returns void
     */
    hide() {
        this.status = false;
    }
}
BlockUiComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-block-ui',
                template: "<p-blockUI [blocked]=\"isBlocked()\">\n    <div class=\"center-screen\">\n        <p-progressSpinner></p-progressSpinner>\n    </div>\n</p-blockUI>\n",
                styles: [".center-screen{display:flex;flex-direction:column;justify-content:center;align-items:center;text-align:center;min-height:100vh}"]
            },] }
];
BlockUiComponent.ctorParameters = () => [
    { type: BlockUiService }
];

/**
 * Class BlockUiModule
 * @class
 */
class BlockUiModule {
}
BlockUiModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    BlockUIModule,
                    ProgressSpinnerModule,
                ],
                declarations: [
                    BlockUiComponent
                ],
                providers: [
                    {
                        provide: HTTP_INTERCEPTORS,
                        useClass: BlockUiInterceptor,
                        multi: true
                    },
                    BlockUiService
                ],
                exports: [
                    BlockUIModule,
                    BlockUiComponent,
                    ProgressSpinnerModule
                ]
            },] }
];

/**
 * Class PageNotificationComponent
 * @class
 */
class PageNotificationComponent {
    constructor() {
        /**
         * duration property
         * @type {number}
         */
        this.duration = 3000;
    }
}
PageNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-page-notification',
                template: "<p-toast></p-toast>\n"
            },] }
];
PageNotificationComponent.propDecorators = {
    duration: [{ type: Input }]
};

/**
 * Class PageNotificationModule
 * @class
 */
class PageNotificationModule {
}
PageNotificationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ToastModule
                ],
                declarations: [
                    PageNotificationComponent
                ],
                exports: [
                    PageNotificationComponent
                ],
                providers: [
                    MessageService,
                    PageNotificationService,
                    {
                        provide: NotificationProvider,
                        useExisting: PageNotificationService
                    }
                ]
            },] }
];

class FormNotificationComponent extends FormNotificationComponentSuperclass {
}
FormNotificationComponent.decorators = [
    { type: Component, args: [{
                selector: '[form-notification]',
                template: "<ng-content></ng-content>\n<small class=\"p-invalid\">{{message}}</small>"
            },] }
];

/**
 * Módulo para adicionar funcionalidade de notificação de erros de formulários.
 * @module
 */
class FormNotificationModule {
}
FormNotificationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormNotificationBaseModule
                ],
                declarations: [
                    FormNotificationComponent
                ],
                exports: [
                    FormNotificationComponent
                ]
            },] }
];

/**
 * Class ErrorStackComponent
 * @class
 */
class ErrorStackComponent {
    /**
     * constructor method
     * @constructor
     * @param {ErrorStackService} errorStack
     */
    constructor(errorStack) {
        this.errorStack = errorStack;
        /**
         * title property
         * @type {string}
         */
        this.title = 'Error Stack';
        /**
         * errors property
         * @type {NamedErrorType}
         */
        this.errors = [];
    }
    /**
     * ngOnInit method
     * @returns void
     */
    ngOnInit() {
        this.errorSubscription = this.errorStack.errors.subscribe((error) => {
            this.errors = [error, ...this.errors];
        });
    }
    /**
     * ngOnDestroy method
     * @returns void
     */
    ngOnDestroy() {
        this.errorSubscription.unsubscribe();
    }
}
ErrorStackComponent.decorators = [
    { type: Component, args: [{
                selector: 'basis-error-stack',
                template: "<ng-template #defaultTemplate>\n    <div class=\"p-grid\">\n        <div class=\"p-g-12\">\n            <div class=\"card no-margin\">\n                <h1>{{ title }}</h1>\n                <p-table \n                    [value]=\"errors\" \n                    styleClass=\"p-datatable-customers\"\n                    [rowHover]=\"true\"\n                    [paginator]=\"false\" \n                    [rows]=\"5\" first=\"0\">\n                    <ng-template pTemplate=\"header\">\n                        <tr>\n                            <th style=\"width: 20%; text-align: center\">Data</th>\n                            <th style=\"width: 20%; text-align: center\">C\u00F3digo de identifica\u00E7\u00E3o</th>\n                            <th>Mensagem</th>\n                            <th style=\"width: 10%; text-align: center\">A\u00E7\u00E3o</th>\n                        </tr>\n                    </ng-template>\n                    <ng-template pTemplate=\"body\" let-error>\n                        <tr>\n                            <td style=\"width: 20%; text-align: center\">{{error.createdAt|date: 'dd/MM/y H:mm:ss'}}</td>\n                            <td style=\"width: 20%; text-align: center\">{{error.correlationId || 'Indispon\u00EDvel'}}</td>\n                            <td>{{error.message}}</td>\n                            <td style=\"width: 10%; text-align: center\">\n                                <button pButton type=\"button\" pTooltip=\"Copiar erro para \u00E1rea de transfer\u00EAncia\" tooltipPosition=\"left\" class=\"p-button-primary\" icon=\"fa fa-copy\" [clipboard]=\"error.fullMessage\"></button>\n                            </td>\n                        </tr>\n                    </ng-template>\n                    <ng-template pTemplate=\"emptymessage\" let-columns>\n                        <tr>\n                            <td colspan=\"4\">\n                                Nenhum erro foi registrado at\u00E9 o momento.\n                            </td>\n                        </tr>\n                    </ng-template>\n                </p-table>\n            </div>\n        </div>\n    </div>\n</ng-template>\n<ng-container *ngTemplateOutlet=\"template? template: defaultTemplate\"></ng-container>\n"
            },] }
];
ErrorStackComponent.ctorParameters = () => [
    { type: ErrorStackService }
];
ErrorStackComponent.propDecorators = {
    title: [{ type: Input }],
    template: [{ type: Input }]
};

/**
 * Class ErrorStackModule
 * @class
 */
class ErrorStackModule {
}
ErrorStackModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TableModule,
                    ButtonModule,
                    TooltipModule,
                    ClipboardModule
                ],
                declarations: [
                    ErrorStackComponent
                ],
                providers: [
                    ErrorStackService,
                    {
                        provide: ErrorProvider,
                        useClass: ErrorStackProviderService,
                        multi: true
                    }
                ],
                exports: [
                    ErrorStackComponent
                ]
            },] }
];

class CrudFormComponent {
    constructor(route) {
        this.route = route;
        this.disableSave = false;
        this.listRoute = "../../list";
    }
    ngOnInit() {
        this.route.paramMap.subscribe((params) => {
            this.action = params.get('action');
            if (params.get('id')) {
                this.route.data.subscribe((data) => {
                    if (data.value) {
                        this.form.patchValue(data.value);
                    }
                });
            }
            else {
                this.listRoute = "../list";
            }
            if (this.action === "view") {
                this.form.disable();
            }
            else if (this.form.disabled) {
                this.form.enable();
            }
        });
    }
}
CrudFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'nCrudForm',
                template: "<nForm [form]=\"form\" [action]=\"action\" [route]=\"[listRoute]\" [disableSave]=\"disableSave\">\n    <ng-content></ng-content>\n    <button nButton pButton type=\"button\" [routerLink]=\"[listRoute]\" label=\"Voltar\" class=\"p-mr-2 p-mb-2\"></button>\n</nForm>\n"
            },] }
];
CrudFormComponent.ctorParameters = () => [
    { type: ActivatedRoute }
];
CrudFormComponent.propDecorators = {
    form: [{ type: Input }],
    service: [{ type: Input }],
    disableSave: [{ type: Input }]
};

const CRUD_SERVICE = new InjectionToken("CRUD_SERVICE");

class CrudListComponent {
    constructor(crudService, confirmationService, route, router) {
        this.crudService = crudService;
        this.confirmationService = confirmationService;
        this.route = route;
        this.router = router;
        this.action = "findAll";
        this.findLabel = "Pesquisar";
        this.disableSave = false;
        this.disableEdit = false;
        this.disableView = false;
        this.disableDelete = false;
        this.find = new EventEmitter();
    }
    ngOnInit() {
        if (this.service) {
            this.crudService = this.service;
        }
        if (!this.url) {
            this.url = this.crudService.uri;
        }
    }
    datatableClick(event) {
        if (event.selection) {
            switch (event.button) {
                case "edit":
                case "view":
                    this.router.navigate([`../${event.button}`, event.selection.id], { relativeTo: this.route });
                    break;
                case "delete":
                    this.confirmationService.confirm({
                        message: 'Você tem certeza que deseja excluir o registro?',
                        accept: () => this.crudService.delete(event.selection.id)
                            .subscribe(() => this.datatable.filter())
                    });
                    break;
            }
        }
    }
    findAll(event) {
        if (this.find.observers.length) {
            this.find.emit(this.form.value);
        }
        else {
            this.datatable.filterParams = {};
            Object.keys(this.form.value).forEach(element => {
                let value = this.form.value[element];
                if (value) {
                    this.datatable.filterParams[element] =
                        value instanceof Date ? JSON.stringify(value).replace(/"/g, "") : value;
                }
            });
            this.datatable.filter();
        }
    }
    ngAfterContentInit() {
        const datatableNgAfterContentInit = this.datatable.pDatatableComponent.ngAfterContentInit;
        this.datatable.pDatatableComponent.ngAfterContentInit = () => {
            this.datatable.pDatatableComponent.columns = this.columns.toArray();
            datatableNgAfterContentInit.call(this.datatable.pDatatableComponent);
        };
    }
    ngAfterViewInit() {
        for (let i in this.datatableExtraParams) {
            this.datatable[i] = this.datatableExtraParams[i];
        }
    }
}
CrudListComponent.decorators = [
    { type: Component, args: [{
                selector: 'nCrudList',
                template: "<nForm [form]=\"form\" (save)=\"findAll($event)\" [saveLabel]=\"findLabel\">\n    <ng-content select=\"[nForm]\"></ng-content>\n    <button nButton pButton type=\"button\" [routerLink]=\"['../save']\" label=\"Novo\" *ngIf=\"!disableSave\" class=\"p-mr-2 p-mb-2\"></button>\n</nForm>\n<basis-datatable #datatable \n    [value]=\"result\" \n    (buttonClick)=\"datatableClick($event)\" \n    [url]=\"url\"\n    [disableEdit]=\"disableEdit\" \n    [disableView]=\"disableView\"     \n    [disableDelete]=\"disableDelete\">\n    <ng-content select=\"p-column\"></ng-content>\n</basis-datatable>\n\n<p-confirmDialog header=\"Confirmar Exclus\u00E3o\" acceptLabel=\"Sim\" rejectLabel=\"N\u00E3o\" icon=\"pi pi-exclamation-triangle\"></p-confirmDialog>\n"
            },] }
];
CrudListComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CRUD_SERVICE,] }] },
    { type: ConfirmationService },
    { type: ActivatedRoute },
    { type: Router }
];
CrudListComponent.propDecorators = {
    form: [{ type: Input }],
    action: [{ type: Input }],
    findLabel: [{ type: Input }],
    service: [{ type: Input }],
    url: [{ type: Input }],
    disableSave: [{ type: Input }],
    disableEdit: [{ type: Input }],
    disableView: [{ type: Input }],
    disableDelete: [{ type: Input }],
    datatableExtraParams: [{ type: Input }],
    find: [{ type: Output }],
    datatable: [{ type: ViewChild, args: ['datatable', { static: true },] }],
    columns: [{ type: ContentChildren, args: [Column,] }]
};

class CrudResolveGuard {
    constructor(crudService) {
        this.crudService = crudService;
    }
    resolve(route) {
        return this.crudService.find(route.paramMap.get('id'));
    }
}
CrudResolveGuard.decorators = [
    { type: Injectable }
];
CrudResolveGuard.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CRUD_SERVICE,] }] }
];

function crudRouteBuilder(route, parent, list, form) {
    return {
        path: route,
        component: parent,
        data: { breadcrumb: route },
        children: [
            {
                path: 'list',
                component: list,
                data: { breadcrumb: 'list' },
            },
            {
                path: ':action',
                component: form,
                data: { breadcrumb: ':action' },
            },
            {
                path: ':action/:id',
                component: form,
                resolve: {
                    value: CrudResolveGuard
                },
                data: { breadcrumb: ':action' },
            }
        ]
    };
}

class CrudServiceNuvem {
    constructor(uri, http) {
        this.uri = uri;
        this.http = http;
    }
    save(entity) {
        return this.http.post(this.uri, entity);
    }
    edit(entity) {
        return this.http.put(this.uri, entity);
    }
    find(id) {
        return this.http.get(`${this.uri}/${id}`);
    }
    delete(id) {
        return this.http.delete(`${this.uri}/${id}`);
    }
    findAll(entity) {
        let params = new HttpParams();
        for (let field in entity) {
            params = params.append(field, entity[field]);
        }
        return this.http.get(`${this.uri}`, { params: params });
    }
}

var STATUS;
(function (STATUS) {
    STATUS[STATUS["OK"] = 200] = "OK";
    STATUS[STATUS["CREATED"] = 201] = "CREATED";
})(STATUS || (STATUS = {}));
class SuccessMessageHandlerInterceptor {
    constructor(notification) {
        this.notification = notification;
    }
    intercept(req, next) {
        return next.handle(req).pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                if (event.headers.has("X-nuvem-alert")) {
                    this.notification.addSuccessMessage(event.headers.get("X-nuvem-alert"));
                }
                else if ((event.status === STATUS.OK || event.status === STATUS.CREATED) && req.method != "GET") {
                    this.notification.addSuccessMessage("Operação realizada com sucesso!");
                }
            }
        }));
    }
}
SuccessMessageHandlerInterceptor.ɵprov = ɵɵdefineInjectable({ factory: function SuccessMessageHandlerInterceptor_Factory() { return new SuccessMessageHandlerInterceptor(ɵɵinject(PageNotificationService)); }, token: SuccessMessageHandlerInterceptor, providedIn: "root" });
SuccessMessageHandlerInterceptor.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SuccessMessageHandlerInterceptor.ctorParameters = () => [
    { type: PageNotificationService }
];
const httpInterceptorProviders = [
    { provide: HTTP_INTERCEPTORS, useClass: SuccessMessageHandlerInterceptor, multi: true },
];

class FieldComponent extends WrappedFormControlSuperclass {
    constructor(controlContainer, injector) {
        super(injector);
        this.controlContainer = controlContainer;
        this.injector = injector;
        this.onBlur = new EventEmitter();
        this.onSelect = new EventEmitter();
        this.onFocus = new EventEmitter();
    }
    get name() {
        return this._name ? this._name : this.formControlName;
    }
    set name(value) {
        this._name = value;
    }
    get label() {
        return this.required ? `${this._label}*` : this._label;
    }
    set label(value) {
        this._label = value;
    }
    ngOnInit() {
        this.setValidators();
        this.setRequired();
    }
    setRequired() {
        if (this.required) {
            if (this.input instanceof ElementRef) {
                this.input.nativeElement.required = true;
            }
            else {
                this.input.required = true;
            }
        }
    }
    setElementRefAttr(attr, value) {
        if (value && this.input instanceof ElementRef) {
            this.input.nativeElement[attr] = value;
        }
    }
    setFormControlValidators() {
        if (this.controlContainer && this.formControlName) {
            let validator = this.controlContainer.control.get(this.formControlName).validator;
            if (validator) {
                this.formControl.setValidators(validator);
            }
        }
    }
    setValidators() {
        if (this.controlContainer && this.formControlName) {
            let validator = this.controlContainer.control.get(this.formControlName).validator;
            if (validator) {
                this.formControl.setValidators(validator);
            }
        }
    }
    ngAfterViewInit() {
        for (let i in this.extraParams) {
            this.input[i] = this.extraParams[i];
        }
    }
    onBlurEvent(event) {
        this.onBlur.emit(event);
    }
    onSelectEvent(event) {
        this.onSelect.emit(event);
    }
    onFocusEvent(event) {
        this.onFocus.emit(event);
    }
}
FieldComponent.decorators = [
    { type: Directive, args: [{
                selector: "[nField]"
            },] }
];
FieldComponent.ctorParameters = () => [
    { type: ControlContainer },
    { type: Injector }
];
FieldComponent.propDecorators = {
    form: [{ type: Input }],
    formControlName: [{ type: Input }],
    extraParams: [{ type: Input }],
    required: [{ type: Input }],
    onBlur: [{ type: Output }],
    onSelect: [{ type: Output }],
    onFocus: [{ type: Output }],
    input: [{ type: ViewChild, args: ["input", { static: false },] }],
    name: [{ type: Input }],
    label: [{ type: Input }]
};

class InputTextComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.type = "text";
    }
    ngOnInit() {
        super.ngOnInit();
        this.setElementRefAttr("min", this.min);
        this.setElementRefAttr("max", this.max);
        this.setElementRefAttr("minLength", this.minLength);
        this.setElementRefAttr("maxLength", this.maxLength);
        this.setElementRefAttr("pattern", this.pattern);
    }
}
InputTextComponent.decorators = [
    { type: Component, args: [{
                selector: "[nInputText]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <input #input\n        pInputText\n        [ngClass]=\"{ 'ng-invalid ng-dirty': notification.message }\"\n        [type]=\"type\"\n        [name]=\"name\"\n        (blur)=\"onBlurEvent($event)\"\n        (focus)=\"onFocusEvent($event)\"\n        [formControl]=\"formControl\" />\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(InputTextComponent)]
            },] }
];
InputTextComponent.propDecorators = {
    minLength: [{ type: Input }],
    maxLength: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    pattern: [{ type: Input }],
    type: [{ type: Input }]
};

const CALENDAR_LOCALE = {
    firstDayOfWeek: 0,
    dayNames: ["Domingo", "Segunda", "Terça", "Quarta", "Quinta", "Sexta", "Sábado"],
    dayNamesShort: ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"],
    dayNamesMin: ["D", "S", "T", "Q", "Q", "S", "S"],
    monthNames: ["Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"],
    monthNamesShort: ["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"],
    today: 'Hoje',
    clear: 'Limpar',
    dateFormat: 'dd/mm/yy',
    weekHeader: 'Semana'
};

class CalendarComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.maxDate = null;
        this.yearRange = null;
        this.monthNavigator = false;
        this.yearNavigator = false;
        this.locale = CALENDAR_LOCALE;
    }
    outerToInner(value) {
        return value ? new Date(value) : null;
    }
}
CalendarComponent.decorators = [
    { type: Component, args: [{
                selector: "[nCalendar]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <p-calendar #input\n        [ngClass]=\"{ 'ng-invalid ng-dirty': notification.message }\"\n        [name]=\"name\"\n        [formControl]=\"formControl\"\n        [locale]=\"locale\"\n        [dateFormat]=\"locale.dateFormat\"\n        [yearRange]=\"yearRange\"\n        [maxDate]=\"maxDate\"\n        [monthNavigator]=\"monthNavigator\"\n        [yearNavigator]=\"yearNavigator\"\n        (onBlur)=\"onBlurEvent($event)\"\n        (onFocus)=\"onFocusEvent($event)\"\n        (onSelect)=\"onSelectEvent($event)\">\n    </p-calendar>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(CalendarComponent)]
            },] }
];
CalendarComponent.propDecorators = {
    maxDate: [{ type: Input }],
    yearRange: [{ type: Input }],
    monthNavigator: [{ type: Input }],
    yearNavigator: [{ type: Input }],
    locale: [{ type: Input }]
};

class TextAreaComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.autoResize = false;
    }
}
TextAreaComponent.decorators = [
    { type: Component, args: [{
                selector: "[nTextArea]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <textarea #input\n        pInputTextarea\n        [ngClass]=\"{ 'ng-invalid ng-dirty': notification.message }\"\n        type=\"text\"\n        [name]=\"name\"\n        [autoResize]=\"autoResize\"\n        [rows]=\"rows\"\n        [cols]=\"cols\"\n        [minLength]=\"minLength\"\n        [maxLength]=\"maxLength\"\n        [formControl]=\"formControl\"\n        (blur)=\"onBlurEvent($event)\"\n        (focus)=\"onFocusEvent($event)\">\n    </textarea>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(TextAreaComponent)]
            },] }
];
TextAreaComponent.propDecorators = {
    autoResize: [{ type: Input }],
    rows: [{ type: Input }],
    cols: [{ type: Input }],
    minLength: [{ type: Input }],
    maxLength: [{ type: Input }]
};

class DropdownComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.virtualScroll = false;
        this.filter = false;
        this.itemSize = 30;
        this.options = [];
        this.onChange = new EventEmitter();
    }
    ngOnInit() {
        super.ngOnInit();
        if (this.service) {
            this.service.findAll(null).subscribe(data => {
                this.options = data;
            });
        }
    }
    onChangeEvent(event) {
        this.onChange.emit(event);
    }
    outerToInner(value) {
        if (value && value.id) {
            this.service.find(value.id).subscribe((data) => {
                this.formControl.setValue(data);
            });
        }
        return value;
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: "[nDropdown]",
                template: "<span #notification form-notification class=\"p-float-label custom-select\" [name]=\"name\" [form]=\"form\">\n    <p-dropdown #input\n        [formControl]=\"formControl\"\n        [optionLabel]=\"optionLabel\"\n        [options]=\"options\"\n        [filter]=\"filter\"\n        [virtualScroll]=\"virtualScroll\"\n        [itemSize]=\"itemSize\"\n        (onChange)=\"onChangeEvent($event)\">\n    </p-dropdown>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(DropdownComponent)]
            },] }
];
DropdownComponent.propDecorators = {
    optionLabel: [{ type: Input }],
    virtualScroll: [{ type: Input }],
    filter: [{ type: Input }],
    itemSize: [{ type: Input }],
    service: [{ type: Input }],
    options: [{ type: Input }],
    onChange: [{ type: Output }]
};

class InputMaskComponent extends FieldComponent {
}
InputMaskComponent.decorators = [
    { type: Component, args: [{
                selector: "[nInputMask]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <p-inputMask #input\n        pInputText\n        [ngClass]=\"{ 'ng-invalid ng-dirty': notification.message }\"\n        [name]=\"name\"\n        (onBlur)=\"onBlurEvent($event)\"\n        (onFocus)=\"onFocusEvent($event)\"\n        [formControl]=\"formControl\"\n        [mask]=\"mask\"\n        [placeholder]=\"placeholder\"></p-inputMask>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(InputMaskComponent)]
            },] }
];
InputMaskComponent.propDecorators = {
    mask: [{ type: Input }],
    placeholder: [{ type: Input }]
};

class CheckComponent extends FieldComponent {
    /**
     * Método construtor responsável por carregar o serviço de validação
     * @param formNotificationService
     */
    constructor(controlContainer, injector, formNotificationService) {
        super(controlContainer, injector);
        this.formNotificationService = formNotificationService;
    }
    /**
     * Método Inicial para subscrição no endpoint responsável por validar o formulário
     */
    ngOnInit() {
        super.ngOnInit();
        this.subscription = this.formNotificationService
            .notifications(this.form, this.name)
            .subscribe((notification) => {
            if (notification instanceof FieldFormNotification) {
                this.message = notification.message;
            }
            else {
                this.message = null;
            }
        });
    }
    /**
     * Método responsável por realizar a saida das subscrições do endpont de validação
     */
    ngOnDestroy() {
        super.ngOnDestroy();
        this.subscription.unsubscribe();
    }
}
CheckComponent.decorators = [
    { type: Component, args: [{
                selector: "[nCheck]",
                template: "<div class=\"p-g-12 semborda\">\n    <div class=\"p-g-4\" [innerHTML]=\"label\"></div>\n    <div class=\"p-g-4\">\n        <p-radioButton\n            [ngClass]=\"{ 'ng-invalid ng-dirty': message }\"\n            id=\"sim\"\n            type=\"radio\"\n            [value]=\"true\"\n            [name]=\"name\"\n            [formControl]=\"formControl\"\n            pRadioButton></p-radioButton>\n        <label>Sim</label>\n    </div>\n    <div class=\"p-g-4\">\n        <p-radioButton\n            [ngClass]=\"{ 'ng-invalid ng-dirty': message }\"\n            id=\"n\u00E3o\"\n            type=\"radio\"\n            [value]=\"false\"\n            name=\"correspondencia\"\n            [formControl]=\"formControl\"\n            pRadioButton></p-radioButton>\n        <label>N\u00E3o</label>\n    </div>\n    <ng-content></ng-content>\n</div>\n",
                providers: [provideValueAccessor(CheckComponent)]
            },] }
];
CheckComponent.ctorParameters = () => [
    { type: ControlContainer },
    { type: Injector },
    { type: FormNotificationService }
];

class FormComponent {
    constructor(crudService, activatedRoute, router) {
        this.crudService = crudService;
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.action = "save";
        this.saveLabel = "Salvar";
        this.disableSave = false;
        this.save = new EventEmitter();
        this.reset = new EventEmitter();
    }
    ngOnInit() {
        if (this.service) {
            this.crudService = this.service;
        }
    }
    submit() {
        if (this.save.observers.length) {
            this.save.emit(this.form.value);
        }
        else {
            this.crudService[this.action](this.form.value)
                .subscribe(() => {
                if (this.route) {
                    this.router.navigate(this.route, { relativeTo: this.activatedRoute });
                }
                else if (this.reset.observers.length) {
                    this.reset.emit(this.form);
                }
                else {
                    this.form.reset();
                }
            });
        }
    }
}
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'nForm',
                template: "<div class=\"p-grid\">\n    <div class=\"p-col-12\">\n        <form (submit)=\"submit()\" class=\"form-group\">\n            <ng-content></ng-content>\n            <div *ngIf=\"!disableSave\">\n                <button pButton type=\"submit\" [label]=\"saveLabel\" [disabled]=\"form.disabled || form.invalid\" class=\"p-mr-2 p-mb-2\"></button>\n                <ng-content select=\"[nButton]\"></ng-content>\n            </div>\n        </form>\n    </div>\n</div>"
            },] }
];
FormComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [CRUD_SERVICE,] }] },
    { type: ActivatedRoute },
    { type: Router }
];
FormComponent.propDecorators = {
    form: [{ type: Input }],
    route: [{ type: Input }],
    action: [{ type: Input }],
    saveLabel: [{ type: Input }],
    service: [{ type: Input }],
    disableSave: [{ type: Input }],
    save: [{ type: Output }],
    reset: [{ type: Output }]
};

class ValidationMessageComponent {
}
ValidationMessageComponent.decorators = [
    { type: Component, args: [{
                selector: 'nValidationMessage',
                template: "<ng-container *ngIf=\"control.invalid && (control.dirty || control.touched) && control.errors\">\n    <div class=\"form-notification-msg p-message p-messages-error p-corner-all\" >\n        <ng-container *ngIf=\"control.errors.required\">\n            campo obrigat\u00F3rio\n        </ng-container>\n        <ng-container *ngIf=\"control.errors.minlength\">\n            tamanho m\u00EDnimo {{ control.errors.minlength.requiredLength }}\n        </ng-container>\n        <ng-container *ngIf=\"control.errors.maxlength\">\n            tamanho m\u00E1ximo {{ control.errors.maxlength.requiredLength }}\n        </ng-container>\n        <ng-container *ngIf=\"control.errors.min\">\n            valor m\u00EDnimo {{ control.errors.min.min }}\n        </ng-container>\n        <ng-container *ngIf=\"control.errors.max\">\n            valor m\u00E1ximo {{ control.errors.max.max }}\n        </ng-container>\n        <ng-container *ngIf=\"control.errors.email || control.errors.pattern\">\n            campo inv\u00E1lido\n        </ng-container>\n    </div>\n</ng-container>\n"
            },] }
];
ValidationMessageComponent.propDecorators = {
    control: [{ type: Input }]
};

class AutoCompleteComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.virtualScroll = false;
        this.itemSize = 30;
    }
    selectItem(option) {
        this.formControl.setValue(option);
    }
    findAll(event) {
        let query = {};
        query[this.field] = event.query;
        this.service.findAll(query).subscribe(data => {
            this.results = data;
        });
    }
    outerToInner(value) {
        if (value && value.id && !value[this.field]) {
            this.service.find(value.id).subscribe((data) => {
                this.formControl.setValue(data);
            });
        }
        return value;
    }
}
AutoCompleteComponent.decorators = [
    { type: Component, args: [{
                selector: "[nAutoComplete]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <p-autoCompleteCustom #input\n        [formControl]=\"formControl\"\n        [suggestions]=\"results\"\n        [virtualScroll]=\"virtualScroll\"\n        [itemSize]=\"itemSize\"\n        (onBlur)=\"onBlurEvent($event)\"\n        (onSelect)=\"onSelectEvent($event)\"\n        (onFocus)=\"onFocusEvent($event)\"\n        (completeMethod)=\"findAll($event)\"\n        [field]=\"field\">\n    </p-autoCompleteCustom>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(AutoCompleteComponent)]
            },] }
];
AutoCompleteComponent.propDecorators = {
    field: [{ type: Input }],
    virtualScroll: [{ type: Input }],
    itemSize: [{ type: Input }],
    service: [{ type: Input }]
};

const AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => AutoCompleteCustomComponent),
    multi: true
};
class AutoCompleteCustomComponent extends AutoComplete {
    constructor(el, renderer, cd, differs) {
        super(el, renderer, cd, differs);
        this.el = el;
        this.renderer = renderer;
        this.cd = cd;
        this.differs = differs;
    }
}
AutoCompleteCustomComponent.decorators = [
    { type: Component, args: [{
                selector: 'p-autoCompleteCustom',
                template: "<span [ngClass]=\"{'p-autocomplete p-component':true,'p-autocomplete-dd':dropdown,'p-autocomplete-multiple':multiple}\" [ngStyle]=\"style\" [class]=\"styleClass\">\n    <input *ngIf=\"!multiple\" #in [attr.type]=\"type\" [attr.id]=\"inputId\" [ngStyle]=\"inputStyle\" [class]=\"inputStyleClass\" [autocomplete]=\"autocomplete\" [attr.required]=\"required\" [attr.name]=\"name\"\n        [ngClass]=\"'p-inputtext p-component p-state-default p-corner-all p-autocomplete-input'\" [value]=\"inputFieldValue\" aria-autocomplete=\"list\" role=\"combobox\" [attr.aria-expanded]=\"overlayVisible\" aria-haspopup=\"true\" [attr.aria-activedescendant]=\"'p-highlighted-option'\"\n        (click)=\"onInputClick($event)\" (input)=\"onInput($event)\" (keydown)=\"onKeydown($event)\" (keyup)=\"onKeyup($event)\" [attr.autofocus]=\"autofocus\" (focus)=\"onInputFocus($event)\" (blur)=\"onInputBlur($event)\" (change)=\"onInputChange($event)\" (paste)=\"onInputPaste($event)\"\n        [attr.placeholder]=\"placeholder\" [attr.size]=\"size\" [attr.maxlength]=\"maxlength\" [attr.tabindex]=\"tabindex\" [readonly]=\"readonly\" [disabled]=\"disabled\" [attr.aria-label]=\"ariaLabel\" [attr.aria-labelledby]=\"ariaLabelledBy\" [attr.aria-required]=\"required\">\n\n    <ul *ngIf=\"multiple\" #multiContainer class=\"p-autocomplete-multiple-container p-component p-inputtext p-state-default p-corner-all\" [ngClass]=\"{'p-disabled':disabled,'p-focus':focus}\" (click)=\"multiIn.focus()\">\n        <li #token *ngFor=\"let val of value\" class=\"p-autocomplete-token p-highlight p-corner-all\">\n            <span class=\"p-autocomplete-token-icon pi pi-fw pi-times\" (click)=\"removeItem(token)\" *ngIf=\"!disabled\"></span>\n            <span *ngIf=\"!selectedItemTemplate\" class=\"p-autocomplete-token-label\">{{resolveFieldData(val)}}</span>\n            <ng-container *ngTemplateOutlet=\"selectedItemTemplate; context: {$implicit: val}\"></ng-container>\n        </li>\n        <li class=\"p-autocomplete-input-token\">\n            <input #multiIn \n                [attr.type]=\"type\" \n                [attr.id]=\"inputId\" [disabled]=\"disabled\" \n                [attr.placeholder]=\"(value&&value.length ? null : placeholder)\" \n                [attr.tabindex]=\"tabindex\" \n                (input)=\"onInput($event)\"  \n                (click)=\"onInputClick($event)\"\n                (keydown)=\"onKeydown($event)\" \n                [readonly]=\"readonly\" (keyup)=\"onKeyup($event)\" \n                [attr.autofocus]=\"autofocus\" \n                (focus)=\"onInputFocus($event)\" \n                (blur)=\"onInputBlur($event)\" \n                (change)=\"onInputChange($event)\" \n                (paste)=\"onInputPaste($event)\" \n                [autocomplete]=\"autocomplete\"\n                [ngStyle]=\"inputStyle\" \n                [class]=\"inputStyleClass\"\n                [ngClass]=\"'p-inputtext p-component p-state-default p-corner-all p-autocomplete-input'\" \n                [attr.aria-label]=\"ariaLabel\" \n                [attr.aria-labelledby]=\"ariaLabelledBy\" \n                [attr.aria-required]=\"required\"\n                aria-autocomplete=\"list\" \n                role=\"combobox\" \n                [attr.aria-expanded]=\"overlayVisible\" \n                aria-haspopup=\"true\" \n                [attr.aria-activedescendant]=\"'p-highlighted-option'\">\n        </li>\n    </ul>\n\n    <i *ngIf=\"loading\" class=\"p-autocomplete-loader pi pi-spinner pi-spin\"></i>\n    <button #ddBtn type=\"button\" pButton [icon]=\"dropdownIcon\" class=\"p-autocomplete-dropdown\" [disabled]=\"disabled\"\n        (click)=\"handleDropdownClick($event)\" *ngIf=\"dropdown\" [attr.tabindex]=\"tabindex\">\n    </button>\n\n    <div #panel *ngIf=\"overlayVisible\" [ngClass]=\"['p-autocomplete-panel p-component p-component-content p-corner-all p-shadow']\"\n        [style.max-height]=\"virtualScroll ? 'auto' : (scrollHeight||'auto')\" [ngStyle]=\"panelStyle\" [class]=\"panelStyleClass\"\n        [@overlayAnimation]=\"{value: 'visible', params: {showTransitionParams: showTransitionOptions, hideTransitionParams: hideTransitionOptions}}\" (@overlayAnimation.start)=\"onOverlayAnimationStart($event)\">\n        <ul role=\"listbox\" class=\"p-autocomplete-items p-autocomplete-list p-component-content p-component p-corner-all p-reset\">\n            <ng-container *ngIf=\"!virtualScroll; else virtualScrollList\">\n                <p-autoCompleteItem *ngFor=\"let option of suggestions; let idx = index\"\n                    [option]=\"option\" [(highlightOption)]=\"highlightOption\" [index]=\"idx\"\n                    (onClick)=\"selectItem($event.option)\" [itemSize]=\"itemSize\"\n                    [template]=\"itemTemplate\" [resolvedFieldData]=\"resolveFieldData(option)\">\n                </p-autoCompleteItem>\n            </ng-container>\n            <ng-template #virtualScrollList>\n                <cdk-virtual-scroll-viewport *ngIf=\"virtualScroll && suggestions && suggestions.length\"\n                    [ngStyle]=\"{height: scrollHeight}\" [itemSize]=\"itemSize\">\n                    <ng-container *cdkVirtualFor=\"let option of suggestions; let idx = index\">\n                        <p-autoCompleteItem\n                            [option]=\"option\" [(highlightOption)]=\"highlightOption\" [index]=\"idx\"\n                            (onClick)=\"selectItem($event.option)\" [itemSize]=\"itemSize\"\n                            [template]=\"itemTemplate\" [resolvedFieldData]=\"resolveFieldData(option)\"\n                        ></p-autoCompleteItem>\n                    </ng-container>\n                </cdk-virtual-scroll-viewport>\n            </ng-template>\n\n            <li *ngIf=\"noResults && emptyMessage\" class=\"p-autocomplete-emptymessage p-autocomplete-list-item p-corner-all\">{{emptyMessage}}</li>\n        </ul>\n    </div>\n</span>\n",
                providers: [AUTOCOMPLETE_VALUE_ACCESSOR],
                styles: ["ul{list-style-type:none}"]
            },] }
];
AutoCompleteCustomComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: IterableDiffers }
];
AutoCompleteCustomComponent.propDecorators = {
    virtualScroll: [{ type: Input }],
    itemSize: [{ type: Input }]
};

class AutoCompleteItem {
    constructor() {
        this.highlightOptionChange = new EventEmitter();
        this.onClick = new EventEmitter();
    }
    selectItem(event) {
        this.onClick.emit({
            originalEvent: event,
            option: this.option
        });
    }
}
AutoCompleteItem.decorators = [
    { type: Component, args: [{
                selector: 'p-autoCompleteItem',
                template: `
        <li role="option" [ngClass]="{'p-autocomplete-list-item p-corner-all':true,'p-highlight':(highlightOption==option)}"
            (mouseenter)="highlightOptionChange.emit(option)" (mouseleave)="highlightOptionChange.emit(null)"
            [id]="highlightOption == option ? 'p-highlighted-option':''" (click)="selectItem($event)"
            [ngStyle]="{'height': itemSize + 'px', 'display': 'table', 'width': '100%'}">
            <span *ngIf="!template">{{resolvedFieldData}}</span>
            <ng-container *ngTemplateOutlet="template; context: {$implicit: option, index: index}"></ng-container>
        </li>
    `
            },] }
];
AutoCompleteItem.propDecorators = {
    option: [{ type: Input }],
    resolvedFieldData: [{ type: Input }],
    highlightOption: [{ type: Input }],
    highlightOptionChange: [{ type: Output }],
    index: [{ type: Input }],
    itemSize: [{ type: Input }],
    template: [{ type: Input }],
    onClick: [{ type: Output }]
};

class AutoCompleteMultipleComponent extends FieldComponent {
    constructor() {
        super(...arguments);
        this.virtualScroll = false;
        this.itemSize = 30;
    }
    findAll(event) {
        let query = {};
        query[this.field] = event.query;
        this.service.findAll(query).subscribe(data => {
            this.results = data;
        });
    }
    outerToInner(value) {
        if (value && value.length > 0 && !value[0][this.field]) {
            let obs = [];
            value.forEach(element => {
                if (element && element.id) {
                    obs.push(this.service.find(element.id));
                }
            });
            forkJoin(obs).subscribe((data) => {
                this.formControl.setValue(data);
            });
        }
        return value;
    }
}
AutoCompleteMultipleComponent.decorators = [
    { type: Component, args: [{
                selector: "[nAutoCompleteMultiple]",
                template: "<span #notification form-notification class=\"p-float-label\" [name]=\"name\" [form]=\"form\">\n    <p-autoCompleteCustom #input\n        [formControl]=\"formControl\"\n        [suggestions]=\"results\"\n        (completeMethod)=\"findAll($event)\"\n        [field]=\"field\"\n        [virtualScroll]=\"virtualScroll\"\n        [itemSize]=\"itemSize\"\n        (onBlur)=\"onBlurEvent($event)\"\n        (onSelect)=\"onSelectEvent($event)\"\n        (onFocus)=\"onFocusEvent($event)\"\n        [multiple]=\"true\">\n    </p-autoCompleteCustom>\n    <label [for]=\"name\" [innerHTML]=\"label\"></label>\n    <nValidationMessage [control]=\"formControl\" *ngIf=\"!notification.message\"></nValidationMessage>\n    <ng-content></ng-content>\n</span>\n",
                providers: [provideValueAccessor(AutoCompleteMultipleComponent)]
            },] }
];
AutoCompleteMultipleComponent.propDecorators = {
    field: [{ type: Input }],
    service: [{ type: Input }],
    virtualScroll: [{ type: Input }],
    itemSize: [{ type: Input }]
};

class CheckPipe {
    transform(value, ...args) {
        return value ? "Sim" : "Não";
    }
}
CheckPipe.decorators = [
    { type: Pipe, args: [{
                name: "check"
            },] }
];

class CrudModule {
}
CrudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    FormNotificationModule,
                    InputTextModule,
                    InputTextareaModule,
                    CalendarModule,
                    AutoCompleteModule,
                    ButtonModule,
                    DatatableModule,
                    HttpClientModule,
                    RouterModule,
                    ConfirmDialogModule,
                    DropdownModule,
                    ScrollingModule,
                    InputMaskModule,
                    RadioButtonModule,
                ],
                declarations: [
                    CalendarComponent,
                    InputTextComponent,
                    TextAreaComponent,
                    FormComponent,
                    AutoCompleteComponent,
                    AutoCompleteMultipleComponent,
                    CrudListComponent,
                    CrudFormComponent,
                    FieldComponent,
                    ValidationMessageComponent,
                    DropdownComponent,
                    AutoCompleteItem,
                    AutoCompleteCustomComponent,
                    CheckComponent,
                    InputMaskComponent,
                    CheckPipe,
                ],
                exports: [
                    CalendarComponent,
                    InputTextComponent,
                    TextAreaComponent,
                    FormComponent,
                    AutoCompleteComponent,
                    AutoCompleteMultipleComponent,
                    CrudListComponent,
                    CrudFormComponent,
                    FieldComponent,
                    ValidationMessageComponent,
                    DropdownComponent,
                    CheckComponent,
                    InputMaskComponent,
                    CheckPipe,
                ],
                providers: [
                    httpInterceptorProviders,
                    ConfirmationService,
                ]
            },] }
];

class BreadcrumbService {
    constructor() {
        this.itemsSource = new Subject();
        this.itemsHandler = this.itemsSource.asObservable();
    }
    setItems(items) {
        this.itemsSource.next(items);
    }
    reset() {
        this.itemsSource.next([]);
    }
}
BreadcrumbService.decorators = [
    { type: Injectable }
];

class BreadcrumbComponent {
    constructor(router, activatedRoute, breadcrumbService, messages, accessibilityService) {
        this.router = router;
        this.activatedRoute = activatedRoute;
        this.breadcrumbService = breadcrumbService;
        this.messages = messages;
        this.accessibilityService = accessibilityService;
        this.highContrastEnabled = false;
        this.subscription = breadcrumbService.itemsHandler.subscribe(response => {
            this.items = response;
        });
        this.home = { icon: 'pi pi-home', routerLink: '/' };
    }
    ngOnInit() {
        this.router.events.pipe(filter((event) => event instanceof NavigationEnd), distinctUntilChanged()).subscribe((event) => {
            this.items = this.buildBreadCrumb(this.activatedRoute.root);
        });
    }
    ngOnDestroy() {
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
    }
    enableHighContrast() {
        this.highContrastEnabled = true;
        this.accessibilityService.enableHighContrast();
    }
    disableHighContrast() {
        this.highContrastEnabled = false;
        this.accessibilityService.disableHighContrast();
    }
    increaseFontSize() {
        this.accessibilityService.increaseFontSize();
    }
    decreaseFontSize() {
        this.accessibilityService.decreaseFontSize();
    }
    ngAfterViewInit() {
        this.messages.messageObserver.subscribe((msg) => {
            this.accessibilityService.addAccessibilityMessages({ severity: msg.severity });
        });
        this.accessibilityService.addAccessibilityIcons();
    }
    buildBreadCrumb(route, url = '', breadcrumbs = []) {
        let label = (route.routeConfig && route.routeConfig.data ? route.routeConfig.data.breadcrumb : '').trim();
        let path = route.routeConfig && route.routeConfig.data ? route.routeConfig.path : '';
        const lastRoutePart = path.split('/').pop();
        const isDynamicRoute = lastRoutePart.startsWith(':');
        if (isDynamicRoute && !!route.snapshot) {
            for (let key in route.snapshot.params) {
                path = path.replace(`:${key}`, route.snapshot.params[key]);
            }
            label = (`${(label != ':action') ? label : ''} ${Object.values(route.snapshot.params).join(' ')}`).trim();
        }
        const nextUrl = path ? `${url}/${path}` : url;
        const menuItem = {
            "label": label.charAt(0).toUpperCase() + label.slice(1),
            "routerLink": nextUrl
        };
        const newBreadcrumbs = menuItem.label ? [...breadcrumbs, menuItem] : [...breadcrumbs];
        if (route.firstChild) {
            return this.buildBreadCrumb(route.firstChild, nextUrl, newBreadcrumbs);
        }
        return newBreadcrumbs;
    }
}
BreadcrumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'breadcrumb',
                template: "<div class=\"layout-breadcrumb layout-breadcrumb-container p-d-flex p-jc-between p-ai-center p-shadow-1\">\n    <p-breadcrumb [model]=\"items\" [home]=\"home\" styleClass=\"layout-breadcrumb p-pl-4 p-py-2\"></p-breadcrumb>\n    <div class=\"layout-breadcrumb-buttons p-d-flex p-ai-center p-pr-3\">\n        <button pButton \n            pRipple type=\"button\" \n            icon=\"pi pi-sliders-h\"\n            (click)=\"highContrastEnabled ? disableHighContrast() : enableHighContrast()\"\n            title=\"{{ highContrastEnabled ? 'Desabilitar alto contraste' : 'Habilitar alto contraste' }}\"\n            class=\"p-button-rounded p-button-text p-button-plain p-mr-1\">\n        </button>\n        <button pButton \n            pRipple \n            type=\"button\" \n            icon=\"pi pi-search-plus\"\n            title=\"Aumentar fonte\"\n            (click)=\"increaseFontSize()\" \n            class=\"p-button-rounded p-button-text p-button-plain p-mr-1\">\n        </button>\n        <button pButton \n            pRipple \n            type=\"button\"\n            icon=\"pi pi-search-minus\" \n            (click)=\"decreaseFontSize()\" title=\"Diminuir fonte\"\n            class=\"p-button-rounded p-button-text p-button-plain p-mr-1\">\n        </button>\n    </div>\n</div>\n",
                styles: [""]
            },] }
];
BreadcrumbComponent.ctorParameters = () => [
    { type: Router },
    { type: ActivatedRoute },
    { type: BreadcrumbService },
    { type: MessageService },
    { type: AccessbilityService }
];

class BreadcrumbModule {
}
BreadcrumbModule.decorators = [
    { type: NgModule, args: [{
                declarations: [BreadcrumbComponent],
                imports: [
                    CommonModule,
                    RouterModule,
                    BreadcrumbModule$1,
                    ButtonModule
                ],
                exports: [
                    BreadcrumbComponent
                ],
                providers: [
                    BreadcrumbService
                ]
            },] }
];

var MenuOrientation;
(function (MenuOrientation) {
    MenuOrientation[MenuOrientation["STATIC"] = 0] = "STATIC";
    MenuOrientation[MenuOrientation["OVERLAY"] = 1] = "OVERLAY";
    MenuOrientation[MenuOrientation["SLIM"] = 2] = "SLIM";
    MenuOrientation[MenuOrientation["HORIZONTAL"] = 3] = "HORIZONTAL";
})(MenuOrientation || (MenuOrientation = {}));
/**
 * Class MenuService
 * @class
 */
class MenusService {
    constructor() {
        this.menuSource = new Subject();
        this.resetSource = new Subject();
        this.menuSource$ = this.menuSource.asObservable();
        this.resetSource$ = this.resetSource.asObservable();
        this.layoutMode = MenuOrientation.STATIC;
        this.itens = [];
    }
    isOverlay() {
        return this.layoutMode === MenuOrientation.OVERLAY;
    }
    isHorizontal() {
        return this.layoutMode === MenuOrientation.HORIZONTAL;
    }
    isSlim() {
        return this.layoutMode === MenuOrientation.SLIM;
    }
    isStatic() {
        return this.layoutMode === MenuOrientation.STATIC;
    }
    changeToStaticMenu() {
        this.layoutMode = MenuOrientation.STATIC;
    }
    changeToOverlayMenu() {
        this.layoutMode = MenuOrientation.OVERLAY;
    }
    changeToHorizontalMenu() {
        this.layoutMode = MenuOrientation.HORIZONTAL;
    }
    changeToSlimMenu() {
        this.layoutMode = MenuOrientation.SLIM;
    }
    onMenuStateChange(key) {
        this.menuSource.next(key);
    }
    reset() {
        this.resetSource.next();
    }
}
MenusService.ɵprov = ɵɵdefineInjectable({ factory: function MenusService_Factory() { return new MenusService(); }, token: MenusService, providedIn: "root" });
MenusService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class MenuComponent {
    constructor(menuService) {
        this.menuService = menuService;
    }
}
MenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'app-menu',
                template: "<ul class=\"layout-menu\">\n    <li submenu *ngFor=\"let item of menuService.itens; let i = index;\" [item]=\"item\" [index]=\"i\" root=\"true\"></li>\n</ul>"
            },] }
];
MenuComponent.ctorParameters = () => [
    { type: MenusService }
];

class SubMenuComponent {
    constructor(menuService, router) {
        this.menuService = menuService;
        this.router = router;
        this.active = false;
        this.menuSourceSubscription = this.menuService.menuSource$.subscribe(key => {
            // deactivate current active menu
            if (this.active && this.key !== key && key.indexOf(this.key) !== 0) {
                this.active = false;
            }
        });
        this.menuResetSubscription = this.menuService.resetSource$.subscribe(() => {
            this.active = false;
        });
        this.router.events.pipe(filter(event => event instanceof NavigationEnd))
            .subscribe(params => {
            if (this.menuService.isHorizontal() || this.menuService.isSlim()) {
                this.active = false;
            }
            else {
                if (this.item.routerLink) {
                    this.updateActiveStateFromRoute();
                }
                else {
                    this.active = false;
                }
            }
        });
    }
    updateActiveStateFromRoute() {
        this.active = this.router.isActive(this.item.routerLink[0], this.item.items ? false : true);
    }
    /**
     * Alterar o menu root entre aberto e fechado
     */
    rootMenuToggle() {
        if (this.root) {
            this.menuService.menuHoverActive = !this.menuService.menuHoverActive;
        }
    }
    /**
     * Activa o menu por index e desativa o item ativo
     * @param index
     */
    activeMenuByIndex(index) {
        this.activeIndex = (this.activeIndex === index) ? null : index;
        return this.activeIndex;
    }
    /**
     * Verifica se foi informado um comando para o item de menu e executa caso necessário
     * @param item menu
     */
    execCommand(event, item) {
        if (item.command) {
            item.command({ 'originalEvent': event, 'item': item });
            return true;
        }
        return false;
    }
    /**
     * Esconte o menu caso este não possua itens
     * @param item menu
     */
    hideMenu(item) {
        if (!item.items) {
            if (this.menuService.isHorizontal() || this.menuService.isSlim()) {
                this.menuService.resetMenu = true;
            }
            else {
                this.menuService.resetMenu = false;
            }
            this.menuService.overlayMenuActive = false;
            this.menuService.staticMenuMobileActive = false;
            this.menuService.menuHoverActive = !this.menuService.menuHoverActive;
            return true;
        }
        return false;
    }
    itemClick(event) {
        // avoid processing disabled items
        if (this.item.disabled) {
            event.preventDefault();
            return true;
        }
        // navigate with hover in horizontal mode
        if (this.root) {
            this.menuService.menuHoverActive = !this.menuService.menuHoverActive;
        }
        // notify other items
        this.menuService.onMenuStateChange(this.key);
        // execute command
        if (this.item.command) {
            this.item.command({ originalEvent: event, item: this.item });
        }
        // toggle active state
        if (this.item.items) {
            this.active = !this.active;
        }
        else {
            // activate item
            this.active = true;
            // reset horizontal and slim menu
            if (this.menuService.isHorizontal() || this.menuService.isSlim()) {
                this.menuService.reset();
                this.menuService.menuHoverActive = false;
            }
            if (!this.menuService.isStatic()) {
                this.active = false;
            }
        }
        this.removeActiveInk(event);
    }
    onMouseEnter() {
        // activate item on hover
        if (this.root) {
            this.active = true;
        }
    }
    isActive(index) {
        return this.activeIndex === index;
    }
    get reset() {
        return this._reset;
    }
    set reset(val) {
        this._reset = val;
        if (this._reset && (this.menuService.isHorizontal() || this.menuService.isSlim())) {
            this.activeIndex = null;
        }
    }
    get parentActive() {
        return this._parentActive;
    }
    set parentActive(val) {
        this._parentActive = val;
        if (!this._parentActive) {
            this.activeIndex = null;
        }
    }
    removeActiveInk(event) {
        let currentTarget = event.currentTarget;
        setTimeout(() => {
            if (currentTarget) {
                let activeInk = currentTarget.querySelector('.p-ink-active');
                if (activeInk) {
                    if (activeInk.classList)
                        activeInk.classList.remove('p-ink-active');
                    else
                        activeInk.className = activeInk.className.replace(new RegExp('(^|\\b)' + 'p-ink-active'.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
                }
            }
        }, 401);
    }
    ngOnDestroy() {
        if (this.menuSourceSubscription) {
            this.menuSourceSubscription.unsubscribe();
        }
        if (this.menuResetSubscription) {
            this.menuResetSubscription.unsubscribe();
        }
    }
}
SubMenuComponent.decorators = [
    { type: Component, args: [{
                selector: '[submenu]',
                template: "<div *ngIf=\"root\">\n    <span class=\"layout-menuitem-text\">{{item.label}}</span>\n</div>\n<a [attr.href]=\"item.url\" (click)=\"itemClick($event)\" *ngIf=\"!item.routerLink || item.items\"\n    (keydown.enter)=\"itemClick($event)\" [attr.target]=\"item.target\" [attr.tabindex]=\"0\" [ngClass]=\"item.class\"\n    (mouseenter)=\"onMouseEnter()\" pRipple [pTooltip]=\"item.label\"\n    [tooltipDisabled]=\"active || !(root && menuService.isSlim() && !menuService.isMobile)\">\n    <i [ngClass]=\"item.icon\" class=\"layout-menuitem-icon\"></i>\n    <span class=\"layout-menuitem-text\">{{item.label}}</span>\n    <span class=\"p-badge p-component p-badge-no-gutter\" [ngClass]=\"item.badgeClass\"\n        *ngIf=\"item.badge && !root\">{{item.badge}}</span>\n    <i class=\"pi pi-fw pi-angle-down layout-submenu-toggler\" *ngIf=\"item.items\"></i>\n</a>\n<a (click)=\"itemClick($event)\" *ngIf=\"item.routerLink && !item.items\" [routerLink]=\"item.routerLink\"\n    routerLinkActive=\"active-menuitem-routerlink\" [routerLinkActiveOptions]=\"{exact: true}\" [attr.target]=\"item.target\"\n    [attr.tabindex]=\"0\" [ngClass]=\"item.class\" (mouseenter)=\"onMouseEnter()\" pRipple [pTooltip]=\"item.label\"\n    [tooltipDisabled]=\"active || !(root && menuService.isSlim() && !menuService.isMobile)\">\n    <i [ngClass]=\"item.icon\" class=\"layout-menuitem-icon\"></i>\n    <span class=\"layout-menuitem-text\">{{item.label}}</span>\n    <span class=\"p-badge p-component p-badge-no-gutter\" [ngClass]=\"item.badgeClass\"\n        *ngIf=\"item.badge && !root\">{{item.badge}}</span>\n    <i class=\"pi pi-fw pi-angle-down layout-submenu-toggler\" *ngIf=\"item.items\"></i>\n</a>\n<ul *ngIf=\"(item.items && root) || (item.items && active)\"\n    [@children]=\"root ? 'visible' : active ? 'visibleAnimated' : 'hiddenAnimated'\">\n    <ng-template ngFor let-child let-i=\"index\" [ngForOf]=\"item.items\">\n        <li submenu [item]=\"child\" [index]=\"i\" [parentKey]=\"key\" [class]=\"child.badgeClass\"></li>\n    </ng-template>\n</ul>",
                host: {
                    '[class.layout-root-menuitem]': 'root || active',
                    '[class.active-menuitem]': '(active)'
                },
                animations: [
                    trigger('children', [
                        state('void', style({
                            height: '0px',
                            padding: '0px'
                        })),
                        state('hiddenAnimated', style({
                            height: '0px',
                            padding: '0px'
                        })),
                        state('visibleAnimated', style({
                            height: '*'
                        })),
                        state('visible', style({
                            height: '*'
                        })),
                        state('hidden', style({
                            height: '0px',
                            padding: '0px'
                        })),
                        transition('visibleAnimated => hiddenAnimated', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                        transition('hiddenAnimated => visibleAnimated', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                        transition('void => visibleAnimated, visibleAnimated => void', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)'))
                    ])
                ]
            },] }
];
SubMenuComponent.ctorParameters = () => [
    { type: MenusService },
    { type: Router }
];
SubMenuComponent.propDecorators = {
    item: [{ type: Input }],
    root: [{ type: Input }],
    visible: [{ type: Input }],
    parentKey: [{ type: Input }],
    index: [{ type: Input }],
    reset: [{ type: Input }],
    parentActive: [{ type: Input }]
};

class MenuModule {
}
MenuModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    MenuComponent,
                    SubMenuComponent
                ],
                imports: [
                    CommonModule,
                    RouterModule,
                    TooltipModule
                ],
                exports: [
                    MenuComponent,
                    SubMenuComponent
                ],
                providers: [
                    MenusService
                ]
            },] }
];

/*
 * Public API Surface of primeng-components
 */

/**
 * Generated bundle index. Do not edit.
 */

export { AutoCompleteComponent, AutoCompleteMultipleComponent, BlockUiComponent, BlockUiModule, BreadcrumbComponent, BreadcrumbModule, BreadcrumbService, CALENDAR_LOCALE, CRUD_SERVICE, CalendarComponent, CheckComponent, CheckPipe, Column, CrudFormComponent, CrudListComponent, CrudModule, CrudResolveGuard, CrudServiceNuvem, DataProviderFactory, DataProviderType, DatatableButtonComponent, DatatableClickEvent, DatatableComponent, DatatableModule, DatatableService, DatatableSplitbuttonComponent, DatatableSplitbuttonModule, DropdownComponent, ErrorStackComponent, ErrorStackModule, FieldComponent, FilterColumn, FilterColumnModule, FormComponent, FormNotificationComponent, FormNotificationModule, InputMaskComponent, InputTextComponent, MemoryDataProvider, MenuComponent, MenuModule, MenuOrientation, MenusService, PageNotificationComponent, PageNotificationModule, PageNotificationService, ServerDataProvider, ShowColumn, ShowColumnModule, SubMenuComponent, SuccessMessageHandlerInterceptor, TextAreaComponent, ValidationMessageComponent, crudRouteBuilder, httpInterceptorProviders, ActionButtonComponent as ɵa, AutoCompleteItem as ɵb, AUTOCOMPLETE_VALUE_ACCESSOR as ɵc, AutoCompleteCustomComponent as ɵd };
//# sourceMappingURL=nuvem-primeng-components.js.map
