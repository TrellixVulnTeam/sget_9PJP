{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function (Chart) {\n  var noop = helpers.noop;\n  Chart.LinearScaleBase = Chart.Scale.extend({\n    getRightValue: function getRightValue(value) {\n      if (typeof value === 'string') {\n        return +value;\n      }\n\n      return Chart.Scale.prototype.getRightValue.call(this, value);\n    },\n    handleTickRangeOptions: function handleTickRangeOptions() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers.sign(me.min);\n        var maxSign = helpers.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        if (me.min === null) {\n          me.min = tickOpts.suggestedMin;\n        } else {\n          me.min = Math.min(me.min, tickOpts.suggestedMin);\n        }\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        if (me.max === null) {\n          me.max = tickOpts.suggestedMax;\n        } else {\n          me.max = Math.max(me.max, tickOpts.suggestedMax);\n        }\n      }\n\n      if (setMin !== setMax) {\n        // We set the min or the max but not both.\n        // So ensure that our range is good\n        // Inverted or 0 length range can happen when\n        // ticks.min is set, and no datasets are visible\n        if (me.min >= me.max) {\n          if (setMin) {\n            me.max = me.min + 1;\n          } else {\n            me.min = me.max - 1;\n          }\n        }\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: noop,\n    handleDirectionalChanges: noop,\n    buildTicks: function buildTicks() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function convertTicksToLabels() {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      Chart.Scale.prototype.convertTicksToLabels.call(me);\n    }\n  });\n};","map":{"version":3,"sources":["/home/basis/template/p-lc-aprd_codigo_fonte/client/node_modules/chart.js/src/scales/scale.linearbase.js"],"names":["helpers","require","Ticks","module","exports","Chart","noop","LinearScaleBase","Scale","extend","getRightValue","value","prototype","call","handleTickRangeOptions","me","opts","options","tickOpts","ticks","beginAtZero","minSign","sign","min","maxSign","max","setMin","undefined","suggestedMin","setMax","suggestedMax","Math","getTickLimit","handleDirectionalChanges","buildTicks","maxTicks","numericGeneratorOptions","stepSize","valueOrDefault","fixedStepSize","generators","linear","reverse","start","end","convertTicksToLabels","ticksAsNumbers","slice","zeroLineIndex","indexOf"],"mappings":"AAAA;;AAEA,IAAIA,OAAO,GAAGC,OAAO,CAAC,kBAAD,CAArB;;AACA,IAAIC,KAAK,GAAGD,OAAO,CAAC,oBAAD,CAAnB;;AAEAE,MAAM,CAACC,OAAP,GAAiB,UAASC,KAAT,EAAgB;AAEhC,MAAIC,IAAI,GAAGN,OAAO,CAACM,IAAnB;AAEAD,EAAAA,KAAK,CAACE,eAAN,GAAwBF,KAAK,CAACG,KAAN,CAAYC,MAAZ,CAAmB;AAC1CC,IAAAA,aAAa,EAAE,uBAASC,KAAT,EAAgB;AAC9B,UAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC9B,eAAO,CAACA,KAAR;AACA;;AACD,aAAON,KAAK,CAACG,KAAN,CAAYI,SAAZ,CAAsBF,aAAtB,CAAoCG,IAApC,CAAyC,IAAzC,EAA+CF,KAA/C,CAAP;AACA,KANyC;AAQ1CG,IAAAA,sBAAsB,EAAE,kCAAW;AAClC,UAAIC,EAAE,GAAG,IAAT;AACA,UAAIC,IAAI,GAAGD,EAAE,CAACE,OAAd;AACA,UAAIC,QAAQ,GAAGF,IAAI,CAACG,KAApB,CAHkC,CAKlC;AACA;AACA;;AACA,UAAID,QAAQ,CAACE,WAAb,EAA0B;AACzB,YAAIC,OAAO,GAAGrB,OAAO,CAACsB,IAAR,CAAaP,EAAE,CAACQ,GAAhB,CAAd;AACA,YAAIC,OAAO,GAAGxB,OAAO,CAACsB,IAAR,CAAaP,EAAE,CAACU,GAAhB,CAAd;;AAEA,YAAIJ,OAAO,GAAG,CAAV,IAAeG,OAAO,GAAG,CAA7B,EAAgC;AAC/B;AACAT,UAAAA,EAAE,CAACU,GAAH,GAAS,CAAT;AACA,SAHD,MAGO,IAAIJ,OAAO,GAAG,CAAV,IAAeG,OAAO,GAAG,CAA7B,EAAgC;AACtC;AACAT,UAAAA,EAAE,CAACQ,GAAH,GAAS,CAAT;AACA;AACD;;AAED,UAAIG,MAAM,GAAGR,QAAQ,CAACK,GAAT,KAAiBI,SAAjB,IAA8BT,QAAQ,CAACU,YAAT,KAA0BD,SAArE;AACA,UAAIE,MAAM,GAAGX,QAAQ,CAACO,GAAT,KAAiBE,SAAjB,IAA8BT,QAAQ,CAACY,YAAT,KAA0BH,SAArE;;AAEA,UAAIT,QAAQ,CAACK,GAAT,KAAiBI,SAArB,EAAgC;AAC/BZ,QAAAA,EAAE,CAACQ,GAAH,GAASL,QAAQ,CAACK,GAAlB;AACA,OAFD,MAEO,IAAIL,QAAQ,CAACU,YAAT,KAA0BD,SAA9B,EAAyC;AAC/C,YAAIZ,EAAE,CAACQ,GAAH,KAAW,IAAf,EAAqB;AACpBR,UAAAA,EAAE,CAACQ,GAAH,GAASL,QAAQ,CAACU,YAAlB;AACA,SAFD,MAEO;AACNb,UAAAA,EAAE,CAACQ,GAAH,GAASQ,IAAI,CAACR,GAAL,CAASR,EAAE,CAACQ,GAAZ,EAAiBL,QAAQ,CAACU,YAA1B,CAAT;AACA;AACD;;AAED,UAAIV,QAAQ,CAACO,GAAT,KAAiBE,SAArB,EAAgC;AAC/BZ,QAAAA,EAAE,CAACU,GAAH,GAASP,QAAQ,CAACO,GAAlB;AACA,OAFD,MAEO,IAAIP,QAAQ,CAACY,YAAT,KAA0BH,SAA9B,EAAyC;AAC/C,YAAIZ,EAAE,CAACU,GAAH,KAAW,IAAf,EAAqB;AACpBV,UAAAA,EAAE,CAACU,GAAH,GAASP,QAAQ,CAACY,YAAlB;AACA,SAFD,MAEO;AACNf,UAAAA,EAAE,CAACU,GAAH,GAASM,IAAI,CAACN,GAAL,CAASV,EAAE,CAACU,GAAZ,EAAiBP,QAAQ,CAACY,YAA1B,CAAT;AACA;AACD;;AAED,UAAIJ,MAAM,KAAKG,MAAf,EAAuB;AACtB;AACA;AACA;AACA;AACA,YAAId,EAAE,CAACQ,GAAH,IAAUR,EAAE,CAACU,GAAjB,EAAsB;AACrB,cAAIC,MAAJ,EAAY;AACXX,YAAAA,EAAE,CAACU,GAAH,GAASV,EAAE,CAACQ,GAAH,GAAS,CAAlB;AACA,WAFD,MAEO;AACNR,YAAAA,EAAE,CAACQ,GAAH,GAASR,EAAE,CAACU,GAAH,GAAS,CAAlB;AACA;AACD;AACD;;AAED,UAAIV,EAAE,CAACQ,GAAH,KAAWR,EAAE,CAACU,GAAlB,EAAuB;AACtBV,QAAAA,EAAE,CAACU,GAAH;;AAEA,YAAI,CAACP,QAAQ,CAACE,WAAd,EAA2B;AAC1BL,UAAAA,EAAE,CAACQ,GAAH;AACA;AACD;AACD,KAzEyC;AA0E1CS,IAAAA,YAAY,EAAE1B,IA1E4B;AA2E1C2B,IAAAA,wBAAwB,EAAE3B,IA3EgB;AA6E1C4B,IAAAA,UAAU,EAAE,sBAAW;AACtB,UAAInB,EAAE,GAAG,IAAT;AACA,UAAIC,IAAI,GAAGD,EAAE,CAACE,OAAd;AACA,UAAIC,QAAQ,GAAGF,IAAI,CAACG,KAApB,CAHsB,CAKtB;AACA;AACA;AACA;;AACA,UAAIgB,QAAQ,GAAGpB,EAAE,CAACiB,YAAH,EAAf;AACAG,MAAAA,QAAQ,GAAGJ,IAAI,CAACN,GAAL,CAAS,CAAT,EAAYU,QAAZ,CAAX;AAEA,UAAIC,uBAAuB,GAAG;AAC7BD,QAAAA,QAAQ,EAAEA,QADmB;AAE7BZ,QAAAA,GAAG,EAAEL,QAAQ,CAACK,GAFe;AAG7BE,QAAAA,GAAG,EAAEP,QAAQ,CAACO,GAHe;AAI7BY,QAAAA,QAAQ,EAAErC,OAAO,CAACsC,cAAR,CAAuBpB,QAAQ,CAACqB,aAAhC,EAA+CrB,QAAQ,CAACmB,QAAxD;AAJmB,OAA9B;AAMA,UAAIlB,KAAK,GAAGJ,EAAE,CAACI,KAAH,GAAWjB,KAAK,CAACsC,UAAN,CAAiBC,MAAjB,CAAwBL,uBAAxB,EAAiDrB,EAAjD,CAAvB;AAEAA,MAAAA,EAAE,CAACkB,wBAAH,GApBsB,CAsBtB;AACA;;AACAlB,MAAAA,EAAE,CAACU,GAAH,GAASzB,OAAO,CAACyB,GAAR,CAAYN,KAAZ,CAAT;AACAJ,MAAAA,EAAE,CAACQ,GAAH,GAASvB,OAAO,CAACuB,GAAR,CAAYJ,KAAZ,CAAT;;AAEA,UAAID,QAAQ,CAACwB,OAAb,EAAsB;AACrBvB,QAAAA,KAAK,CAACuB,OAAN;AAEA3B,QAAAA,EAAE,CAAC4B,KAAH,GAAW5B,EAAE,CAACU,GAAd;AACAV,QAAAA,EAAE,CAAC6B,GAAH,GAAS7B,EAAE,CAACQ,GAAZ;AACA,OALD,MAKO;AACNR,QAAAA,EAAE,CAAC4B,KAAH,GAAW5B,EAAE,CAACQ,GAAd;AACAR,QAAAA,EAAE,CAAC6B,GAAH,GAAS7B,EAAE,CAACU,GAAZ;AACA;AACD,KAjHyC;AAkH1CoB,IAAAA,oBAAoB,EAAE,gCAAW;AAChC,UAAI9B,EAAE,GAAG,IAAT;AACAA,MAAAA,EAAE,CAAC+B,cAAH,GAAoB/B,EAAE,CAACI,KAAH,CAAS4B,KAAT,EAApB;AACAhC,MAAAA,EAAE,CAACiC,aAAH,GAAmBjC,EAAE,CAACI,KAAH,CAAS8B,OAAT,CAAiB,CAAjB,CAAnB;AAEA5C,MAAAA,KAAK,CAACG,KAAN,CAAYI,SAAZ,CAAsBiC,oBAAtB,CAA2ChC,IAA3C,CAAgDE,EAAhD;AACA;AAxHyC,GAAnB,CAAxB;AA0HA,CA9HD","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\nvar Ticks = require('../core/core.ticks');\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = Ticks.generators.linear(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}