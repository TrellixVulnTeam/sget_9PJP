{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = function (Chart) {\n  function filterByPosition(array, position) {\n    return helpers.where(array, function (v) {\n      return v.position === position;\n    });\n  }\n\n  function sortByWeight(array, reverse) {\n    array.forEach(function (v, i) {\n      v._tmpIndex_ = i;\n      return v;\n    });\n    array.sort(function (a, b) {\n      var v0 = reverse ? b : a;\n      var v1 = reverse ? a : b;\n      return v0.weight === v1.weight ? v0._tmpIndex_ - v1._tmpIndex_ : v0.weight - v1.weight;\n    });\n    array.forEach(function (v) {\n      delete v._tmpIndex_;\n    });\n  }\n  /**\n   * @interface ILayoutItem\n   * @prop {String} position - The position of the item in the chart layout. Possible values are\n   * 'left', 'top', 'right', 'bottom', and 'chartArea'\n   * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n   * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n   * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n   * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n   * @prop {Function} getPadding -  Returns an object with padding on the edges\n   * @prop {Number} width - Width of item. Must be valid after update()\n   * @prop {Number} height - Height of item. Must be valid after update()\n   * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n   * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n   * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n   * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n   */\n  // The layout service is very self explanatory.  It's responsible for the layout within a chart.\n  // Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n  // It is this service's responsibility of carrying out that layout.\n\n\n  Chart.layoutService = {\n    defaults: {},\n\n    /**\n     * Register a box to a chart.\n     * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n     * @param {Chart} chart - the chart to use\n     * @param {ILayoutItem} item - the item to add to be layed out\n     */\n    addBox: function addBox(chart, item) {\n      if (!chart.boxes) {\n        chart.boxes = [];\n      } // initialize item with default values\n\n\n      item.fullWidth = item.fullWidth || false;\n      item.position = item.position || 'top';\n      item.weight = item.weight || 0;\n      chart.boxes.push(item);\n    },\n\n    /**\n     * Remove a layoutItem from a chart\n     * @param {Chart} chart - the chart to remove the box from\n     * @param {Object} layoutItem - the item to remove from the layout\n     */\n    removeBox: function removeBox(chart, layoutItem) {\n      var index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\n      if (index !== -1) {\n        chart.boxes.splice(index, 1);\n      }\n    },\n\n    /**\n     * Sets (or updates) options on the given `item`.\n     * @param {Chart} chart - the chart in which the item lives (or will be added to)\n     * @param {Object} item - the item to configure with the given options\n     * @param {Object} options - the new item options.\n     */\n    configure: function configure(chart, item, options) {\n      var props = ['fullWidth', 'position', 'weight'];\n      var ilen = props.length;\n      var i = 0;\n      var prop;\n\n      for (; i < ilen; ++i) {\n        prop = props[i];\n\n        if (options.hasOwnProperty(prop)) {\n          item[prop] = options[prop];\n        }\n      }\n    },\n\n    /**\n     * Fits boxes of the given chart into the given size by having each box measure itself\n     * then running a fitting algorithm\n     * @param {Chart} chart - the chart\n     * @param {Number} width - the width to fit into\n     * @param {Number} height - the height to fit into\n     */\n    update: function update(chart, width, height) {\n      if (!chart) {\n        return;\n      }\n\n      var layoutOptions = chart.options.layout || {};\n      var padding = helpers.options.toPadding(layoutOptions.padding);\n      var leftPadding = padding.left;\n      var rightPadding = padding.right;\n      var topPadding = padding.top;\n      var bottomPadding = padding.bottom;\n      var leftBoxes = filterByPosition(chart.boxes, 'left');\n      var rightBoxes = filterByPosition(chart.boxes, 'right');\n      var topBoxes = filterByPosition(chart.boxes, 'top');\n      var bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n      var chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea'); // Sort boxes by weight. A higher weight is further away from the chart area\n\n      sortByWeight(leftBoxes, true);\n      sortByWeight(rightBoxes, false);\n      sortByWeight(topBoxes, true);\n      sortByWeight(bottomBoxes, false); // Essentially we now have any number of boxes on each of the 4 sides.\n      // Our canvas looks like the following.\n      // The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n      // B1 is the bottom axis\n      // There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n      // These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n      // an error will be thrown.\n      //\n      // |----------------------------------------------------|\n      // |                  T1 (Full Width)                   |\n      // |----------------------------------------------------|\n      // |    |    |                 T2                  |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    | C1 |                           | C2 |    |\n      // |    |    |----|                           |----|    |\n      // |    |    |                                     |    |\n      // | L1 | L2 |           ChartArea (C0)            | R1 |\n      // |    |    |                                     |    |\n      // |    |    |----|                           |----|    |\n      // |    |    | C3 |                           | C4 |    |\n      // |    |----|-------------------------------------|----|\n      // |    |    |                 B1                  |    |\n      // |----------------------------------------------------|\n      // |                  B2 (Full Width)                   |\n      // |----------------------------------------------------|\n      //\n      // What we do to find the best sizing, we do the following\n      // 1. Determine the minimum size of the chart area.\n      // 2. Split the remaining width equally between each vertical axis\n      // 3. Split the remaining height equally between each horizontal axis\n      // 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n      // 5. Adjust the sizes of each axis based on it's minimum reported size.\n      // 6. Refit each axis\n      // 7. Position each axis in the final location\n      // 8. Tell the chart the final location of the chart area\n      // 9. Tell any axes that overlay the chart area the positions of the chart area\n      // Step 1\n\n      var chartWidth = width - leftPadding - rightPadding;\n      var chartHeight = height - topPadding - bottomPadding;\n      var chartAreaWidth = chartWidth / 2; // min 50%\n\n      var chartAreaHeight = chartHeight / 2; // min 50%\n      // Step 2\n\n      var verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length); // Step 3\n\n      var horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length); // Step 4\n\n      var maxChartAreaWidth = chartWidth;\n      var maxChartAreaHeight = chartHeight;\n      var minBoxSizes = [];\n\n      function getMinimumBoxSize(box) {\n        var minSize;\n        var isHorizontal = box.isHorizontal();\n\n        if (isHorizontal) {\n          minSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n          maxChartAreaHeight -= minSize.height;\n        } else {\n          minSize = box.update(verticalBoxWidth, chartAreaHeight);\n          maxChartAreaWidth -= minSize.width;\n        }\n\n        minBoxSizes.push({\n          horizontal: isHorizontal,\n          minSize: minSize,\n          box: box\n        });\n      }\n\n      helpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize); // If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\n      var maxHorizontalLeftPadding = 0;\n      var maxHorizontalRightPadding = 0;\n      var maxVerticalTopPadding = 0;\n      var maxVerticalBottomPadding = 0;\n      helpers.each(topBoxes.concat(bottomBoxes), function (horizontalBox) {\n        if (horizontalBox.getPadding) {\n          var boxPadding = horizontalBox.getPadding();\n          maxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n          maxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n        }\n      });\n      helpers.each(leftBoxes.concat(rightBoxes), function (verticalBox) {\n        if (verticalBox.getPadding) {\n          var boxPadding = verticalBox.getPadding();\n          maxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n          maxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n        }\n      }); // At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n      // be if the axes are drawn at their minimum sizes.\n      // Steps 5 & 6\n\n      var totalLeftBoxesWidth = leftPadding;\n      var totalRightBoxesWidth = rightPadding;\n      var totalTopBoxesHeight = topPadding;\n      var totalBottomBoxesHeight = bottomPadding; // Function to fit a box\n\n      function fitBox(box) {\n        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minBox) {\n          return minBox.box === box;\n        });\n\n        if (minBoxSize) {\n          if (box.isHorizontal()) {\n            var scaleMargin = {\n              left: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n              right: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n              top: 0,\n              bottom: 0\n            }; // Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n            // on the margin. Sometimes they need to increase in size slightly\n\n            box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n          } else {\n            box.update(minBoxSize.minSize.width, maxChartAreaHeight);\n          }\n        }\n      } // Update, and calculate the left and right margins for the horizontal boxes\n\n\n      helpers.each(leftBoxes.concat(rightBoxes), fitBox);\n      helpers.each(leftBoxes, function (box) {\n        totalLeftBoxesWidth += box.width;\n      });\n      helpers.each(rightBoxes, function (box) {\n        totalRightBoxesWidth += box.width;\n      }); // Set the Left and Right margins for the horizontal boxes\n\n      helpers.each(topBoxes.concat(bottomBoxes), fitBox); // Figure out how much margin is on the top and bottom of the vertical boxes\n\n      helpers.each(topBoxes, function (box) {\n        totalTopBoxesHeight += box.height;\n      });\n      helpers.each(bottomBoxes, function (box) {\n        totalBottomBoxesHeight += box.height;\n      });\n\n      function finalFitVerticalBox(box) {\n        var minBoxSize = helpers.findNextWhere(minBoxSizes, function (minSize) {\n          return minSize.box === box;\n        });\n        var scaleMargin = {\n          left: 0,\n          right: 0,\n          top: totalTopBoxesHeight,\n          bottom: totalBottomBoxesHeight\n        };\n\n        if (minBoxSize) {\n          box.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n        }\n      } // Let the left layout know the final margin\n\n\n      helpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox); // Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\n      totalLeftBoxesWidth = leftPadding;\n      totalRightBoxesWidth = rightPadding;\n      totalTopBoxesHeight = topPadding;\n      totalBottomBoxesHeight = bottomPadding;\n      helpers.each(leftBoxes, function (box) {\n        totalLeftBoxesWidth += box.width;\n      });\n      helpers.each(rightBoxes, function (box) {\n        totalRightBoxesWidth += box.width;\n      });\n      helpers.each(topBoxes, function (box) {\n        totalTopBoxesHeight += box.height;\n      });\n      helpers.each(bottomBoxes, function (box) {\n        totalBottomBoxesHeight += box.height;\n      }); // We may be adding some padding to account for rotated x axis labels\n\n      var leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n      totalLeftBoxesWidth += leftPaddingAddition;\n      totalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n      var topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n      totalTopBoxesHeight += topPaddingAddition;\n      totalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0); // Figure out if our chart area changed. This would occur if the dataset layout label rotation\n      // changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n      // without calling `fit` again\n\n      var newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n      var newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n      if (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n        helpers.each(leftBoxes, function (box) {\n          box.height = newMaxChartAreaHeight;\n        });\n        helpers.each(rightBoxes, function (box) {\n          box.height = newMaxChartAreaHeight;\n        });\n        helpers.each(topBoxes, function (box) {\n          if (!box.fullWidth) {\n            box.width = newMaxChartAreaWidth;\n          }\n        });\n        helpers.each(bottomBoxes, function (box) {\n          if (!box.fullWidth) {\n            box.width = newMaxChartAreaWidth;\n          }\n        });\n        maxChartAreaHeight = newMaxChartAreaHeight;\n        maxChartAreaWidth = newMaxChartAreaWidth;\n      } // Step 7 - Position the boxes\n\n\n      var left = leftPadding + leftPaddingAddition;\n      var top = topPadding + topPaddingAddition;\n\n      function placeBox(box) {\n        if (box.isHorizontal()) {\n          box.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n          box.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n          box.top = top;\n          box.bottom = top + box.height; // Move to next point\n\n          top = box.bottom;\n        } else {\n          box.left = left;\n          box.right = left + box.width;\n          box.top = totalTopBoxesHeight;\n          box.bottom = totalTopBoxesHeight + maxChartAreaHeight; // Move to next point\n\n          left = box.right;\n        }\n      }\n\n      helpers.each(leftBoxes.concat(topBoxes), placeBox); // Account for chart width and height\n\n      left += maxChartAreaWidth;\n      top += maxChartAreaHeight;\n      helpers.each(rightBoxes, placeBox);\n      helpers.each(bottomBoxes, placeBox); // Step 8\n\n      chart.chartArea = {\n        left: totalLeftBoxesWidth,\n        top: totalTopBoxesHeight,\n        right: totalLeftBoxesWidth + maxChartAreaWidth,\n        bottom: totalTopBoxesHeight + maxChartAreaHeight\n      }; // Step 9\n\n      helpers.each(chartAreaBoxes, function (box) {\n        box.left = chart.chartArea.left;\n        box.top = chart.chartArea.top;\n        box.right = chart.chartArea.right;\n        box.bottom = chart.chartArea.bottom;\n        box.update(maxChartAreaWidth, maxChartAreaHeight);\n      });\n    }\n  };\n};","map":{"version":3,"sources":["/home/basis/TCC/codificacao/frontend/node_modules/chart.js/src/core/core.layoutService.js"],"names":["helpers","require","module","exports","Chart","filterByPosition","array","position","where","v","sortByWeight","reverse","forEach","i","_tmpIndex_","sort","a","b","v0","v1","weight","layoutService","defaults","addBox","chart","item","boxes","fullWidth","push","removeBox","layoutItem","index","indexOf","splice","configure","options","props","ilen","length","prop","hasOwnProperty","update","width","height","layoutOptions","layout","padding","toPadding","leftPadding","left","rightPadding","right","topPadding","top","bottomPadding","bottom","leftBoxes","rightBoxes","topBoxes","bottomBoxes","chartAreaBoxes","chartWidth","chartHeight","chartAreaWidth","chartAreaHeight","verticalBoxWidth","horizontalBoxHeight","maxChartAreaWidth","maxChartAreaHeight","minBoxSizes","getMinimumBoxSize","box","minSize","isHorizontal","horizontal","each","concat","maxHorizontalLeftPadding","maxHorizontalRightPadding","maxVerticalTopPadding","maxVerticalBottomPadding","horizontalBox","getPadding","boxPadding","Math","max","verticalBox","totalLeftBoxesWidth","totalRightBoxesWidth","totalTopBoxesHeight","totalBottomBoxesHeight","fitBox","minBoxSize","findNextWhere","minBox","scaleMargin","finalFitVerticalBox","leftPaddingAddition","topPaddingAddition","newMaxChartAreaHeight","newMaxChartAreaWidth","placeBox","chartArea"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\nmodule.exports = function(Chart) {\n\n\tfunction filterByPosition(array, position) {\n\t\treturn helpers.where(array, function(v) {\n\t\t\treturn v.position === position;\n\t\t});\n\t}\n\n\tfunction sortByWeight(array, reverse) {\n\t\tarray.forEach(function(v, i) {\n\t\t\tv._tmpIndex_ = i;\n\t\t\treturn v;\n\t\t});\n\t\tarray.sort(function(a, b) {\n\t\t\tvar v0 = reverse ? b : a;\n\t\t\tvar v1 = reverse ? a : b;\n\t\t\treturn v0.weight === v1.weight ?\n\t\t\t\tv0._tmpIndex_ - v1._tmpIndex_ :\n\t\t\t\tv0.weight - v1.weight;\n\t\t});\n\t\tarray.forEach(function(v) {\n\t\t\tdelete v._tmpIndex_;\n\t\t});\n\t}\n\n\t/**\n\t * @interface ILayoutItem\n\t * @prop {String} position - The position of the item in the chart layout. Possible values are\n\t * 'left', 'top', 'right', 'bottom', and 'chartArea'\n\t * @prop {Number} weight - The weight used to sort the item. Higher weights are further away from the chart area\n\t * @prop {Boolean} fullWidth - if true, and the item is horizontal, then push vertical boxes down\n\t * @prop {Function} isHorizontal - returns true if the layout item is horizontal (ie. top or bottom)\n\t * @prop {Function} update - Takes two parameters: width and height. Returns size of item\n\t * @prop {Function} getPadding -  Returns an object with padding on the edges\n\t * @prop {Number} width - Width of item. Must be valid after update()\n\t * @prop {Number} height - Height of item. Must be valid after update()\n\t * @prop {Number} left - Left edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} top - Top edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} right - Right edge of the item. Set by layout system and cannot be used in update\n\t * @prop {Number} bottom - Bottom edge of the item. Set by layout system and cannot be used in update\n\t */\n\n\t// The layout service is very self explanatory.  It's responsible for the layout within a chart.\n\t// Scales, Legends and Plugins all rely on the layout service and can easily register to be placed anywhere they need\n\t// It is this service's responsibility of carrying out that layout.\n\tChart.layoutService = {\n\t\tdefaults: {},\n\n\t\t/**\n\t\t * Register a box to a chart.\n\t\t * A box is simply a reference to an object that requires layout. eg. Scales, Legend, Title.\n\t\t * @param {Chart} chart - the chart to use\n\t\t * @param {ILayoutItem} item - the item to add to be layed out\n\t\t */\n\t\taddBox: function(chart, item) {\n\t\t\tif (!chart.boxes) {\n\t\t\t\tchart.boxes = [];\n\t\t\t}\n\n\t\t\t// initialize item with default values\n\t\t\titem.fullWidth = item.fullWidth || false;\n\t\t\titem.position = item.position || 'top';\n\t\t\titem.weight = item.weight || 0;\n\n\t\t\tchart.boxes.push(item);\n\t\t},\n\n\t\t/**\n\t\t * Remove a layoutItem from a chart\n\t\t * @param {Chart} chart - the chart to remove the box from\n\t\t * @param {Object} layoutItem - the item to remove from the layout\n\t\t */\n\t\tremoveBox: function(chart, layoutItem) {\n\t\t\tvar index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;\n\t\t\tif (index !== -1) {\n\t\t\t\tchart.boxes.splice(index, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Sets (or updates) options on the given `item`.\n\t\t * @param {Chart} chart - the chart in which the item lives (or will be added to)\n\t\t * @param {Object} item - the item to configure with the given options\n\t\t * @param {Object} options - the new item options.\n\t\t */\n\t\tconfigure: function(chart, item, options) {\n\t\t\tvar props = ['fullWidth', 'position', 'weight'];\n\t\t\tvar ilen = props.length;\n\t\t\tvar i = 0;\n\t\t\tvar prop;\n\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tprop = props[i];\n\t\t\t\tif (options.hasOwnProperty(prop)) {\n\t\t\t\t\titem[prop] = options[prop];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Fits boxes of the given chart into the given size by having each box measure itself\n\t\t * then running a fitting algorithm\n\t\t * @param {Chart} chart - the chart\n\t\t * @param {Number} width - the width to fit into\n\t\t * @param {Number} height - the height to fit into\n\t\t */\n\t\tupdate: function(chart, width, height) {\n\t\t\tif (!chart) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar layoutOptions = chart.options.layout || {};\n\t\t\tvar padding = helpers.options.toPadding(layoutOptions.padding);\n\t\t\tvar leftPadding = padding.left;\n\t\t\tvar rightPadding = padding.right;\n\t\t\tvar topPadding = padding.top;\n\t\t\tvar bottomPadding = padding.bottom;\n\n\t\t\tvar leftBoxes = filterByPosition(chart.boxes, 'left');\n\t\t\tvar rightBoxes = filterByPosition(chart.boxes, 'right');\n\t\t\tvar topBoxes = filterByPosition(chart.boxes, 'top');\n\t\t\tvar bottomBoxes = filterByPosition(chart.boxes, 'bottom');\n\t\t\tvar chartAreaBoxes = filterByPosition(chart.boxes, 'chartArea');\n\n\t\t\t// Sort boxes by weight. A higher weight is further away from the chart area\n\t\t\tsortByWeight(leftBoxes, true);\n\t\t\tsortByWeight(rightBoxes, false);\n\t\t\tsortByWeight(topBoxes, true);\n\t\t\tsortByWeight(bottomBoxes, false);\n\n\t\t\t// Essentially we now have any number of boxes on each of the 4 sides.\n\t\t\t// Our canvas looks like the following.\n\t\t\t// The areas L1 and L2 are the left axes. R1 is the right axis, T1 is the top axis and\n\t\t\t// B1 is the bottom axis\n\t\t\t// There are also 4 quadrant-like locations (left to right instead of clockwise) reserved for chart overlays\n\t\t\t// These locations are single-box locations only, when trying to register a chartArea location that is already taken,\n\t\t\t// an error will be thrown.\n\t\t\t//\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  T1 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |    |    |                 T2                  |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    | C1 |                           | C2 |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// | L1 | L2 |           ChartArea (C0)            | R1 |\n\t\t\t// |    |    |                                     |    |\n\t\t\t// |    |    |----|                           |----|    |\n\t\t\t// |    |    | C3 |                           | C4 |    |\n\t\t\t// |    |----|-------------------------------------|----|\n\t\t\t// |    |    |                 B1                  |    |\n\t\t\t// |----------------------------------------------------|\n\t\t\t// |                  B2 (Full Width)                   |\n\t\t\t// |----------------------------------------------------|\n\t\t\t//\n\t\t\t// What we do to find the best sizing, we do the following\n\t\t\t// 1. Determine the minimum size of the chart area.\n\t\t\t// 2. Split the remaining width equally between each vertical axis\n\t\t\t// 3. Split the remaining height equally between each horizontal axis\n\t\t\t// 4. Give each layout the maximum size it can be. The layout will return it's minimum size\n\t\t\t// 5. Adjust the sizes of each axis based on it's minimum reported size.\n\t\t\t// 6. Refit each axis\n\t\t\t// 7. Position each axis in the final location\n\t\t\t// 8. Tell the chart the final location of the chart area\n\t\t\t// 9. Tell any axes that overlay the chart area the positions of the chart area\n\n\t\t\t// Step 1\n\t\t\tvar chartWidth = width - leftPadding - rightPadding;\n\t\t\tvar chartHeight = height - topPadding - bottomPadding;\n\t\t\tvar chartAreaWidth = chartWidth / 2; // min 50%\n\t\t\tvar chartAreaHeight = chartHeight / 2; // min 50%\n\n\t\t\t// Step 2\n\t\t\tvar verticalBoxWidth = (width - chartAreaWidth) / (leftBoxes.length + rightBoxes.length);\n\n\t\t\t// Step 3\n\t\t\tvar horizontalBoxHeight = (height - chartAreaHeight) / (topBoxes.length + bottomBoxes.length);\n\n\t\t\t// Step 4\n\t\t\tvar maxChartAreaWidth = chartWidth;\n\t\t\tvar maxChartAreaHeight = chartHeight;\n\t\t\tvar minBoxSizes = [];\n\n\t\t\tfunction getMinimumBoxSize(box) {\n\t\t\t\tvar minSize;\n\t\t\t\tvar isHorizontal = box.isHorizontal();\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize = box.update(box.fullWidth ? chartWidth : maxChartAreaWidth, horizontalBoxHeight);\n\t\t\t\t\tmaxChartAreaHeight -= minSize.height;\n\t\t\t\t} else {\n\t\t\t\t\tminSize = box.update(verticalBoxWidth, chartAreaHeight);\n\t\t\t\t\tmaxChartAreaWidth -= minSize.width;\n\t\t\t\t}\n\n\t\t\t\tminBoxSizes.push({\n\t\t\t\t\thorizontal: isHorizontal,\n\t\t\t\t\tminSize: minSize,\n\t\t\t\t\tbox: box,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes, topBoxes, bottomBoxes), getMinimumBoxSize);\n\n\t\t\t// If a horizontal box has padding, we move the left boxes over to avoid ugly charts (see issue #2478)\n\t\t\tvar maxHorizontalLeftPadding = 0;\n\t\t\tvar maxHorizontalRightPadding = 0;\n\t\t\tvar maxVerticalTopPadding = 0;\n\t\t\tvar maxVerticalBottomPadding = 0;\n\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), function(horizontalBox) {\n\t\t\t\tif (horizontalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = horizontalBox.getPadding();\n\t\t\t\t\tmaxHorizontalLeftPadding = Math.max(maxHorizontalLeftPadding, boxPadding.left);\n\t\t\t\t\tmaxHorizontalRightPadding = Math.max(maxHorizontalRightPadding, boxPadding.right);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), function(verticalBox) {\n\t\t\t\tif (verticalBox.getPadding) {\n\t\t\t\t\tvar boxPadding = verticalBox.getPadding();\n\t\t\t\t\tmaxVerticalTopPadding = Math.max(maxVerticalTopPadding, boxPadding.top);\n\t\t\t\t\tmaxVerticalBottomPadding = Math.max(maxVerticalBottomPadding, boxPadding.bottom);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t// At this point, maxChartAreaHeight and maxChartAreaWidth are the size the chart area could\n\t\t\t// be if the axes are drawn at their minimum sizes.\n\t\t\t// Steps 5 & 6\n\t\t\tvar totalLeftBoxesWidth = leftPadding;\n\t\t\tvar totalRightBoxesWidth = rightPadding;\n\t\t\tvar totalTopBoxesHeight = topPadding;\n\t\t\tvar totalBottomBoxesHeight = bottomPadding;\n\n\t\t\t// Function to fit a box\n\t\t\tfunction fitBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minBox) {\n\t\t\t\t\treturn minBox.box === box;\n\t\t\t\t});\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\t\tvar scaleMargin = {\n\t\t\t\t\t\t\tleft: Math.max(totalLeftBoxesWidth, maxHorizontalLeftPadding),\n\t\t\t\t\t\t\tright: Math.max(totalRightBoxesWidth, maxHorizontalRightPadding),\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tbottom: 0\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\t// Don't use min size here because of label rotation. When the labels are rotated, their rotation highly depends\n\t\t\t\t\t\t// on the margin. Sometimes they need to increase in size slightly\n\t\t\t\t\t\tbox.update(box.fullWidth ? chartWidth : maxChartAreaWidth, chartHeight / 2, scaleMargin);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update, and calculate the left and right margins for the horizontal boxes\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), fitBox);\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\t// Set the Left and Right margins for the horizontal boxes\n\t\t\thelpers.each(topBoxes.concat(bottomBoxes), fitBox);\n\n\t\t\t// Figure out how much margin is on the top and bottom of the vertical boxes\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\tfunction finalFitVerticalBox(box) {\n\t\t\t\tvar minBoxSize = helpers.findNextWhere(minBoxSizes, function(minSize) {\n\t\t\t\t\treturn minSize.box === box;\n\t\t\t\t});\n\n\t\t\t\tvar scaleMargin = {\n\t\t\t\t\tleft: 0,\n\t\t\t\t\tright: 0,\n\t\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\t\tbottom: totalBottomBoxesHeight\n\t\t\t\t};\n\n\t\t\t\tif (minBoxSize) {\n\t\t\t\t\tbox.update(minBoxSize.minSize.width, maxChartAreaHeight, scaleMargin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Let the left layout know the final margin\n\t\t\thelpers.each(leftBoxes.concat(rightBoxes), finalFitVerticalBox);\n\n\t\t\t// Recalculate because the size of each layout might have changed slightly due to the margins (label rotation for instance)\n\t\t\ttotalLeftBoxesWidth = leftPadding;\n\t\t\ttotalRightBoxesWidth = rightPadding;\n\t\t\ttotalTopBoxesHeight = topPadding;\n\t\t\ttotalBottomBoxesHeight = bottomPadding;\n\n\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\ttotalLeftBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\ttotalRightBoxesWidth += box.width;\n\t\t\t});\n\n\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\ttotalTopBoxesHeight += box.height;\n\t\t\t});\n\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\ttotalBottomBoxesHeight += box.height;\n\t\t\t});\n\n\t\t\t// We may be adding some padding to account for rotated x axis labels\n\t\t\tvar leftPaddingAddition = Math.max(maxHorizontalLeftPadding - totalLeftBoxesWidth, 0);\n\t\t\ttotalLeftBoxesWidth += leftPaddingAddition;\n\t\t\ttotalRightBoxesWidth += Math.max(maxHorizontalRightPadding - totalRightBoxesWidth, 0);\n\n\t\t\tvar topPaddingAddition = Math.max(maxVerticalTopPadding - totalTopBoxesHeight, 0);\n\t\t\ttotalTopBoxesHeight += topPaddingAddition;\n\t\t\ttotalBottomBoxesHeight += Math.max(maxVerticalBottomPadding - totalBottomBoxesHeight, 0);\n\n\t\t\t// Figure out if our chart area changed. This would occur if the dataset layout label rotation\n\t\t\t// changed due to the application of the margins in step 6. Since we can only get bigger, this is safe to do\n\t\t\t// without calling `fit` again\n\t\t\tvar newMaxChartAreaHeight = height - totalTopBoxesHeight - totalBottomBoxesHeight;\n\t\t\tvar newMaxChartAreaWidth = width - totalLeftBoxesWidth - totalRightBoxesWidth;\n\n\t\t\tif (newMaxChartAreaWidth !== maxChartAreaWidth || newMaxChartAreaHeight !== maxChartAreaHeight) {\n\t\t\t\thelpers.each(leftBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(rightBoxes, function(box) {\n\t\t\t\t\tbox.height = newMaxChartAreaHeight;\n\t\t\t\t});\n\n\t\t\t\thelpers.each(topBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\thelpers.each(bottomBoxes, function(box) {\n\t\t\t\t\tif (!box.fullWidth) {\n\t\t\t\t\t\tbox.width = newMaxChartAreaWidth;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tmaxChartAreaHeight = newMaxChartAreaHeight;\n\t\t\t\tmaxChartAreaWidth = newMaxChartAreaWidth;\n\t\t\t}\n\n\t\t\t// Step 7 - Position the boxes\n\t\t\tvar left = leftPadding + leftPaddingAddition;\n\t\t\tvar top = topPadding + topPaddingAddition;\n\n\t\t\tfunction placeBox(box) {\n\t\t\t\tif (box.isHorizontal()) {\n\t\t\t\t\tbox.left = box.fullWidth ? leftPadding : totalLeftBoxesWidth;\n\t\t\t\t\tbox.right = box.fullWidth ? width - rightPadding : totalLeftBoxesWidth + maxChartAreaWidth;\n\t\t\t\t\tbox.top = top;\n\t\t\t\t\tbox.bottom = top + box.height;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\ttop = box.bottom;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tbox.left = left;\n\t\t\t\t\tbox.right = left + box.width;\n\t\t\t\t\tbox.top = totalTopBoxesHeight;\n\t\t\t\t\tbox.bottom = totalTopBoxesHeight + maxChartAreaHeight;\n\n\t\t\t\t\t// Move to next point\n\t\t\t\t\tleft = box.right;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\thelpers.each(leftBoxes.concat(topBoxes), placeBox);\n\n\t\t\t// Account for chart width and height\n\t\t\tleft += maxChartAreaWidth;\n\t\t\ttop += maxChartAreaHeight;\n\n\t\t\thelpers.each(rightBoxes, placeBox);\n\t\t\thelpers.each(bottomBoxes, placeBox);\n\n\t\t\t// Step 8\n\t\t\tchart.chartArea = {\n\t\t\t\tleft: totalLeftBoxesWidth,\n\t\t\t\ttop: totalTopBoxesHeight,\n\t\t\t\tright: totalLeftBoxesWidth + maxChartAreaWidth,\n\t\t\t\tbottom: totalTopBoxesHeight + maxChartAreaHeight\n\t\t\t};\n\n\t\t\t// Step 9\n\t\t\thelpers.each(chartAreaBoxes, function(box) {\n\t\t\t\tbox.left = chart.chartArea.left;\n\t\t\t\tbox.top = chart.chartArea.top;\n\t\t\t\tbox.right = chart.chartArea.right;\n\t\t\t\tbox.bottom = chart.chartArea.bottom;\n\n\t\t\t\tbox.update(maxChartAreaWidth, maxChartAreaHeight);\n\t\t\t});\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}