import { Injectable } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';
import { Authentication } from './authentication';
import * as i0 from "@angular/core";
import * as i1 from "./authentication";
/**
 * Provedor de error para criação de erros de notificação.
 * @class
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './authentication';
export class NotAuthenticatedErrorProvider {
    constructor(authenticationService) {
        this.authenticationService = authenticationService;
    }
    /**
     * Método para identificar se o usuário está logado
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    shouldHandle(error) {
        return error instanceof HttpErrorResponse && error.status == 401;
    }
    /**
     * Método para redirecionar caso o usuário não esteja
     * @public
     * @param {HttpErrorResponse} error
     * @returns void
     */
    handle(error) {
        this.authenticationService.redirect();
    }
}
NotAuthenticatedErrorProvider.ɵfac = function NotAuthenticatedErrorProvider_Factory(t) { return new (t || NotAuthenticatedErrorProvider)(ɵngcc0.ɵɵinject(ɵngcc1.Authentication)); };
NotAuthenticatedErrorProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function NotAuthenticatedErrorProvider_Factory() { return new NotAuthenticatedErrorProvider(i0.ɵɵinject(i1.Authentication)); }, token: NotAuthenticatedErrorProvider, providedIn: "root" });
NotAuthenticatedErrorProvider.ctorParameters = () => [
    { type: Authentication }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NotAuthenticatedErrorProvider, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Authentication }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm90LWF1dGhlbnRpY2F0ZWQtZXJyb3ItcHJvdmlkZXIuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1iYXNlL3NyYy9saWIvc2VjdXJpdHkvYXV0aGVudGljYXRpb24vbm90LWF1dGhlbnRpY2F0ZWQtZXJyb3ItcHJvdmlkZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxrQkFBa0IsQ0FBQztBQUNsRDtBQUdDO0FBREQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBSUgsTUFBTSxPQUFPLDZCQUE2QjtBQUFHLElBRXpDLFlBQW9CLHFCQUEyQztBQUFJLFFBQS9DLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBc0I7QUFBQyxJQUFHLENBQUM7QUFDeEUsSUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksWUFBWSxDQUFDLEtBQWdDO0FBQUksUUFDN0MsT0FBTyxLQUFLLFlBQVksaUJBQWlCLElBQUksS0FBSyxDQUFDLE1BQU0sSUFBSSxHQUFHLENBQUM7QUFDekUsSUFBSSxDQUFDO0FBQ0wsSUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksTUFBTSxDQUFDLEtBQXdCO0FBQUksUUFDL0IsSUFBSSxDQUFDLHFCQUFxQixDQUFDLFFBQVEsRUFBRSxDQUFDO0FBQzlDLElBQUksQ0FBQztBQUNMO29MQUNBO0FBQUMsbVFBeEJJO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBR2lELFlBVnBELGNBQWM7QUFBRztPQVF0QixVQUFVLEVBQUUsTUFBTSxlQUNyQjs7Ozs7K0VBVDJCO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEh0dHBFcnJvclJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgRXJyb3JQcm92aWRlciB9IGZyb20gJy4uLy4uL2Vycm9yL3Byb3ZpZGVycy9lcnJvci5wcm92aWRlcic7XG5pbXBvcnQgeyBBdXRoZW50aWNhdGlvbiB9IGZyb20gJy4vYXV0aGVudGljYXRpb24nO1xuaW1wb3J0IHsgVXNlciB9IGZyb20gJy4vdXNlcic7XG5cbi8qKlxuICogUHJvdmVkb3IgZGUgZXJyb3IgcGFyYSBjcmlhw6fDo28gZGUgZXJyb3MgZGUgbm90aWZpY2HDp8Ojby5cbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBOb3RBdXRoZW50aWNhdGVkRXJyb3JQcm92aWRlciBpbXBsZW1lbnRzIEVycm9yUHJvdmlkZXIge1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uPFVzZXI+KSB7IH1cblxuICAgIC8qKlxuICAgICAqIE3DqXRvZG8gcGFyYSBpZGVudGlmaWNhciBzZSBvIHVzdcOhcmlvIGVzdMOhIGxvZ2Fkb1xuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0h0dHBFcnJvclJlc3BvbnNlfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBzaG91bGRIYW5kbGUoZXJyb3I6IEVycm9yIHwgSHR0cEVycm9yUmVzcG9uc2UpOiBCb29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgSHR0cEVycm9yUmVzcG9uc2UgJiYgZXJyb3Iuc3RhdHVzID09IDQwMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHBhcmEgcmVkaXJlY2lvbmFyIGNhc28gbyB1c3XDoXJpbyBuw6NvIGVzdGVqYVxuICAgICAqIEBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge0h0dHBFcnJvclJlc3BvbnNlfSBlcnJvclxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBoYW5kbGUoZXJyb3I6IEh0dHBFcnJvclJlc3BvbnNlKTogdm9pZCB7XG4gICAgICAgIHRoaXMuYXV0aGVudGljYXRpb25TZXJ2aWNlLnJlZGlyZWN0KCk7XG4gICAgfVxuXG59XG4iXX0=