{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\n\n\nmodule.exports = {\n  /**\n   * Namespace to hold generators for different types of ticks\n   * @namespace Chart.Ticks.generators\n   */\n  generators: {\n    /**\n     * Interface for the options provided to the numeric tick generator\n     * @interface INumericTickGenerationOptions\n     */\n\n    /**\n     * The maximum number of ticks to display\n     * @name INumericTickGenerationOptions#maxTicks\n     * @type Number\n     */\n\n    /**\n     * The distance between each tick.\n     * @name INumericTickGenerationOptions#stepSize\n     * @type Number\n     * @optional\n     */\n\n    /**\n     * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n     * @name INumericTickGenerationOptions#min\n     * @type Number\n     * @optional\n     */\n\n    /**\n     * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n     * @name INumericTickGenerationOptions#max\n     * @type Number\n     * @optional\n     */\n\n    /**\n     * Generate a set of linear ticks\n     * @method Chart.Ticks.generators.linear\n     * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n     * @param dataRange {IRange} the range of the data\n     * @returns {Array<Number>} array of tick values\n     */\n    linear: function linear(generationOptions, dataRange) {\n      var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n      // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n      // for details.\n\n      var spacing;\n\n      if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n        spacing = generationOptions.stepSize;\n      } else {\n        var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n        spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n      }\n\n      var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n      var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n      if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n        // If very close to our whole number, use it.\n        if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n          niceMin = generationOptions.min;\n          niceMax = generationOptions.max;\n        }\n      }\n\n      var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n      if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n        numSpaces = Math.round(numSpaces);\n      } else {\n        numSpaces = Math.ceil(numSpaces);\n      } // Put the values into the ticks array\n\n\n      ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\n      for (var j = 1; j < numSpaces; ++j) {\n        ticks.push(niceMin + j * spacing);\n      }\n\n      ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n      return ticks;\n    },\n\n    /**\n     * Generate a set of logarithmic ticks\n     * @method Chart.Ticks.generators.logarithmic\n     * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n     * @param dataRange {IRange} the range of the data\n     * @returns {Array<Number>} array of tick values\n     */\n    logarithmic: function logarithmic(generationOptions, dataRange) {\n      var ticks = [];\n      var valueOrDefault = helpers.valueOrDefault; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph\n\n      var tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n      var endExp = Math.floor(helpers.log10(dataRange.max));\n      var endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n      var exp, significand;\n\n      if (tickVal === 0) {\n        exp = Math.floor(helpers.log10(dataRange.minNotZero));\n        significand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n        ticks.push(tickVal);\n        tickVal = significand * Math.pow(10, exp);\n      } else {\n        exp = Math.floor(helpers.log10(tickVal));\n        significand = Math.floor(tickVal / Math.pow(10, exp));\n      }\n\n      do {\n        ticks.push(tickVal);\n        ++significand;\n\n        if (significand === 10) {\n          significand = 1;\n          ++exp;\n        }\n\n        tickVal = significand * Math.pow(10, exp);\n      } while (exp < endExp || exp === endExp && significand < endSignificand);\n\n      var lastTick = valueOrDefault(generationOptions.max, tickVal);\n      ticks.push(lastTick);\n      return ticks;\n    }\n  },\n\n  /**\n   * Namespace to hold formatters for different types of ticks\n   * @namespace Chart.Ticks.formatters\n   */\n  formatters: {\n    /**\n     * Formatter for value labels\n     * @method Chart.Ticks.formatters.values\n     * @param value the value to display\n     * @return {String|Array} the label to display\n     */\n    values: function values(value) {\n      return helpers.isArray(value) ? value : '' + value;\n    },\n\n    /**\n     * Formatter for linear numeric ticks\n     * @method Chart.Ticks.formatters.linear\n     * @param tickValue {Number} the value to be formatted\n     * @param index {Number} the position of the tickValue parameter in the ticks array\n     * @param ticks {Array<Number>} the list of ticks being converted\n     * @return {String} string representation of the tickValue parameter\n     */\n    linear: function linear(tickValue, index, ticks) {\n      // If we have lots of ticks, don't use the ones\n      var delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0]; // If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\n      if (Math.abs(delta) > 1) {\n        if (tickValue !== Math.floor(tickValue)) {\n          // not an integer\n          delta = tickValue - Math.floor(tickValue);\n        }\n      }\n\n      var logDelta = helpers.log10(Math.abs(delta));\n      var tickString = '';\n\n      if (tickValue !== 0) {\n        var numDecimal = -1 * Math.floor(logDelta);\n        numDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\n        tickString = tickValue.toFixed(numDecimal);\n      } else {\n        tickString = '0'; // never show decimal places for 0\n      }\n\n      return tickString;\n    },\n    logarithmic: function logarithmic(tickValue, index, ticks) {\n      var remain = tickValue / Math.pow(10, Math.floor(helpers.log10(tickValue)));\n\n      if (tickValue === 0) {\n        return '0';\n      } else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n        return tickValue.toExponential();\n      }\n\n      return '';\n    }\n  }\n};","map":{"version":3,"sources":["/home/basis/template/p-lc-aprd_codigo_fonte/client/node_modules/chart.js/src/core/core.ticks.js"],"names":["helpers","require","module","exports","generators","linear","generationOptions","dataRange","ticks","spacing","stepSize","niceRange","niceNum","max","min","maxTicks","niceMin","Math","floor","niceMax","ceil","almostWhole","numSpaces","almostEquals","round","push","undefined","j","logarithmic","valueOrDefault","tickVal","pow","log10","endExp","endSignificand","exp","significand","minNotZero","lastTick","formatters","values","value","isArray","tickValue","index","delta","length","abs","logDelta","tickString","numDecimal","toFixed","remain","toExponential"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Namespace to hold static tick generation functions\n * @namespace Chart.Ticks\n */\nmodule.exports = {\n\t/**\n\t * Namespace to hold generators for different types of ticks\n\t * @namespace Chart.Ticks.generators\n\t */\n\tgenerators: {\n\t\t/**\n\t\t * Interface for the options provided to the numeric tick generator\n\t\t * @interface INumericTickGenerationOptions\n\t\t */\n\t\t/**\n\t\t * The maximum number of ticks to display\n\t\t * @name INumericTickGenerationOptions#maxTicks\n\t\t * @type Number\n\t\t */\n\t\t/**\n\t\t * The distance between each tick.\n\t\t * @name INumericTickGenerationOptions#stepSize\n\t\t * @type Number\n\t\t * @optional\n\t\t */\n\t\t/**\n\t\t * Forced minimum for the ticks. If not specified, the minimum of the data range is used to calculate the tick minimum\n\t\t * @name INumericTickGenerationOptions#min\n\t\t * @type Number\n\t\t * @optional\n\t\t */\n\t\t/**\n\t\t * The maximum value of the ticks. If not specified, the maximum of the data range is used to calculate the tick maximum\n\t\t * @name INumericTickGenerationOptions#max\n\t\t * @type Number\n\t\t * @optional\n\t\t */\n\n\t\t/**\n\t\t * Generate a set of linear ticks\n\t\t * @method Chart.Ticks.generators.linear\n\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t * @param dataRange {IRange} the range of the data\n\t\t * @returns {Array<Number>} array of tick values\n\t\t */\n\t\tlinear: function(generationOptions, dataRange) {\n\t\t\tvar ticks = [];\n\t\t\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t\t\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t\t\t// for details.\n\n\t\t\tvar spacing;\n\t\t\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\t\t\tspacing = generationOptions.stepSize;\n\t\t\t} else {\n\t\t\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\t\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t\t\t}\n\t\t\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\t\t\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t\t\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\t\t\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t\t\t// If very close to our whole number, use it.\n\t\t\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\t\t\tniceMin = generationOptions.min;\n\t\t\t\t\tniceMax = generationOptions.max;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t\t\t// If very close to our rounded value, use it.\n\t\t\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\t\t\tnumSpaces = Math.round(numSpaces);\n\t\t\t} else {\n\t\t\t\tnumSpaces = Math.ceil(numSpaces);\n\t\t\t}\n\n\t\t\t// Put the values into the ticks array\n\t\t\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\t\t\tfor (var j = 1; j < numSpaces; ++j) {\n\t\t\t\tticks.push(niceMin + (j * spacing));\n\t\t\t}\n\t\t\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\t\t\treturn ticks;\n\t\t},\n\n\t\t/**\n\t\t * Generate a set of logarithmic ticks\n\t\t * @method Chart.Ticks.generators.logarithmic\n\t\t * @param generationOptions {INumericTickGenerationOptions} the options used to generate the ticks\n\t\t * @param dataRange {IRange} the range of the data\n\t\t * @returns {Array<Number>} array of tick values\n\t\t */\n\t\tlogarithmic: function(generationOptions, dataRange) {\n\t\t\tvar ticks = [];\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph\n\t\t\tvar tickVal = valueOrDefault(generationOptions.min, Math.pow(10, Math.floor(helpers.log10(dataRange.min))));\n\n\t\t\tvar endExp = Math.floor(helpers.log10(dataRange.max));\n\t\t\tvar endSignificand = Math.ceil(dataRange.max / Math.pow(10, endExp));\n\t\t\tvar exp, significand;\n\n\t\t\tif (tickVal === 0) {\n\t\t\t\texp = Math.floor(helpers.log10(dataRange.minNotZero));\n\t\t\t\tsignificand = Math.floor(dataRange.minNotZero / Math.pow(10, exp));\n\n\t\t\t\tticks.push(tickVal);\n\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t} else {\n\t\t\t\texp = Math.floor(helpers.log10(tickVal));\n\t\t\t\tsignificand = Math.floor(tickVal / Math.pow(10, exp));\n\t\t\t}\n\n\t\t\tdo {\n\t\t\t\tticks.push(tickVal);\n\n\t\t\t\t++significand;\n\t\t\t\tif (significand === 10) {\n\t\t\t\t\tsignificand = 1;\n\t\t\t\t\t++exp;\n\t\t\t\t}\n\n\t\t\t\ttickVal = significand * Math.pow(10, exp);\n\t\t\t} while (exp < endExp || (exp === endExp && significand < endSignificand));\n\n\t\t\tvar lastTick = valueOrDefault(generationOptions.max, tickVal);\n\t\t\tticks.push(lastTick);\n\n\t\t\treturn ticks;\n\t\t}\n\t},\n\n\t/**\n\t * Namespace to hold formatters for different types of ticks\n\t * @namespace Chart.Ticks.formatters\n\t */\n\tformatters: {\n\t\t/**\n\t\t * Formatter for value labels\n\t\t * @method Chart.Ticks.formatters.values\n\t\t * @param value the value to display\n\t\t * @return {String|Array} the label to display\n\t\t */\n\t\tvalues: function(value) {\n\t\t\treturn helpers.isArray(value) ? value : '' + value;\n\t\t},\n\n\t\t/**\n\t\t * Formatter for linear numeric ticks\n\t\t * @method Chart.Ticks.formatters.linear\n\t\t * @param tickValue {Number} the value to be formatted\n\t\t * @param index {Number} the position of the tickValue parameter in the ticks array\n\t\t * @param ticks {Array<Number>} the list of ticks being converted\n\t\t * @return {String} string representation of the tickValue parameter\n\t\t */\n\t\tlinear: function(tickValue, index, ticks) {\n\t\t\t// If we have lots of ticks, don't use the ones\n\t\t\tvar delta = ticks.length > 3 ? ticks[2] - ticks[1] : ticks[1] - ticks[0];\n\n\t\t\t// If we have a number like 2.5 as the delta, figure out how many decimal places we need\n\t\t\tif (Math.abs(delta) > 1) {\n\t\t\t\tif (tickValue !== Math.floor(tickValue)) {\n\t\t\t\t\t// not an integer\n\t\t\t\t\tdelta = tickValue - Math.floor(tickValue);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar logDelta = helpers.log10(Math.abs(delta));\n\t\t\tvar tickString = '';\n\n\t\t\tif (tickValue !== 0) {\n\t\t\t\tvar numDecimal = -1 * Math.floor(logDelta);\n\t\t\t\tnumDecimal = Math.max(Math.min(numDecimal, 20), 0); // toFixed has a max of 20 decimal places\n\t\t\t\ttickString = tickValue.toFixed(numDecimal);\n\t\t\t} else {\n\t\t\t\ttickString = '0'; // never show decimal places for 0\n\t\t\t}\n\n\t\t\treturn tickString;\n\t\t},\n\n\t\tlogarithmic: function(tickValue, index, ticks) {\n\t\t\tvar remain = tickValue / (Math.pow(10, Math.floor(helpers.log10(tickValue))));\n\n\t\t\tif (tickValue === 0) {\n\t\t\t\treturn '0';\n\t\t\t} else if (remain === 1 || remain === 2 || remain === 5 || index === 0 || index === ticks.length - 1) {\n\t\t\t\treturn tickValue.toExponential();\n\t\t\t}\n\t\t\treturn '';\n\t\t}\n\t}\n};\n"]},"metadata":{},"sourceType":"script"}