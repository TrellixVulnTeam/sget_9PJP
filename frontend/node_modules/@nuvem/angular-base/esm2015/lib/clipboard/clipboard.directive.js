import { Directive, Input, Output, EventEmitter, HostListener } from '@angular/core';
import { ClipboardService } from './clipboard.service';
/**
 * Diretiva que expõe seletor para o uso do clipbord
 * @class
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './clipboard.service';
export class ClipboardDirective {
    /**
     * constructor method
     * @param {ClipboardService} service
     * @constructor
     */
    constructor(service) {
        this.service = service;
        /**
         * onClipboard variable
         * @type {EventEmitter<boolean>}
         */
        this.onClipboard = new EventEmitter();
    }
    /**
     * copy method
     * @event click
     * @returns void
     */
    copy() {
        try {
            this.service.copy(this.clipboard);
            this.onClipboard.emit(true);
        }
        catch (e) {
            this.onClipboard.emit(false);
            throw e;
        }
    }
}
ClipboardDirective.ɵfac = function ClipboardDirective_Factory(t) { return new (t || ClipboardDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ClipboardService)); };
ClipboardDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ClipboardDirective, selectors: [["", "clipboard", ""]], hostBindings: function ClipboardDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function ClipboardDirective_click_HostBindingHandler() { return ctx.copy(); });
    } }, inputs: { clipboard: "clipboard" }, outputs: { onClipboard: "onClipboard" } });
ClipboardDirective.ctorParameters = () => [
    { type: ClipboardService }
];
ClipboardDirective.propDecorators = {
    clipboard: [{ type: Input }],
    onClipboard: [{ type: Output }],
    copy: [{ type: HostListener, args: ['click',] }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ClipboardDirective, [{
        type: Directive,
        args: [{
                selector: '[clipboard]'
            }]
    }], function () { return [{ type: ɵngcc1.ClipboardService }]; }, { onClipboard: [{
            type: Output
        }], 
    /**
     * copy method
     * @event click
     * @returns void
     */
    copy: [{
            type: HostListener,
            args: ['click']
        }], clipboard: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xpcGJvYXJkLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1iYXNlL3NyYy9saWIvY2xpcGJvYXJkL2NsaXBib2FyZC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFckYsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0scUJBQXFCLENBQUM7QUFLdkQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBQ0gsTUFBTSxPQUFPLGtCQUFrQjtBQUMvQixJQWVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksWUFBb0IsT0FBeUI7QUFBSSxRQUE3QixZQUFPLEdBQVAsT0FBTyxDQUFrQjtBQUFDLFFBWjlDO0FBQ0o7QUFDSTtBQUVKLFdBRE87QUFDUCxRQUNJLGdCQUFXLEdBQTBCLElBQUksWUFBWSxFQUFXLENBQUM7QUFDckUsSUFNb0QsQ0FBQztBQUNyRCxJQUVJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksSUFBSTtBQUNSLFFBQVEsSUFBSTtBQUNaLFlBQVksSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0FBQzlDLFlBQVksSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7QUFDeEMsU0FBUztBQUFDLFFBQUEsT0FBTyxDQUFDLEVBQUU7QUFDcEIsWUFBWSxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUN6QyxZQUFZLE1BQU0sQ0FBQyxDQUFDO0FBQ3BCLFNBQVM7QUFDVCxJQUFJLENBQUM7QUFDTDs4Q0E3Q0MsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFBRSxhQUFhLGNBQzFCOzs7d0ZBRUE7QUFBQztBQUE0QyxZQU5yQyxnQkFBZ0I7QUFBRztBQUFHO0FBRW5CLHdCQWFQLEtBQUs7QUFDUiwwQkFNRyxNQUFNO0FBQ1QsbUJBU0csWUFBWSxTQUFDLE9BQU87QUFDckI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE91dHB1dCwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuaW1wb3J0IHsgQ2xpcGJvYXJkU2VydmljZSB9IGZyb20gJy4vY2xpcGJvYXJkLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tjbGlwYm9hcmRdJ1xufSlcbi8qKlxuICogRGlyZXRpdmEgcXVlIGV4cMO1ZSBzZWxldG9yIHBhcmEgbyB1c28gZG8gY2xpcGJvcmRcbiAqIEBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgQ2xpcGJvYXJkRGlyZWN0aXZlIHtcblxuICAgIC8qKlxuICAgICAqIGNsaXBib2FyZCB2YXJpYWJsZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBjbGlwYm9hcmQ6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIG9uQ2xpcGJvYXJkIHZhcmlhYmxlXG4gICAgICogQHR5cGUge0V2ZW50RW1pdHRlcjxib29sZWFuPn1cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBvbkNsaXBib2FyZDogRXZlbnRFbWl0dGVyPGJvb2xlYW4+ID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3IgbWV0aG9kXG4gICAgICogQHBhcmFtIHtDbGlwYm9hcmRTZXJ2aWNlfSBzZXJ2aWNlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBzZXJ2aWNlOiBDbGlwYm9hcmRTZXJ2aWNlKSB7fVxuXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIC8qKlxuICAgICAqIGNvcHkgbWV0aG9kXG4gICAgICogQGV2ZW50IGNsaWNrXG4gICAgICogQHJldHVybnMgdm9pZFxuICAgICAqL1xuICAgIGNvcHkoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNlcnZpY2UuY29weSh0aGlzLmNsaXBib2FyZCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xpcGJvYXJkLmVtaXQodHJ1ZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMub25DbGlwYm9hcmQuZW1pdChmYWxzZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19