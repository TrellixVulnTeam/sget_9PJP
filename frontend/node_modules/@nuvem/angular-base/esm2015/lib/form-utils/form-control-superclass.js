import { Directive } from "@angular/core";
import { NG_VALUE_ACCESSOR } from "@angular/forms";
import { DirectiveSuperclass } from "./directive-superclass";
import * as ɵngcc0 from '@angular/core';
export function noop() { }
;
/**
 * Use in the `providers` of a component that implements `ControlValueAccessor` to reduce some boilerplate.
 *
 * ```ts
 * @Component({ providers: [provideValueAccessor(MyFormControl)] }
 * class MyFormControl extends BaseFormControl {
 *   // ...
 * }
 * ```
 */
export function provideValueAccessor(type) {
    return {
        provide: NG_VALUE_ACCESSOR,
        useExisting: type,
        multi: true,
    };
}
/**
 * Extend this when creating a form control to reduce some boilerplate. **Warning:** You _must_ include a constructor in your subclass.
 *
 * This example allows 2-way binding to a number via `[(ngModel)]`, `[formControl]`, or any other technique that leverages the `ControlValueAccessor` interface.
 * ```ts
 * @Component({
 *   template: `
 *     <button (click)="increment()" [disabled]="isDisabled">{{ counter }}</button>
 *   `,
 *   providers: [provideValueAccessor(CounterComponent)],
 * })
 * class CounterComponent extends FormControlSuperclass<number> {
 *   counter = 0;
 *
 *   // This looks unnecessary, but is required for Angular to provide `Injector`
 *   constructor(injector: Injector) {
 *     super(injector);
 *   }
 *
 *   handleIncomingValue(value: number) {
 *     this.counter = value;
 *   }
 *
 *   increment() {
 *     this.emitOutgoingValue(++this.counter);
 *     this.onTouched();
 *   }
 * }
 * ```
 */
export class FormControlSuperclass extends DirectiveSuperclass {
    constructor() {
        super(...arguments);
        /** Call this to emit a new value when it changes. */
        this.emitOutgoingValue = noop;
        /** Call this to "commit" a change, traditionally done e.g. on blur. */
        this.onTouched = noop;
        /** You can bind to this in your template as needed. */
        this.isDisabled = false;
    }
    /** Called as angular propagates value changes to this `ControlValueAccessor`. You normally do not need to use it. */
    writeValue(value) {
        this.handleIncomingValue(value);
        this.changeDetectorRef.markForCheck();
    }
    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
    registerOnChange(fn) {
        this.emitOutgoingValue = fn;
    }
    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */
    setDisabledState(isDisabled) {
        this.isDisabled = isDisabled;
        this.changeDetectorRef.markForCheck();
    }
}
FormControlSuperclass.ɵfac = function FormControlSuperclass_Factory(t) { return ɵFormControlSuperclass_BaseFactory(t || FormControlSuperclass); };
FormControlSuperclass.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FormControlSuperclass, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
const ɵFormControlSuperclass_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(FormControlSuperclass);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(FormControlSuperclass, [{
        type: Directive
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9ybS1jb250cm9sLXN1cGVyY2xhc3MuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYmFzZS9zcmMvbGliL2Zvcm0tdXRpbHMvZm9ybS1jb250cm9sLXN1cGVyY2xhc3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFRLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRCxPQUFPLEVBQXdCLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7O0FBRTdELE1BQU0sVUFBVSxJQUFJLEtBQUssQ0FBQztBQUFBLENBQUM7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxJQUFlO0FBQ3BELElBQUksT0FBTztBQUNYLFFBQVEsT0FBTyxFQUFFLGlCQUFpQjtBQUNsQyxRQUFRLFdBQVcsRUFBRSxJQUFJO0FBQ3pCLFFBQVEsS0FBSyxFQUFFLElBQUk7QUFDbkIsS0FBSyxDQUFDO0FBQ04sQ0FBQztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsTUFBTSxPQUFnQixxQkFBeUIsU0FBUSxtQkFBbUI7QUFDeEUsSUFGRjtBQUNHO0FBQTZCLFFBRTVCLHFEQUFxRDtBQUN6RCxRQUFJLHNCQUFpQixHQUF1QixJQUFJLENBQUM7QUFDakQsUUFDSSx1RUFBdUU7QUFDM0UsUUFBSSxjQUFTLEdBQUcsSUFBSSxDQUFDO0FBQ3JCLFFBQ0ksdURBQXVEO0FBQzNELFFBQUksZUFBVSxHQUFHLEtBQUssQ0FBQztBQUN2QixJQXlCQSxDQUFDO0FBQ0QsSUF0QkkscUhBQXFIO0FBQ3pILElBQUksVUFBVSxDQUFDLEtBQVE7QUFDdkIsUUFBUSxJQUFJLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDeEMsUUFBUSxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxFQUFFLENBQUM7QUFDOUMsSUFBSSxDQUFDO0FBQ0wsSUFDSSxnSEFBZ0g7QUFDcEgsSUFBSSxnQkFBZ0IsQ0FBQyxFQUFzQjtBQUMzQyxRQUFRLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLENBQUM7QUFDcEMsSUFBSSxDQUFDO0FBQ0wsSUFDSSxnSEFBZ0g7QUFDcEgsSUFBSSxpQkFBaUIsQ0FBQyxFQUFnQjtBQUN0QyxRQUFRLElBQUksQ0FBQyxTQUFTLEdBQUcsRUFBRSxDQUFDO0FBQzVCLElBQUksQ0FBQztBQUNMLElBQ0ksd0hBQXdIO0FBQzVILElBQUksZ0JBQWdCLENBQUMsVUFBbUI7QUFDeEMsUUFBUSxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsQ0FBQztBQUNyQyxRQUFRLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztBQUM5QyxJQUFJLENBQUM7QUFDTDtpREFwQ0MsU0FBUzs7Ozs7MEJBQ1I7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFR5cGUsIERpcmVjdGl2ZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTkdfVkFMVUVfQUNDRVNTT1IgfSBmcm9tIFwiQGFuZ3VsYXIvZm9ybXNcIjtcbmltcG9ydCB7IERpcmVjdGl2ZVN1cGVyY2xhc3MgfSBmcm9tIFwiLi9kaXJlY3RpdmUtc3VwZXJjbGFzc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9vcCgpIHsgfTtcblxuLyoqXG4gKiBVc2UgaW4gdGhlIGBwcm92aWRlcnNgIG9mIGEgY29tcG9uZW50IHRoYXQgaW1wbGVtZW50cyBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIHRvIHJlZHVjZSBzb21lIGJvaWxlcnBsYXRlLlxuICpcbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHsgcHJvdmlkZXJzOiBbcHJvdmlkZVZhbHVlQWNjZXNzb3IoTXlGb3JtQ29udHJvbCldIH1cbiAqIGNsYXNzIE15Rm9ybUNvbnRyb2wgZXh0ZW5kcyBCYXNlRm9ybUNvbnRyb2wge1xuICogICAvLyAuLi5cbiAqIH1cbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvdmlkZVZhbHVlQWNjZXNzb3IodHlwZTogVHlwZTxhbnk+KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gICAgICAgIHVzZUV4aXN0aW5nOiB0eXBlLFxuICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIEV4dGVuZCB0aGlzIHdoZW4gY3JlYXRpbmcgYSBmb3JtIGNvbnRyb2wgdG8gcmVkdWNlIHNvbWUgYm9pbGVycGxhdGUuICoqV2FybmluZzoqKiBZb3UgX211c3RfIGluY2x1ZGUgYSBjb25zdHJ1Y3RvciBpbiB5b3VyIHN1YmNsYXNzLlxuICpcbiAqIFRoaXMgZXhhbXBsZSBhbGxvd3MgMi13YXkgYmluZGluZyB0byBhIG51bWJlciB2aWEgYFsobmdNb2RlbCldYCwgYFtmb3JtQ29udHJvbF1gLCBvciBhbnkgb3RoZXIgdGVjaG5pcXVlIHRoYXQgbGV2ZXJhZ2VzIHRoZSBgQ29udHJvbFZhbHVlQWNjZXNzb3JgIGludGVyZmFjZS5cbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8YnV0dG9uIChjbGljayk9XCJpbmNyZW1lbnQoKVwiIFtkaXNhYmxlZF09XCJpc0Rpc2FibGVkXCI+e3sgY291bnRlciB9fTwvYnV0dG9uPlxuICogICBgLFxuICogICBwcm92aWRlcnM6IFtwcm92aWRlVmFsdWVBY2Nlc3NvcihDb3VudGVyQ29tcG9uZW50KV0sXG4gKiB9KVxuICogY2xhc3MgQ291bnRlckNvbXBvbmVudCBleHRlbmRzIEZvcm1Db250cm9sU3VwZXJjbGFzczxudW1iZXI+IHtcbiAqICAgY291bnRlciA9IDA7XG4gKlxuICogICAvLyBUaGlzIGxvb2tzIHVubmVjZXNzYXJ5LCBidXQgaXMgcmVxdWlyZWQgZm9yIEFuZ3VsYXIgdG8gcHJvdmlkZSBgSW5qZWN0b3JgXG4gKiAgIGNvbnN0cnVjdG9yKGluamVjdG9yOiBJbmplY3Rvcikge1xuICogICAgIHN1cGVyKGluamVjdG9yKTtcbiAqICAgfVxuICpcbiAqICAgaGFuZGxlSW5jb21pbmdWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gKiAgICAgdGhpcy5jb3VudGVyID0gdmFsdWU7XG4gKiAgIH1cbiAqXG4gKiAgIGluY3JlbWVudCgpIHtcbiAqICAgICB0aGlzLmVtaXRPdXRnb2luZ1ZhbHVlKCsrdGhpcy5jb3VudGVyKTtcbiAqICAgICB0aGlzLm9uVG91Y2hlZCgpO1xuICogICB9XG4gKiB9XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSgpXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgRm9ybUNvbnRyb2xTdXBlcmNsYXNzPFQ+IGV4dGVuZHMgRGlyZWN0aXZlU3VwZXJjbGFzc1xuICAgIGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xuICAgIC8qKiBDYWxsIHRoaXMgdG8gZW1pdCBhIG5ldyB2YWx1ZSB3aGVuIGl0IGNoYW5nZXMuICovXG4gICAgZW1pdE91dGdvaW5nVmFsdWU6ICh2YWx1ZTogVCkgPT4gdm9pZCA9IG5vb3A7XG5cbiAgICAvKiogQ2FsbCB0aGlzIHRvIFwiY29tbWl0XCIgYSBjaGFuZ2UsIHRyYWRpdGlvbmFsbHkgZG9uZSBlLmcuIG9uIGJsdXIuICovXG4gICAgb25Ub3VjaGVkID0gbm9vcDtcblxuICAgIC8qKiBZb3UgY2FuIGJpbmQgdG8gdGhpcyBpbiB5b3VyIHRlbXBsYXRlIGFzIG5lZWRlZC4gKi9cbiAgICBpc0Rpc2FibGVkID0gZmFsc2U7XG5cbiAgICAvKiogSW1wbGVtZW50IHRoaXMgdG8gaGFuZGxlIGEgbmV3IHZhbHVlIGNvbWluZyBpbiBmcm9tIG91dHNpZGUuICovXG4gICAgYWJzdHJhY3QgaGFuZGxlSW5jb21pbmdWYWx1ZSh2YWx1ZTogVCk6IHZvaWQ7XG5cbiAgICAvKiogQ2FsbGVkIGFzIGFuZ3VsYXIgcHJvcGFnYXRlcyB2YWx1ZSBjaGFuZ2VzIHRvIHRoaXMgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYC4gWW91IG5vcm1hbGx5IGRvIG5vdCBuZWVkIHRvIHVzZSBpdC4gKi9cbiAgICB3cml0ZVZhbHVlKHZhbHVlOiBUKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYubWFya0ZvckNoZWNrKCk7XG4gICAgfVxuXG4gICAgLyoqIENhbGxlZCBhcyBhbmd1bGFyIHNldHMgdXAgdGhlIGJpbmRpbmcgdG8gdGhpcyBgQ29udHJvbFZhbHVlQWNjZXNzb3JgLiBZb3Ugbm9ybWFsbHkgZG8gbm90IG5lZWQgdG8gdXNlIGl0LiAqL1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46ICh2YWx1ZTogVCkgPT4gdm9pZCkge1xuICAgICAgICB0aGlzLmVtaXRPdXRnb2luZ1ZhbHVlID0gZm47XG4gICAgfVxuXG4gICAgLyoqIENhbGxlZCBhcyBhbmd1bGFyIHNldHMgdXAgdGhlIGJpbmRpbmcgdG8gdGhpcyBgQ29udHJvbFZhbHVlQWNjZXNzb3JgLiBZb3Ugbm9ybWFsbHkgZG8gbm90IG5lZWQgdG8gdXNlIGl0LiAqL1xuICAgIHJlZ2lzdGVyT25Ub3VjaGVkKGZuOiBWb2lkRnVuY3Rpb24pIHtcbiAgICAgICAgdGhpcy5vblRvdWNoZWQgPSBmbjtcbiAgICB9XG5cbiAgICAvKiogQ2FsbGVkIGFzIGFuZ3VsYXIgcHJvcGFnYXRlcyBkaXNhYmxlZCBjaGFuZ2VzIHRvIHRoaXMgYENvbnRyb2xWYWx1ZUFjY2Vzc29yYC4gWW91IG5vcm1hbGx5IGRvIG5vdCBuZWVkIHRvIHVzZSBpdC4gKi9cbiAgICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5pc0Rpc2FibGVkID0gaXNEaXNhYmxlZDtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICB9XG59XG4iXX0=