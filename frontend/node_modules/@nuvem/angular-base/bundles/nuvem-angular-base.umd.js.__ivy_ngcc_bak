(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common/http'), require('@angular/core'), require('rxjs/operators'), require('rxjs'), require('@angular/common'), require('@angular/router'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@nuvem/angular-base', ['exports', '@angular/common/http', '@angular/core', 'rxjs/operators', 'rxjs', '@angular/common', '@angular/router', '@angular/forms'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.nuvem = global.nuvem || {}, global.nuvem['angular-base'] = {}), global.ng.common.http, global.ng.core, global.rxjs.operators, global.rxjs, global.ng.common, global.ng.router, global.ng.forms));
}(this, (function (exports, i2, i0, operators, rxjs, common, router, forms) { 'use strict';

    /**
     * Class BlockUiService
     * @class
     */
    var BlockUiService = /** @class */ (function () {
        /**
         * constructor method
         * @constructor
         */
        function BlockUiService() {
            /**
             * subject property
             * @private
             * @type {Subject<BlockUiStatus>}
             */
            this.subject = new rxjs.Subject();
            /**
             * loaderStatus property
             * @public
             * @type {Observable}
             */
            this.loaderStatus = this.subject.asObservable();
        }
        /**
         * show methods
         * @returns void
         */
        BlockUiService.prototype.show = function () {
            this.subject.next({ status: true });
        };
        /**
         * hide methods
         * @returns void
         */
        BlockUiService.prototype.hide = function () {
            this.subject.next({ status: false });
        };
        return BlockUiService;
    }());
    BlockUiService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BlockUiService_Factory() { return new BlockUiService(); }, token: BlockUiService, providedIn: "root" });
    BlockUiService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    BlockUiService.ctorParameters = function () { return []; };

    /**
     * Class BlockUiInterceptor
     * @class
     */
    var BlockUiInterceptor = /** @class */ (function () {
        /**
         * constructor method
         * @constructor
         * @param {BlockUiService} service
         */
        function BlockUiInterceptor(service) {
            this.service = service;
        }
        /**
         * intercept method
         * @public
         * @param {HttpRequest<any>} req
         * @param {HttpHandler} next
         * @return Observable<HttpEvent<any>>
         */
        BlockUiInterceptor.prototype.intercept = function (req, next) {
            var _this = this;
            if (this.isMutation(req.method)) {
                this.service.show();
            }
            return next.handle(req).pipe(operators.tap(function (event) {
                if (event instanceof i2.HttpResponse) {
                    _this.service.hide();
                }
            }, function (err) {
                _this.service.hide();
            }));
        };
        /**
         * isMutation method
         * @private
         * @param {string} method
         * @return boolean
         */
        BlockUiInterceptor.prototype.isMutation = function (method) {
            var mutationsMethods = [
                'DELETE',
                'PATCH',
                'POST',
                'PUT'
            ];
            return mutationsMethods.indexOf(method) !== -1;
        };
        return BlockUiInterceptor;
    }());
    BlockUiInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function BlockUiInterceptor_Factory() { return new BlockUiInterceptor(i0.ɵɵinject(BlockUiService)); }, token: BlockUiInterceptor, providedIn: "root" });
    BlockUiInterceptor.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    BlockUiInterceptor.ctorParameters = function () { return [
        { type: BlockUiService }
    ]; };

    /**
     * Constante de configuração
     * @const
     */
    var VERSIONTAG_CONFIG = new i0.InjectionToken('versiontag.config');

    /**
     * Componente responsável por expor o seletor <app-version-tag></app-version-tag> para reuso
     * @class
     */
    var VersionTagComponent = /** @class */ (function () {
        function VersionTagComponent(config) {
            this.config = config;
        }
        /**
         * Metodo executado ao carregar o componente responsável por carregar o arquivo 'package.json'
         * @return void
         */
        VersionTagComponent.prototype.ngOnInit = function () {
            this.version = this.config.appVersion;
        };
        return VersionTagComponent;
    }());
    VersionTagComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'app-version-tag',
                    template: "<span style=\"margin-left: 5px;\">\n    Vers\u00E3o: {{version}}\n</span>"
                },] }
    ];
    VersionTagComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [VERSIONTAG_CONFIG,] }] }
    ]; };
    VersionTagComponent.propDecorators = {
        cssClass: [{ type: i0.Input }]
    };

    /**
     * O componente VersionTag exibe o atributo `version` do arquivo `package.json` do sistema,
     * com o intuito de informar o usuário a versão atual da aplicação. Inicialmente foi feito para
     * ser utilizado no rodapé das aplicações conforme o exemplo a seguir.
     * @module
     */
    var VersionTagModule = /** @class */ (function () {
        function VersionTagModule() {
        }
        /**
         * forRoot method
         * @public
         * @static
         * @returns ModuleWithProviders
         */
        VersionTagModule.forRoot = function (config) {
            return {
                ngModule: VersionTagModule,
                providers: [
                    { provide: VERSIONTAG_CONFIG, useValue: config },
                ]
            };
        };
        return VersionTagModule;
    }());
    VersionTagModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        router.RouterModule
                    ],
                    declarations: [
                        VersionTagComponent
                    ],
                    exports: [
                        VersionTagComponent
                    ]
                },] }
    ];

    /**
     * Classe abstrata para serviço de autenticação
     * @class
     */
    var Authentication = /** @class */ (function () {
        function Authentication() {
        }
        return Authentication;
    }());

    var LogoutDirective = /** @class */ (function () {
        function LogoutDirective(authenticationService) {
            this.authenticationService = authenticationService;
        }
        LogoutDirective.prototype.click = function () {
            this.authenticationService.logout();
        };
        return LogoutDirective;
    }());
    LogoutDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[logout]' },] }
    ];
    LogoutDirective.ctorParameters = function () { return [
        { type: Authentication }
    ]; };
    LogoutDirective.propDecorators = {
        click: [{ type: i0.HostListener, args: ['click',] }]
    };

    var UserDirective = /** @class */ (function () {
        function UserDirective(el, authenticationService) {
            this.el = el;
            this.authenticationService = authenticationService;
        }
        UserDirective.prototype.ngOnInit = function () {
            if (this.authenticationService.isAuthenticated()) {
                var user = this.authenticationService.getUser();
                this.el.nativeElement.innerHTML += this.user ? user[this.user] : user.name;
            }
        };
        return UserDirective;
    }());
    UserDirective.decorators = [
        { type: i0.Directive, args: [{ selector: '[user]' },] }
    ];
    UserDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: Authentication }
    ]; };
    UserDirective.propDecorators = {
        user: [{ type: i0.Input }]
    };

    /**
     * Componente de login que será chamado quando a aplicação for logada com sucesso.
     * Deverá ser criada uma rota para esse componente.
     * @class
     */
    var LoginSuccessComponent = /** @class */ (function () {
        function LoginSuccessComponent(authenticationService) {
            this.authenticationService = authenticationService;
        }
        LoginSuccessComponent.prototype.ngOnInit = function () {
            this.authenticationService.login();
        };
        return LoginSuccessComponent;
    }());
    LoginSuccessComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'app-login-success',
                    template: ''
                },] }
    ];
    LoginSuccessComponent.ctorParameters = function () { return [
        { type: Authentication }
    ]; };

    /**
     * Classe abstrata para serviço de autorização
     * @class
     */
    var Authorization = /** @class */ (function () {
        function Authorization() {
        }
        return Authorization;
    }());

    /**
     * HasRoleDirective diretiva para checagem da existência de permissões de acesso para o usuário logado.
     * @class
     */
    var HasRoleDirective = /** @class */ (function () {
        /**
         * Método construtor responsável por carregar o serviço de autorização e serviço de identificação de mudança
         * @param {TemplateRef<any>} templateRef
         * @param {ViewContainerRef} viewContainer
         * @param {Authorization} authorization
         * @param {Authentication<User>} authentication
         */
        function HasRoleDirective(templateRef, viewContainer, authorization, authentication) {
            this.templateRef = templateRef;
            this.viewContainer = viewContainer;
            this.authorization = authorization;
            this.authentication = authentication;
        }
        Object.defineProperty(HasRoleDirective.prototype, "hasRole", {
            /**
             * Propriedade para identificar regras de acesso aos itens
             * @type {string}
             */
            set: function (hasRole) {
                var _this = this;
                this.viewContainer.clear();
                if (hasRole) {
                    if (this.loginNotifications)
                        this.loginNotifications.unsubscribe();
                    this.loginNotifications = this.authentication.getLoginNotifications().subscribe(function () {
                        if (_this.authorization.hasRole(hasRole)) {
                            _this.viewContainer.clear();
                            _this.viewContainer.createEmbeddedView(_this.templateRef);
                        }
                    });
                }
                else {
                    this.viewContainer.createEmbeddedView(this.templateRef);
                }
            },
            enumerable: false,
            configurable: true
        });
        HasRoleDirective.prototype.ngOnDestroy = function () {
            if (this.loginNotifications) {
                this.loginNotifications.unsubscribe();
            }
        };
        return HasRoleDirective;
    }());
    HasRoleDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[hasRole]'
                },] }
    ];
    HasRoleDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef },
        { type: i0.ViewContainerRef },
        { type: Authorization },
        { type: Authentication }
    ]; };
    HasRoleDirective.propDecorators = {
        hasRole: [{ type: i0.Input }]
    };

    /**
     *
     * Componente HideWhileLoginComponent, utilizado para não apresentar a tela da aplicação enquanto a fase de login não terminou.
     *
     * @class
     */
    var HideWhileLoginComponent = /** @class */ (function () {
        /**
         * constructor method
         * @param {ElementRef} hostComponent
         * @param {AbstractAuthentication} auth
         * @param {BlockUiService} blockUiService
         * @constructor
         */
        function HideWhileLoginComponent(hostComponent, auth, blockUiService) {
            this.hostComponent = hostComponent;
            this.auth = auth;
            this.blockUiService = blockUiService;
            /**
             * Carrega conteúdo
             * @type {loadingString}
             */
            this.loadingContent = "";
            this.waitingLogin = false;
        }
        HideWhileLoginComponent.prototype.ngOnInit = function () {
            this.waitingLogin = !this.auth.isAuthenticated();
        };
        HideWhileLoginComponent.prototype.ngAfterContentInit = function () {
            if (!this.auth.isAuthenticated()) {
                this.blockUiService.show();
            }
        };
        HideWhileLoginComponent.prototype.ngAfterViewInit = function () {
            var _this = this;
            if (!this.auth.isAuthenticated()) {
                for (var i = 1; i < this.hostComponent.nativeElement.children.length; i++) {
                    this.hostComponent.nativeElement.children[i].style.display = 'none';
                }
            }
            this.loginNotifications = this.auth.getLoginNotifications().subscribe(function () {
                for (var i = 1; i < _this.hostComponent.nativeElement.children.length; i++) {
                    _this.hostComponent.nativeElement.children[i].style.display = 'inherit';
                }
                _this.waitingLogin = false;
                _this.blockUiService.hide();
            });
        };
        /**
         * ngOnDestroy method
         * @returns void
         */
        HideWhileLoginComponent.prototype.ngOnDestroy = function () {
            this.loginNotifications.unsubscribe();
        };
        return HideWhileLoginComponent;
    }());
    HideWhileLoginComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: '[hide-while-login]',
                    template: "<span *ngIf=\"waitingLogin\">{{ loadingContent }}</span>\n<ng-content></ng-content>"
                },] }
    ];
    HideWhileLoginComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: Authentication },
        { type: BlockUiService }
    ]; };
    HideWhileLoginComponent.propDecorators = {
        loadingContent: [{ type: i0.Input }]
    };

    /**
     * Constante de configuração
     * @const
     */
    var AUTH_CONFIG = new i0.InjectionToken('auth.config');

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    /**
     * Serviço de autorização
     * @class
     */
    var AuthorizationService = /** @class */ (function (_super) {
        __extends(AuthorizationService, _super);
        /**
         * Método construtor para a injeção do serviço de configuração AuthConfig
         * @constructor
         * @param {AuthConfig} config
         */
        function AuthorizationService(authenticationService) {
            var _this = _super.call(this) || this;
            _this.authenticationService = authenticationService;
            return _this;
        }
        /**
         * Método responsável por identificar as regras de acesso
         * @public
         * @param {any} role
         * @returns boolean
         */
        AuthorizationService.prototype.hasRole = function (role) {
            if (role) {
                var user = this.authenticationService.getUser();
                if (role instanceof Array) {
                    return user.roles.some(function (userRole) { return role.some(function (checkRole) { return userRole === checkRole; }); });
                }
                return user.roles.some(function (userRole) { return userRole === role; });
            }
            return true;
        };
        return AuthorizationService;
    }(Authorization));
    AuthorizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthorizationService_Factory() { return new AuthorizationService(i0.ɵɵinject(Authentication)); }, token: AuthorizationService, providedIn: "root" });
    AuthorizationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AuthorizationService.ctorParameters = function () { return [
        { type: Authentication }
    ]; };

    function isAuthenticated(config) {
        return null !== config.storage.getItem(config.userStorageIndex);
    }
    ;
    function redirect(config) {
        window.location.href = config.loginUrl;
        ;
    }
    ;
    /**
     * Serviço de autenticação
     * @class
     */
    var AuthenticationService = /** @class */ (function (_super) {
        __extends(AuthenticationService, _super);
        function AuthenticationService(config, http) {
            var _this = _super.call(this) || this;
            _this.config = config;
            _this.http = http;
            _this.loginNotifications = new rxjs.BehaviorSubject(_this.getUser());
            return _this;
        }
        /**
         * Método para verificar se o usuário esta autenticado na aplicação
         * @returns boolean
         * @public
         */
        AuthenticationService.prototype.isAuthenticated = function () {
            return isAuthenticated(this.config);
        };
        /**
         * Método responsável por realizar redirecionamentos
         * @returns void
         * @public
         */
        AuthenticationService.prototype.redirect = function () {
            redirect(this.config);
        };
        /**
         * Método responsável pelo login da aplicação
         * @public
         * @param {User} user
         * @returns Observable<any>
         */
        AuthenticationService.prototype.login = function () {
            var _this = this;
            this.getUserDetails()
                .subscribe(function (user) {
                _this.setUser(user);
                _this.loginNotifications.next(user);
            });
        };
        /**
         * Método responsável pelo logou da aplicação
         * @public
         * @returns void
         */
        AuthenticationService.prototype.logout = function () {
            this.loginNotifications.next(null);
            this.config.storage.removeItem(this.config.userStorageIndex);
            window.location.href = this.config.logoutUrl;
        };
        /**
         * Método responsável por obter os dados do usuário logado
         * @public
         * @returns Observable<any>
         */
        AuthenticationService.prototype.getUserDetails = function () {
            return this.http.get(this.config.baseUrl + this.config.detailsUrl);
        };
        AuthenticationService.prototype.setUser = function (user) {
            this.config.storage.setItem(this.config.userStorageIndex, JSON.stringify(user));
        };
        AuthenticationService.prototype.getUser = function () {
            return JSON.parse(this.config.storage.getItem(this.config.userStorageIndex));
        };
        AuthenticationService.prototype.getLoginNotifications = function () {
            return this.loginNotifications.pipe(operators.filter(function (value) { return value != null; }));
        };
        return AuthenticationService;
    }(Authentication));
    AuthenticationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthenticationService_Factory() { return new AuthenticationService(i0.ɵɵinject(AUTH_CONFIG), i0.ɵɵinject(i2.HttpClient)); }, token: AuthenticationService, providedIn: "root" });
    AuthenticationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AuthenticationService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [AUTH_CONFIG,] }] },
        { type: i2.HttpClient }
    ]; };

    /**
     * Provedor de error para criação de erros de notificação.
     * @class
     */
    var NotAuthenticatedErrorProvider = /** @class */ (function () {
        function NotAuthenticatedErrorProvider(authenticationService) {
            this.authenticationService = authenticationService;
        }
        /**
         * Método para identificar se o usuário está logado
         * @public
         * @param {HttpErrorResponse} error
         * @returns void
         */
        NotAuthenticatedErrorProvider.prototype.shouldHandle = function (error) {
            return error instanceof i2.HttpErrorResponse && error.status == 401;
        };
        /**
         * Método para redirecionar caso o usuário não esteja
         * @public
         * @param {HttpErrorResponse} error
         * @returns void
         */
        NotAuthenticatedErrorProvider.prototype.handle = function (error) {
            this.authenticationService.redirect();
        };
        return NotAuthenticatedErrorProvider;
    }());
    NotAuthenticatedErrorProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function NotAuthenticatedErrorProvider_Factory() { return new NotAuthenticatedErrorProvider(i0.ɵɵinject(Authentication)); }, token: NotAuthenticatedErrorProvider, providedIn: "root" });
    NotAuthenticatedErrorProvider.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    NotAuthenticatedErrorProvider.ctorParameters = function () { return [
        { type: Authentication }
    ]; };

    /**
     * Anstract class ErrorProvider
     * @class
     * @abstract
     */
    var ErrorProvider = /** @class */ (function () {
        function ErrorProvider() {
        }
        return ErrorProvider;
    }());

    /**
     * Classe abstrata para gerencia de tokens
     * @class
     */
    var Token = /** @class */ (function () {
        function Token() {
        }
        return Token;
    }());

    /**
     * Implementação de classe para interceptar e tratar requisições http/https
     * @class
     */
    var JWTAuthInterceptor = /** @class */ (function () {
        /**
         * Metodo construtor responsável por injetar serviço de autenticação
         * @constructor
         * @param {AbstractAuthentication} auth
         */
        function JWTAuthInterceptor(token) {
            this.token = token;
        }
        /**
         * Metodo responsável por interceptar requisições HTTP/HTTPS
         * @public
         * @param {HttpRequest<any>} request
         * @param {HttpHandler} next
         * @returns Observable<HttpEvent<any>>
         */
        JWTAuthInterceptor.prototype.intercept = function (request, next) {
            var _this = this;
            if (this.token.hasToken()) {
                request = this.token.setTokenInHeader(request);
            }
            return next.handle(request)
                .pipe(operators.tap(function (event) {
                if (event instanceof i2.HttpResponse) {
                    var token = _this.token.extractTokenFromHeaders(event.headers);
                    if (null !== token)
                        _this.token.storeToken(token);
                }
                return event;
            }));
        };
        return JWTAuthInterceptor;
    }());
    JWTAuthInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function JWTAuthInterceptor_Factory() { return new JWTAuthInterceptor(i0.ɵɵinject(Token)); }, token: JWTAuthInterceptor, providedIn: "root" });
    JWTAuthInterceptor.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    JWTAuthInterceptor.ctorParameters = function () { return [
        { type: Token }
    ]; };

    /**
     * Inplementação de serviço JWTTokenService
     * @class
     */
    var JWTTokenService = /** @class */ (function (_super) {
        __extends(JWTTokenService, _super);
        /**
         * Metodo construtor responsável por injetar as configurações de autenticação
         * @constructor
         * @param {AuthConfig} config
         */
        function JWTTokenService(config) {
            var _this = _super.call(this) || this;
            _this.config = config;
            return _this;
        }
        /**
         * Metodo responsável pela extração de tokes do heaedrs das requisições
         * @public
         * @param {HttpHeaders} headers
         * @returns string
         */
        JWTTokenService.prototype.extractTokenFromHeaders = function (headers) {
            return headers.get(JWTTokenService.HEADER_STRING);
        };
        /**
         * Metodo responsável pela adição dos tokens no storage
         * @public
         * @param {String} token
         * @returns void
         */
        JWTTokenService.prototype.storeToken = function (token) {
            this.config.storage.setItem(this.config.tokenStorageIndex, token.toString());
        };
        /**
         * Metodo responsável por injetar token no header das requisições
         * @public
         * @param {HttpRequest<any>} request
         * @returns HttpRequest<any>
         */
        JWTTokenService.prototype.setTokenInHeader = function (request) {
            var _a;
            var req = request.clone({
                headers: new i2.HttpHeaders((_a = {},
                    _a[JWTTokenService.HEADER_STRING] = this.config.storage.getItem(this.config.tokenStorageIndex),
                    _a))
            });
            return req;
        };
        /**
         * Metodo responsável por verificar a existencia de um token de autenticação
         * @returns boolean
         * @public
         */
        JWTTokenService.prototype.hasToken = function () {
            return null !== this.config.storage.getItem(this.config.tokenStorageIndex);
        };
        return JWTTokenService;
    }(Token));
    /**
     * TOKEN_PREFIX  property
     * @type {string}
     */
    JWTTokenService.TOKEN_PREFIX = "Bearer";
    /**
     * HEADER_STRING property
     * @type {string}
     */
    JWTTokenService.HEADER_STRING = "Authorization";
    JWTTokenService.ɵprov = i0.ɵɵdefineInjectable({ factory: function JWTTokenService_Factory() { return new JWTTokenService(i0.ɵɵinject(AUTH_CONFIG)); }, token: JWTTokenService, providedIn: "root" });
    JWTTokenService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    JWTTokenService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [AUTH_CONFIG,] }] }
    ]; };

    /**
     * O modulo de segurança contem funcionalidades para autenticação, autorização, redirecionamento
     * para login, gerenciamento de tokens JWT e obtenção e armazenamento de dados de usuário.
     * @class
     */
    var SecurityModule = /** @class */ (function () {
        function SecurityModule() {
        }
        /**
         * forRoot method
         * @public
         * @static
         * @returns ModuleWithProviders
         */
        SecurityModule.forRoot = function (config) {
            return {
                ngModule: SecurityModule,
                providers: [
                    { provide: AUTH_CONFIG, useValue: config },
                    config.tokenStorageIndex ?
                        [
                            { provide: Token, useClass: JWTTokenService },
                            { provide: i2.HTTP_INTERCEPTORS, useClass: JWTAuthInterceptor, multi: true }
                        ] : []
                ]
            };
        };
        return SecurityModule;
    }());
    SecurityModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        router.RouterModule,
                        i2.HttpClientModule
                    ],
                    declarations: [
                        LogoutDirective,
                        UserDirective,
                        LoginSuccessComponent,
                        HasRoleDirective,
                        HideWhileLoginComponent
                    ],
                    providers: [
                        AuthorizationService,
                        AuthenticationService,
                        { provide: ErrorProvider, useClass: NotAuthenticatedErrorProvider, multi: true },
                        { provide: Authorization, useClass: AuthorizationService },
                        { provide: Authentication, useClass: AuthenticationService }
                    ],
                    exports: [
                        LogoutDirective,
                        UserDirective,
                        LoginSuccessComponent,
                        HasRoleDirective,
                        HideWhileLoginComponent
                    ]
                },] }
    ];

    /**
     * Guard que verifica se usuário está autenticado antes do usuário acessar uma rota.
     * Se for verificar que o usuário não está autenticado, é feito um redirecionamento para o login.
     * @class
     */
    var AuthGuard = /** @class */ (function () {
        /**
         * Método construtor responsável pela injeção do serviço de autenticação
         * @constructor
         * @param {Authentication} auth
         */
        function AuthGuard(authenticationService) {
            this.authenticationService = authenticationService;
        }
        /**
         * Método responsável por identificar se o usuário está autenticado
         * @public
         * @param {ActivatedRouteSnapshot} route
         * @param {RouterStateSnapshot} state
         * @returns boolean
         */
        AuthGuard.prototype.canActivate = function (route, state) {
            if (this.authenticationService.isAuthenticated()) {
                return true;
            }
            this.authenticationService.redirect();
            return false;
        };
        /**
         * Método responsável por atuar somente em rotas filhas de modo independente
         * @public
         * @param {ActivatedRouteSnapshot} route
         * @param {RouterStateSnapshot} state
         * @returns boolean
         */
        AuthGuard.prototype.canActivateChild = function (route, state) {
            return this.canActivate(route, state);
        };
        return AuthGuard;
    }());
    AuthGuard.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(i0.ɵɵinject(Authentication)); }, token: AuthGuard, providedIn: "root" });
    AuthGuard.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AuthGuard.ctorParameters = function () { return [
        { type: Authentication }
    ]; };

    function bootstrapSecurity(config, authenticated, isAuthenticated$1, notAuthenticated) {
        if (isAuthenticated$1 === void 0) { isAuthenticated$1 = isAuthenticated; }
        if (notAuthenticated === void 0) { notAuthenticated = redirect; }
        if (window.location.href.includes(config.loginSuccessRoute) || isAuthenticated$1(config)) {
            authenticated();
        }
        else {
            notAuthenticated(config);
        }
    }

    /**
     * AccessbilityService Serviço de acessibilidade, este serviço prove recursos de contraste
     * de tela e controle do tamanho da fonte apresentadas na tela.
     * @class
     */
    var AccessbilityService = /** @class */ (function () {
        function AccessbilityService(rendererFactory) {
            /**
             * Propriedade que define tamanho da fonte
             * @type {number}
             */
            this.fontSize = 1.0;
            this.renderer = rendererFactory.createRenderer(null, null);
        }
        /**
         * Medoto para habilitar contraste
         * @public
         * @returns void
         */
        AccessbilityService.prototype.enableHighContrast = function () {
            this.renderer.addClass(document.body, 'contraste');
        };
        /**
         * Metodo para desabilitar contraste
         * @public
         * @returns void
         */
        AccessbilityService.prototype.disableHighContrast = function () {
            this.renderer.removeClass(document.body, 'contraste');
        };
        /**
         * Metodo utilizado para aumentar o tamnho da fonte apresentada no display
         * @public
         * @returns void
         */
        AccessbilityService.prototype.increaseFontSize = function () {
            this.fontSize += 0.1;
            this.renderer.setStyle(document.querySelector('div.layout-wrapper'), 'font-size', this.fontSize + 'em');
        };
        /**
         * Metodo utilizado para diminuir o tamnho da fonte apresentada no display
         * @public
         * @returns void
         */
        AccessbilityService.prototype.decreaseFontSize = function () {
            this.fontSize -= 0.1;
            this.renderer.setStyle(document.querySelector('div.layout-wrapper'), 'font-size', this.fontSize + 'em');
        };
        AccessbilityService.prototype.addAccessibilityIcons = function () {
            var elements = document.querySelector('.p-button-icon-left, p-button-icon-righ');
            if (elements) {
                this.renderer.setStyle(elements, 'aria-hidden', true);
            }
        };
        AccessbilityService.prototype.addAccessibilityMessages = function (msg) {
            var type = 'polite';
            if (msg.severity.toLowerCase() !== 'custom' && msg.severity.toLowerCase() !== 'success') {
                type = 'assertive';
            }
            this.renderer.setStyle(document.querySelector('p-toast, p-growl'), 'aria-live', type);
        };
        return AccessbilityService;
    }());
    AccessbilityService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AccessbilityService_Factory() { return new AccessbilityService(i0.ɵɵinject(i0.RendererFactory2)); }, token: AccessbilityService, providedIn: "root" });
    AccessbilityService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    AccessbilityService.ctorParameters = function () { return [
        { type: i0.RendererFactory2 }
    ]; };

    /**
     * AccessbilityModule expõe o serviço AccessbilityService para o uso de outras aplicações
     * @module
     */
    var AccessbilityModule = /** @class */ (function () {
        function AccessbilityModule() {
        }
        return AccessbilityModule;
    }());
    AccessbilityModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [common.CommonModule],
                    providers: [AccessbilityService],
                    exports: []
                },] }
    ];

    /**
     *
     * Class CommonMaskService serviço para inserção de mascara de data em campos input
     * @class
     */
    var CommonMaskService = /** @class */ (function () {
        function CommonMaskService() {
            /**
             * DATE_SEPARATOR property
             * @type {string}
             */
            this.DATE_SEPARATOR = '/';
        }
        /**
         * Metodo para formatar valor digitado no padrão dd/mm/yyyy
         * @param $event
         * @returns void
         */
        CommonMaskService.prototype.dateMask = function ($event) {
            if ($event.target.value) {
                var date = $event.target.value.replace(/[^0-9]/g, '').substr(0, 8);
                if (date.length >= 3) {
                    date = date.replace(/^(\d{2})(\d{1,2})/, '$1' + this.DATE_SEPARATOR + '$2');
                }
                if (date.length >= 6) {
                    date = date.replace(/^(\S{5})(\d{1,4})/, '$1' + this.DATE_SEPARATOR + '$2');
                }
                $event.target.value = date;
            }
        };
        return CommonMaskService;
    }());
    CommonMaskService.ɵprov = i0.ɵɵdefineInjectable({ factory: function CommonMaskService_Factory() { return new CommonMaskService(); }, token: CommonMaskService, providedIn: "root" });
    CommonMaskService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * CommonMaskModule expõe o servico CommonMaskService para o uso de outras aplicações
     * @class
     */
    var CommonMaskModule = /** @class */ (function () {
        function CommonMaskModule() {
        }
        return CommonMaskModule;
    }());
    CommonMaskModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    declarations: [],
                    providers: [
                        CommonMaskService
                    ],
                    exports: []
                },] }
    ];

    /**
     * Class ErrorService
     * @class
     */
    var ErrorService = /** @class */ (function (_super) {
        __extends(ErrorService, _super);
        /**
         * Metodo construtor responável por injetar o serviço ErrorProvider
         * @param {ErrorProvider} providers
         */
        function ErrorService(providers) {
            var _this = _super.call(this) || this;
            _this.providers = providers;
            return _this;
        }
        /**
         * Metodo responsável por idetificar e obter os erros lançados de requisições http/https
         * @param {Error} error
         * @returns void
         */
        ErrorService.prototype.handleError = function (error) {
            try {
                this.providers.forEach(function (p) {
                    if (p.shouldHandle(error)) {
                        p.handle(error);
                    }
                });
            }
            catch (e) {
            }
            _super.prototype.handleError.call(this, error);
        };
        return ErrorService;
    }(i0.ErrorHandler));
    ErrorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorService_Factory() { return new ErrorService(i0.ɵɵinject(ErrorProvider)); }, token: ErrorService, providedIn: "root" });
    ErrorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ErrorService.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: i0.Inject, args: [ErrorProvider,] }] }
    ]; };

    /**
     * Abstract provider NotificationProvider
     * @abstract
     * @class
     */
    var NotificationProvider = /** @class */ (function () {
        function NotificationProvider() {
        }
        return NotificationProvider;
    }());

    /**
     * Classe modelo ApplicationProblemType
     * @class
     */
    var ApplicationProblemType = /** @class */ (function () {
        /**
         * constructor method
         * @param {string} type
         * @param {string} title
         * @param {string} detail
         * @param {Number} status
         * @param {string} instance
         * @param {Array<string>} stacktrace
         * @param {ApplicationProblemType} cause
         * @constructor
         */
        function ApplicationProblemType(type, title, detail, status, instance, stacktrace, cause) {
            this.type = type;
            this.title = title;
            this.detail = detail;
            this.status = status;
            this.instance = instance;
            this.stacktrace = stacktrace;
            this.cause = cause;
        }
        return ApplicationProblemType;
    }());

    /**
     * Serviço HttpApplicationProblemErrorService
     * @class
     */
    var HttpApplicationProblemErrorService = /** @class */ (function () {
        /**
         * Metodo construtor responsável por injetar serviço NotificationProvider
         * @param {NotificationProvider} notification
         * @constructor
         */
        function HttpApplicationProblemErrorService(notification, ngZone) {
            this.notification = notification;
            this.ngZone = ngZone;
        }
        /**
         * Metodo responsável pela identificação de erros
         * @public
         * @param {Error | HttpErrorResponse} error
         * @returns Boolean
         */
        HttpApplicationProblemErrorService.prototype.shouldHandle = function (error) {
            return error instanceof i2.HttpErrorResponse &&
                error.headers.get('Content-Type') === 'application/problem+json' &&
                error.error;
        };
        /**
         * Metodo pela adição de erros
         * @public
         * @param {HttpErrorResponse} error
         * @returns void
         */
        HttpApplicationProblemErrorService.prototype.handle = function (error) {
            var _this = this;
            this.ngZone.run(function () {
                _this.notification.addErrorProblem(new ApplicationProblemType(error.error.type, error.error.title, error.error.detail, error.error.status, error.error.instance));
            });
        };
        return HttpApplicationProblemErrorService;
    }());
    HttpApplicationProblemErrorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpApplicationProblemErrorService_Factory() { return new HttpApplicationProblemErrorService(i0.ɵɵinject(NotificationProvider), i0.ɵɵinject(i0.NgZone)); }, token: HttpApplicationProblemErrorService, providedIn: "root" });
    HttpApplicationProblemErrorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    HttpApplicationProblemErrorService.ctorParameters = function () { return [
        { type: NotificationProvider },
        { type: i0.NgZone }
    ]; };

    /**
     * Classe modelo HttpGenericErrorType
     * @class
     */
    var HttpGenericErrorType = /** @class */ (function () {
        /**
         * constructor method
         * @param {Number} code
         * @param {string} title
         * @param {string} detail
         * @constructor
         */
        function HttpGenericErrorType(code, title, detail) {
            this.code = code;
            this.title = title;
            this.detail = detail;
        }
        return HttpGenericErrorType;
    }());

    /**
     * Serviço HttpGenericErrorService
     * @class
     */
    var HttpGenericErrorService = /** @class */ (function () {
        /**
         * Metodo construtor responsávelpor injetar o serviço NotificationProvider
         * @param {NotificationProvider} notification
         * @constructor
         */
        function HttpGenericErrorService(notification, ngZone) {
            this.notification = notification;
            this.ngZone = ngZone;
        }
        /**
         * Metodo responsável pela identificação de erros
         * @public
         * @param {Error | HttpErrorResponse} error
         * @returns Boolean
         */
        HttpGenericErrorService.prototype.shouldHandle = function (error) {
            return error instanceof i2.HttpErrorResponse &&
                !(error.headers.get('Content-Type') === 'application/problem+json' &&
                    error.error);
        };
        /**
         * Metodo pela adição de erros
         * @public
         * @param {HttpErrorResponse} error
         * @returns void
         */
        HttpGenericErrorService.prototype.handle = function (error) {
            var _this = this;
            var generic = this.getErrorByCode(error);
            this.ngZone.run(function () {
                _this.notification.addErrorMessage(generic.detail, generic.title);
            });
        };
        /**
         * Metodo para obter erros a partir de um código
         * @public
         * @param {HttpErrorResponse} error
         * @returns HttpGenericErrorType
         */
        HttpGenericErrorService.prototype.getErrorByCode = function (error) {
            var generic = GENERIC_ERRORS[error.status];
            if (generic === undefined) {
                return new HttpGenericErrorType(error.status, error.statusText, error.message);
            }
            return generic;
        };
        return HttpGenericErrorService;
    }());
    HttpGenericErrorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function HttpGenericErrorService_Factory() { return new HttpGenericErrorService(i0.ɵɵinject(NotificationProvider), i0.ɵɵinject(i0.NgZone)); }, token: HttpGenericErrorService, providedIn: "root" });
    HttpGenericErrorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    HttpGenericErrorService.ctorParameters = function () { return [
        { type: NotificationProvider },
        { type: i0.NgZone }
    ]; };
    /**
     * Constante que define tipos de erros básicos
     * @const GENERIC_ERRORS
     */
    var GENERIC_ERRORS = {
        401: new HttpGenericErrorType(401, 'Não Autenticado', 'Essa requisição requer um usuário autenticado.'),
        403: new HttpGenericErrorType(403, 'Proibido', 'Essa requisição requer uma permissão no servidor da aplicação que o usuário não possui.'),
        404: new HttpGenericErrorType(404, 'Não encontrado', 'Essa requisição não pode ser encontrada.'),
        500: new HttpGenericErrorType(500, 'Erro desconhecido', 'O servidor encontrou uma condição inesperada.'),
        502: new HttpGenericErrorType(502, 'Bad Gateway', 'O servidor recebeu uma resposta inválida de um serviço que utilizou para cumprir a requisição'),
        503: new HttpGenericErrorType(503, 'Serviço Indisponível', 'O servidor não pode atender a requisição nesse momento. Esta é uma condição temporária, tente novamente mais tarde'),
        504: new HttpGenericErrorType(504, 'Gateway Timeout', 'O servidor não conseguiu receber uma resposta a tempo esperado por um serviço que utilizou para cumprir a requisição')
    };

    /**
     * O modulo ErrorModule contem funcionalidades para a captura e apresentação dos erros que possam ocorrer na aplicação.
     * @module
     */
    var ErrorModule = /** @class */ (function () {
        function ErrorModule() {
        }
        return ErrorModule;
    }());
    ErrorModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: [],
                    imports: [
                        common.CommonModule
                    ],
                    providers: [
                        {
                            provide: ErrorProvider,
                            useClass: HttpGenericErrorService,
                            multi: true
                        },
                        {
                            provide: ErrorProvider,
                            useClass: HttpApplicationProblemErrorService,
                            multi: true
                        },
                        {
                            provide: i0.ErrorHandler,
                            useClass: ErrorService,
                        },
                    ]
                },] }
    ];

    /**
     * Class NotificationService
     * @class
     */
    var NotificationService = /** @class */ (function (_super) {
        __extends(NotificationService, _super);
        function NotificationService() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Metodo responsável po adicionar mensagem de erro
         * @param {string} message
         * @param {string} title
         * @returns void
         */
        NotificationService.prototype.addErrorMessage = function (message, title) {
            console.error(title + ' ' + message);
        };
        /**
         * Metodo responsável por adicionar o detalhamento do erro no console
         * @param {ApplicationProblemType} problem
         * @returns void
         */
        NotificationService.prototype.addErrorProblem = function (problem) {
            console.error(problem.title + ' ' + problem.detail);
        };
        return NotificationService;
    }(NotificationProvider));
    NotificationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NotificationService_Factory() { return new NotificationService(); }, token: NotificationService, providedIn: "root" });
    NotificationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Serviço de erros ErrorStackService
     * @class
     */
    var ErrorStackService = /** @class */ (function () {
        /**
         * metodo construtor injeta serviço generico de erros
         * @param {HttpGenericErrorService} genericErrorService
         * @constructor
         */
        function ErrorStackService(genericErrorService) {
            var _this = this;
            this.genericErrorService = genericErrorService;
            /**
             * Propriedade errors
             * @type {ReplaySubject<NamedErrorType>}
             */
            this.errors = new rxjs.ReplaySubject();
            if (null === localStorage.getItem('errorStack')) {
                localStorage.setItem('errorStack', JSON.stringify([]));
            }
            this.getErrorsSubjects().forEach(function (error) {
                _this.errors.next(error);
            });
        }
        /**
         * Metodo responsável por criar erro do tipo HttpResponse
         * @param {HttpErrorResponse} error
         * @returns void
         */
        ErrorStackService.prototype.create = function (error) {
            var namedError = this.createNamedError(error);
            var persistedErrors = this.getErrorsSubjects();
            if (persistedErrors.length >= 15) {
                persistedErrors.shift();
            }
            persistedErrors.push(namedError);
            localStorage.setItem('errorStack', JSON.stringify(persistedErrors));
            this.errors.next(namedError);
        };
        /**
         * Metodo responsável por obter o conteúdo dos erros emitidos
         * @private
         * @returns NamedErrorType[]
         */
        ErrorStackService.prototype.getErrorsSubjects = function () {
            return JSON.parse(localStorage.getItem('errorStack'));
        };
        /**
         * Metodo responsável por itentifica o tipo de erro lançado
         * @private
         * @param {HttpErrorResponse} error
         * @returns NamedErrorType
         */
        ErrorStackService.prototype.createNamedError = function (error) {
            var fullMessage;
            var namedError;
            var createdAt = new Date();
            var errorId = this.getErrorId(error);
            var title;
            if (error.headers.get('Content-Type') === 'application/problem+json') {
                fullMessage = "X-Correlation-ID: " + errorId + "\n                           createdAt: " + createdAt + "\n                           status: " + error.status + "\n                           url: " + error.url + "\n                           body: " + error.error.detail + "\n                           stacktrace: " + error.error.stacktrace + "\n                           cause: " + error.error.cause;
                title = error.error.title;
            }
            else {
                var genericError = this.genericErrorService.getErrorByCode(error);
                fullMessage = "X-Correlation-ID: " + errorId + "\n                           createdAt: " + createdAt + "\n                           status: " + error.status + "\n                           url: " + error.url + "\n                           body: " + genericError.detail;
                title = genericError.title;
            }
            namedError = {
                message: title,
                createdAt: createdAt,
                correlationId: errorId,
                fullMessage: fullMessage
            };
            return namedError;
        };
        /**
         * Metodo responsável por obter o identificador do erro
         * @private
         * @param {HttpErrorResponse} error
         * @returns string
         */
        ErrorStackService.prototype.getErrorId = function (error) {
            var errorKey;
            error.headers.keys().every(function (key) {
                if (key.toUpperCase() === 'X-CORRELATION-ID') {
                    errorKey = key;
                    return false;
                }
                return true;
            });
            return errorKey ? error.headers.get(errorKey) : null;
        };
        return ErrorStackService;
    }());
    ErrorStackService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorStackService_Factory() { return new ErrorStackService(i0.ɵɵinject(HttpGenericErrorService)); }, token: ErrorStackService, providedIn: "root" });
    ErrorStackService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ErrorStackService.ctorParameters = function () { return [
        { type: HttpGenericErrorService }
    ]; };

    /**
     * Class ErrorStackProviderService
     * @class
     */
    var ErrorStackProviderService = /** @class */ (function () {
        /**
         * Metodo construtor responsável por injetar o serviso de erros
         * @param {ErrorStackService} errorStackService
         */
        function ErrorStackProviderService(errorStackService) {
            this.errorStackService = errorStackService;
        }
        /**
         * Metodo responsável pela identificação de erros
         * @param {Error} error
         * @returns Boolean
         */
        ErrorStackProviderService.prototype.shouldHandle = function (error) {
            return error instanceof i2.HttpErrorResponse;
        };
        /**
         * Metodo pela adição de erros
         * @param {HttpErrorResponse} error
         * @returns void
         */
        ErrorStackProviderService.prototype.handle = function (error) {
            this.errorStackService.create(error);
        };
        return ErrorStackProviderService;
    }());
    ErrorStackProviderService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ErrorStackProviderService_Factory() { return new ErrorStackProviderService(i0.ɵɵinject(ErrorStackService)); }, token: ErrorStackProviderService, providedIn: "root" });
    ErrorStackProviderService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    ErrorStackProviderService.ctorParameters = function () { return [
        { type: ErrorStackService }
    ]; };

    /**
     *
     * Cria PIPE de CEP para valores.
     *
     * Usage:
     * {{ value | cep }}
    */
    var CepPipe = /** @class */ (function () {
        function CepPipe() {
        }
        CepPipe.prototype.transform = function (value) {
            if (value === null) {
                return '-';
            }
            else {
                value = value.replace(/[^0-9A-Za-z]/g, '');
                return value.substring(0, 5) + '-' + value.substring(5, 8);
            }
        };
        return CepPipe;
    }());
    CepPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'cep'
                },] }
    ];

    /**
     *
     * Cria PIPE de CPF para valores.
     *
     * Usage:
     * {{ value | cpf }}
    */
    var CpfPipe = /** @class */ (function () {
        function CpfPipe() {
        }
        CpfPipe.prototype.transform = function (value) {
            if (value === null || value.length !== 11) {
                return value;
            }
            else {
                value = value.replace(/[^0-9A-Za-z]/g, '');
                return value.substring(0, 3) + '.' +
                    value.substring(3, 6) + '.' +
                    value.substring(6, 9) + '-' +
                    value.substring(9, 11);
            }
        };
        return CpfPipe;
    }());
    CpfPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'cpf'
                },] }
    ];

    /**
     *
     * Cria PIPE de CNPJ para valores.
     *
     * Usage:
     * {{ value | cnpj }}
    */
    var CnpjPipe = /** @class */ (function () {
        function CnpjPipe() {
        }
        CnpjPipe.prototype.transform = function (value) {
            if (value === null || value.length !== 14) {
                return value;
            }
            else {
                value = value.replace(/[^0-9A-Za-z]/g, '');
                return value.substring(0, 2) + '.' +
                    value.substring(2, 5) + '.' +
                    value.substring(5, 8) + '/' +
                    value.substring(8, 12) + '-' +
                    value.substring(12, 14);
            }
        };
        return CnpjPipe;
    }());
    CnpjPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'cnpj'
                },] }
    ];

    /**
     *
     * Cria PIPE de valores com regra definida em expressão regex
     * Usage:
     * {{ value | regex:arg1:arg2 }}
    */
    var RegexPipe = /** @class */ (function () {
        function RegexPipe() {
        }
        RegexPipe.prototype.transform = function (value, regex, regexPrint) {
            return value.replace(regex, regexPrint);
        };
        return RegexPipe;
    }());
    RegexPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'regex'
                },] }
    ];

    /**
     *
     * Cria PIPE para valores com restrição de valores a serem apresentados.
     *
     * Usage:
     * {{ value | limit:20 }}
     * {{ value | limit:20:"..." }}
    */
    var LimitPipe = /** @class */ (function () {
        function LimitPipe() {
        }
        LimitPipe.prototype.transform = function (value, limit, ellipsis) {
            if (limit === void 0) { limit = 25; }
            if (ellipsis === void 0) { ellipsis = '...'; }
            return value.length > limit
                ? "" + value.substr(0, limit) + ellipsis
                : value;
        };
        return LimitPipe;
    }());
    LimitPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'limit'
                },] }
    ];

    /**
     *
     *  Export do módulo
     */
    var PipeModule = /** @class */ (function () {
        function PipeModule() {
        }
        return PipeModule;
    }());
    PipeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    declarations: [
                        CepPipe,
                        CpfPipe,
                        CnpjPipe,
                        RegexPipe,
                        LimitPipe,
                    ],
                    exports: [
                        CepPipe,
                        CpfPipe,
                        CnpjPipe,
                        RegexPipe,
                        LimitPipe,
                    ]
                },] }
    ];

    /**
     * Fornece metodo para copia de textos
     * @class
     */
    var ClipboardService = /** @class */ (function () {
        function ClipboardService() {
        }
        /**
         * Inspirado no clipboard.js, copia texto selecionado para área de trasferência
         * @param {string} text
         * @returns void
         * @public
         */
        ClipboardService.prototype.copy = function (text) {
            var isRTL = document.documentElement.getAttribute('dir') === 'rtl';
            // cria um elemento temporário, seta o foco, copia e remove em seguida
            var fake = document.createElement('textarea');
            fake.style.fontSize = '12pt';
            fake.style.border = '0';
            fake.style.padding = '0';
            fake.style.margin = '0';
            fake.style.position = 'absolute';
            fake.style[isRTL ? 'right' : 'left'] = '-9999px';
            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
            fake.style.top = yPosition + "px";
            fake.setAttribute('readonly', '');
            fake.value = text;
            document.body.appendChild(fake);
            fake.select();
            document.execCommand('copy');
            document.body.removeChild(fake);
        };
        return ClipboardService;
    }());
    ClipboardService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ClipboardService_Factory() { return new ClipboardService(); }, token: ClipboardService, providedIn: "root" });
    ClipboardService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Diretiva que expõe seletor para o uso do clipbord
     * @class
     */
    var ClipboardDirective = /** @class */ (function () {
        /**
         * constructor method
         * @param {ClipboardService} service
         * @constructor
         */
        function ClipboardDirective(service) {
            this.service = service;
            /**
             * onClipboard variable
             * @type {EventEmitter<boolean>}
             */
            this.onClipboard = new i0.EventEmitter();
        }
        /**
         * copy method
         * @event click
         * @returns void
         */
        ClipboardDirective.prototype.copy = function () {
            try {
                this.service.copy(this.clipboard);
                this.onClipboard.emit(true);
            }
            catch (e) {
                this.onClipboard.emit(false);
                throw e;
            }
        };
        return ClipboardDirective;
    }());
    ClipboardDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[clipboard]'
                },] }
    ];
    ClipboardDirective.ctorParameters = function () { return [
        { type: ClipboardService }
    ]; };
    ClipboardDirective.propDecorators = {
        clipboard: [{ type: i0.Input }],
        onClipboard: [{ type: i0.Output }],
        copy: [{ type: i0.HostListener, args: ['click',] }]
    };

    /**
     * ClipboardModule expõe o servico ClipboardService para o uso de outras aplicações
     * @module
     */
    var ClipboardModule = /** @class */ (function () {
        function ClipboardModule() {
        }
        return ClipboardModule;
    }());
    ClipboardModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [],
                    declarations: [
                        ClipboardDirective,
                    ],
                    providers: [
                        ClipboardService
                    ],
                    exports: [
                        ClipboardDirective,
                    ]
                },] }
    ];

    /**
     *
     * UnmaskDirective diretiva para remoção de mascaras de valores numericos
     * @class
     */
    var UnmaskDirective = /** @class */ (function () {
        /**
         * constructor method
         * @param {ElementRef} elementRef
         * @param {NgControl} model
         * @constructor
         */
        function UnmaskDirective(elementRef, model) {
            this.elementRef = elementRef;
            this.model = model;
        }
        /**
         * Metodo executado no carregamento da diretiva, executa verificação do valor e remove as mascaras baseado em um aexpressão regular
         * @returns void
         */
        UnmaskDirective.prototype.ngOnInit = function () {
            var _this = this;
            this.subscriber = this.model.control.valueChanges.subscribe(function () {
                var newValue = _this.elementRef.nativeElement.value.replace(new RegExp(_this.appUnmask), '');
                _this.model.control.setValue(newValue, {
                    emitEvent: false,
                    emitModelToViewChange: false,
                    emitViewToModelChange: false
                });
            });
        };
        /**
         * ngOnDestroy method
         * @returns void
         */
        UnmaskDirective.prototype.ngOnDestroy = function () {
            this.subscriber.unsubscribe();
        };
        return UnmaskDirective;
    }());
    UnmaskDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[unmask]'
                },] }
    ];
    UnmaskDirective.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: forms.NgControl }
    ]; };
    UnmaskDirective.propDecorators = {
        appUnmask: [{ type: i0.Input }]
    };

    /**
     * OnlyNumbersDirective diretiva para que sejam permitidos somente números
     * @class
     */
    var OnlyNumbersDirective = /** @class */ (function () {
        /**
         * @param {ElementRef} el
         * @constructor
         */
        function OnlyNumbersDirective(el) {
            this.el = el;
            /**
             * Propriedade que carrega expressão regular para numeros
             * @type {RegExp}
             */
            this.regex = new RegExp(/[^0-9]$/g);
            /**
             * Propriedade que lista opções aceitas além de núsmeros
             * @type {Array<string>}
             */
            this.specialKeys = [
                'Backspace',
                'Delete',
                'Tab',
                'End',
                'Home',
                'ArrowLeft',
                'ArrowRight'
            ];
        }
        /**
         * Metodo executado para os evento KeyDown do teclado executa verificação do valor digitado
         * @param {KeyboardEvent} event
         * @returns void
         */
        OnlyNumbersDirective.prototype.onKeyDown = function (event) {
            var current = this.el.nativeElement.value;
            var next = current.concat(event.key);
            if (this.specialKeys.indexOf(event.key) !== -1) {
                return;
            }
            if (next && String(next).match(this.regex)) {
                event.preventDefault();
            }
        };
        return OnlyNumbersDirective;
    }());
    OnlyNumbersDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'input[onlyNumbers]'
                },] }
    ];
    OnlyNumbersDirective.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    OnlyNumbersDirective.propDecorators = {
        onKeyDown: [{ type: i0.HostListener, args: ['keydown', ['$event'],] }]
    };

    /**
     * DIRECTIVES constant
     * @constant
     */
    var DIRECTIVES = [
        OnlyNumbersDirective,
        UnmaskDirective
    ];
    /**
     * Expõe directivas para reuso em outras palicações
     * @module
     */
    var DirectivesModule = /** @class */ (function () {
        function DirectivesModule() {
        }
        return DirectivesModule;
    }());
    DirectivesModule.decorators = [
        { type: i0.NgModule, args: [{
                    declarations: DIRECTIVES,
                    exports: DIRECTIVES
                },] }
    ];

    (function (FormNotificationType) {
        FormNotificationType[FormNotificationType["CLEAN"] = 0] = "CLEAN";
        FormNotificationType[FormNotificationType["FIELD"] = 1] = "FIELD";
    })(exports.FormNotificationType || (exports.FormNotificationType = {}));
    /**
     * Class modelo para validação de formulários
     * @class
     */
    var FormNotification = /** @class */ (function () {
        /**
         * Metodo construtor para validação de formulários
         * @param {string} form
         * @param {FormNotificationType} type
         */
        function FormNotification(form, type) {
            this.form = form;
            this.type = type;
        }
        return FormNotification;
    }());

    /**
     * Class modelo para validação de campos de formulários
     * @class
     */
    var FieldFormNotification = /** @class */ (function (_super) {
        __extends(FieldFormNotification, _super);
        /**
         * Método construtor para validação de campos de formulários
         * @param {string} form
         * @param {string} field
         * @param {string} message
         */
        function FieldFormNotification(form, field, message) {
            var _this = _super.call(this, form, exports.FormNotificationType.FIELD) || this;
            _this.field = field;
            _this.message = message;
            return _this;
        }
        return FieldFormNotification;
    }(FormNotification));

    /**
     * Serviço ṕara tratar notificações em formulários
     * @class
     */
    var FormNotificationService = /** @class */ (function () {
        function FormNotificationService() {
            /**
             * @type {Subject<FormNotification>()}
             */
            this.formNotifications = new rxjs.Subject();
        }
        /**
         * Método para criação de inscrição de campos presentes nos formulários
         * @param {string} field
         * @returns Observable<ResponseHandle>
         */
        FormNotificationService.prototype.notifications = function (form, field) {
            return this.formNotifications.pipe(operators.filter(function (violation) {
                return (!form || violation.form === form) && (violation.type === exports.FormNotificationType.CLEAN || (violation instanceof FieldFormNotification &&
                    violation.field === field));
            }));
        };
        FormNotificationService.prototype.notify = function (notification) {
            this.formNotifications.next(notification);
        };
        return FormNotificationService;
    }());
    FormNotificationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function FormNotificationService_Factory() { return new FormNotificationService(); }, token: FormNotificationService, providedIn: "root" });
    FormNotificationService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];

    /**
     * Provedor de error para criação de erros de notificação.
     * @class
     */
    var FormNotificationErrorProvider = /** @class */ (function () {
        /**
         * Método construtor
         * @param {FormtNotificationService} formNotificationService
         * @constructor
         */
        function FormNotificationErrorProvider(formNotificationService) {
            this.formNotificationService = formNotificationService;
        }
        /**
         * Método responsável pela identificação de erros
         * @public
         * @param {Error | HttpErrorResponse} error
         * @returns Boolean
         */
        FormNotificationErrorProvider.prototype.shouldHandle = function (error) {
            return error instanceof i2.HttpErrorResponse &&
                error.headers.get('Content-Type') === 'application/problem+json' &&
                error.error && (error.error.violations || error.error.fieldErrors);
        };
        /**
         * Método para emissão de erros
         * @public
         * @param {HttpErrorResponse} error
         * @returns void
         */
        FormNotificationErrorProvider.prototype.handle = function (error) {
            if (error.error.violations) {
                this.violation(error.url, error.error.violations);
            }
            if (error.error.fieldErrors) {
                this.violation(error.url, error.error.fieldErrors);
            }
        };
        /**
         * Método iteração de violações e emissão de erros
         * @param values
         */
        FormNotificationErrorProvider.prototype.violation = function (form, values) {
            var _this = this;
            values.forEach(function (violation) { return _this.formNotificationService.notify(new FieldFormNotification(form, violation.field, violation.message)); });
        };
        return FormNotificationErrorProvider;
    }());
    FormNotificationErrorProvider.ɵprov = i0.ɵɵdefineInjectable({ factory: function FormNotificationErrorProvider_Factory() { return new FormNotificationErrorProvider(i0.ɵɵinject(FormNotificationService)); }, token: FormNotificationErrorProvider, providedIn: "root" });
    FormNotificationErrorProvider.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    FormNotificationErrorProvider.ctorParameters = function () { return [
        { type: FormNotificationService }
    ]; };

    /**
     * Class modelo para limpeza de validação de formulários
     * @class
     */
    var CleanFormNotification = /** @class */ (function (_super) {
        __extends(CleanFormNotification, _super);
        /**
         * Método construtor para limpeza de validação de formulários
         * @param {string} form
         */
        function CleanFormNotification(form) {
            return _super.call(this, form, exports.FormNotificationType.CLEAN) || this;
        }
        return CleanFormNotification;
    }(FormNotification));

    /**
     * Implementação de classe para interceptar e tratar requisições http/https
     * @class
     */
    var FormNotificationInterceptor = /** @class */ (function () {
        /**
         * Método construtor
         * @constructor
         * @param {AbstractAuthentication} auth
         */
        function FormNotificationInterceptor(formNotificationService) {
            this.formNotificationService = formNotificationService;
        }
        /**
         * Método responsável por interceptar requisições HTTP/HTTPS
         * @public
         * @param {HttpRequest<any>} request
         * @param {HttpHandler} next
         * @returns Observable<HttpEvent<any>>
         */
        FormNotificationInterceptor.prototype.intercept = function (request, next) {
            this.formNotificationService
                .notify(new CleanFormNotification(request.url));
            return next.handle(request);
        };
        return FormNotificationInterceptor;
    }());
    FormNotificationInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function FormNotificationInterceptor_Factory() { return new FormNotificationInterceptor(i0.ɵɵinject(FormNotificationService)); }, token: FormNotificationInterceptor, providedIn: "root" });
    FormNotificationInterceptor.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] }
    ];
    FormNotificationInterceptor.ctorParameters = function () { return [
        { type: FormNotificationService }
    ]; };

    var FormNotificationComponentSuperclass = /** @class */ (function () {
        /**
         * Método construtor responsável por carregar o serviço de validação
         * @param formNotificationService
         */
        function FormNotificationComponentSuperclass(formNotificationService) {
            this.formNotificationService = formNotificationService;
        }
        /**
         * Método Inicial para subscrição no endpoint responsável por validar o formulário
         */
        FormNotificationComponentSuperclass.prototype.ngOnInit = function () {
            var _this = this;
            this.subscription = this.formNotificationService
                .notifications(this.form, this.name)
                .subscribe(function (notification) {
                if (notification instanceof FieldFormNotification) {
                    _this.message = notification.message;
                }
                else {
                    _this.message = null;
                }
            });
        };
        /**
         * Método responsável por realizar a saida das subscrições do endpont de validação
         */
        FormNotificationComponentSuperclass.prototype.ngOnDestroy = function () {
            this.subscription.unsubscribe();
        };
        return FormNotificationComponentSuperclass;
    }());
    FormNotificationComponentSuperclass.decorators = [
        { type: i0.Directive, args: [{
                    selector: 'form-notification-component-superclass'
                },] }
    ];
    FormNotificationComponentSuperclass.ctorParameters = function () { return [
        { type: FormNotificationService }
    ]; };
    FormNotificationComponentSuperclass.propDecorators = {
        name: [{ type: i0.Input }],
        form: [{ type: i0.Input }]
    };

    /**
     * Módulo para adicionar funcionalidade de notificação de erros de formulários.
     * @module
     */
    var FormNotificationBaseModule = /** @class */ (function () {
        function FormNotificationBaseModule() {
        }
        return FormNotificationBaseModule;
    }());
    FormNotificationBaseModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule
                    ],
                    declarations: [FormNotificationComponentSuperclass],
                    exports: [FormNotificationComponentSuperclass],
                    providers: [
                        FormNotificationService,
                        {
                            provide: ErrorProvider,
                            useClass: FormNotificationErrorProvider,
                            multi: true,
                        },
                        {
                            provide: i2.HTTP_INTERCEPTORS,
                            useClass: FormNotificationInterceptor,
                            multi: true,
                        },
                    ],
                },] }
    ];

    /**
     * Class provider para definição básica de tratamento de erros de formulários
     * @class
     */
    var FormNotificationProvider = /** @class */ (function (_super) {
        __extends(FormNotificationProvider, _super);
        /**
         * Metodo construtor para validação de formulários
         * @param {string} type
         * @param {string} title
         * @param {string} detail
         * @param {Number} status
         * @param {string} instance
         * @param {Array<string>} stacktrace
         * @param {ApplicationProblemType} cause
         * @param {FormViolation} violations
         */
        function FormNotificationProvider(type, title, detail, status, instance, stacktrace, cause, violations) {
            var _this = _super.call(this, type, title, detail, status, instance, stacktrace, cause) || this;
            _this.violations = violations;
            return _this;
        }
        return FormNotificationProvider;
    }(ApplicationProblemType));

    /**
     * Use as the superclass for anything managed by angular's dependency injection for care-free use of `subscribeTo()`. It simply calls `unsubscribe()` during `ngOnDestroy()`. If you override `ngOnDestroy()` in your subclass, be sure to invoke the super implementation.
     *
     * ```ts
     * @Injectable()
     * // or @Component() (also consider DirectiveSuperclass)
     * // or @Directive() (also consider DirectiveSuperclass)
     * // or @Pipe()
     * class MyThing extends InjectableSuperclass {
     *   constructor(somethingObservable: Observable) {
     *     super();
     *     this.subscribeTo(somethingObservable);
     *   }
     *
     *   ngOnDestroy() {
     *     // if you override ngOnDestroy, be sure to call this too
     *     super.ngOnDestroy();
     *   }
     * }
     * ```
     */
    var InjectableSuperclass = /** @class */ (function () {
        function InjectableSuperclass() {
            this.subscriptions = new rxjs.Subscription();
            this.destructionSubject = new rxjs.Subject();
            this.destruction$ = this.destructionSubject.asObservable();
        }
        InjectableSuperclass.prototype.subscribeTo = function (observable, next, error, complete) {
            this.subscriptions.add(observable.subscribe(this.bind(next), this.bind(error), this.bind(complete)));
        };
        InjectableSuperclass.prototype.unsubscribe = function () {
            this.subscriptions.unsubscribe();
            this.subscriptions = new rxjs.Subscription();
        };
        InjectableSuperclass.prototype.bind = function (fn) {
            return fn === null || fn === void 0 ? void 0 : fn.bind(this);
        };
        InjectableSuperclass.prototype.ngOnDestroy = function () {
            this.unsubscribe();
            this.destructionSubject.next();
            this.destructionSubject.complete();
        };
        return InjectableSuperclass;
    }());
    InjectableSuperclass.decorators = [
        { type: i0.Injectable }
    ];
    InjectableSuperclass.ctorParameters = function () { return []; };

    /**
     * Extend this when creating a directive (including a component, which is a kind of directive) to gain access to the helpers demonstrated below. **Warning:** You _must_ include a constructor in your subclass.
     *
     * ```ts
     * @Component({
     *   selector: "s-color-text",
     *   template: `
     *     <span [style.background]="color">{{ color }}</span>
     *   `,
     *   // note that `bindToInstance()` works even with OnPush change detection
     *   changeDetection: ChangeDetectionStrategy.OnPush,
     * })
     *  class ColorTextComponent extends DirectiveSuperclass {
     *   @Input() prefix?: string;
     *   @Input() prefix2?: string;
     *   color!: string;
     *
     *   // Even if you don't need extra arguments injector, you must still include a constructor. It is required for angular to provide `Injector`.
     *   constructor(
     *     @Inject("color$") color$: Observable<string>,
     *     injector: Injector,
     *   ) {
     *     super(injector);
     *
     *     // combine everything to calculate `color` and keep it up to date
     *     this.bindToInstance(
     *       "color",
     *       combineLatest(
     *         this.getInput$("prefix"),
     *         this.getInput$("prefix2"),
     *         color$,
     *       ).pipe(map((parts) => parts.filter((p) => p).join(""))),
     *     );
     *   }
     * }
     * ```
     */
    var DirectiveSuperclass = /** @class */ (function (_super) {
        __extends(DirectiveSuperclass, _super);
        function DirectiveSuperclass(injector) {
            var _this = _super.call(this) || this;
            /**
             *  Emits the set of `@Input()` property names that change during each call to `ngOnChanges()`.
             */
            _this.inputChanges$ = new rxjs.Subject();
            _this.changeDetectorRef = injector.get(i0.ChangeDetectorRef);
            return _this;
        }
        DirectiveSuperclass.prototype.ngOnChanges = function (changes) {
            this.inputChanges$.next(new Set(Object.getOwnPropertyNames(changes)));
        };
        /**
         * @return an observable of the values for one of this directive's `@Input()` properties
         */
        DirectiveSuperclass.prototype.getInput$ = function (key) {
            var _this = this;
            return this.inputChanges$.pipe(operators.filter(function (keys) { return keys.has(key); }), operators.startWith(undefined), operators.map(function () { return _this[key]; }));
        };
        /**
         * Binds an observable to one of this directive's instance variables. When the observable emits the instance variable will be updated, and change detection will be triggered to propagate any changes. Use this an an alternative to repeating `| async` multiple times in your template.
         */
        DirectiveSuperclass.prototype.bindToInstance = function (key, value$) {
            var _this = this;
            this.subscribeTo(value$, function (value) {
                _this[key] = value;
                _this.changeDetectorRef.markForCheck();
            });
        };
        return DirectiveSuperclass;
    }(InjectableSuperclass));
    DirectiveSuperclass.decorators = [
        { type: i0.Directive }
    ];
    DirectiveSuperclass.ctorParameters = function () { return [
        { type: i0.Injector }
    ]; };

    function noop() { }
    ;
    /**
     * Use in the `providers` of a component that implements `ControlValueAccessor` to reduce some boilerplate.
     *
     * ```ts
     * @Component({ providers: [provideValueAccessor(MyFormControl)] }
     * class MyFormControl extends BaseFormControl {
     *   // ...
     * }
     * ```
     */
    function provideValueAccessor(type) {
        return {
            provide: forms.NG_VALUE_ACCESSOR,
            useExisting: type,
            multi: true,
        };
    }
    /**
     * Extend this when creating a form control to reduce some boilerplate. **Warning:** You _must_ include a constructor in your subclass.
     *
     * This example allows 2-way binding to a number via `[(ngModel)]`, `[formControl]`, or any other technique that leverages the `ControlValueAccessor` interface.
     * ```ts
     * @Component({
     *   template: `
     *     <button (click)="increment()" [disabled]="isDisabled">{{ counter }}</button>
     *   `,
     *   providers: [provideValueAccessor(CounterComponent)],
     * })
     * class CounterComponent extends FormControlSuperclass<number> {
     *   counter = 0;
     *
     *   // This looks unnecessary, but is required for Angular to provide `Injector`
     *   constructor(injector: Injector) {
     *     super(injector);
     *   }
     *
     *   handleIncomingValue(value: number) {
     *     this.counter = value;
     *   }
     *
     *   increment() {
     *     this.emitOutgoingValue(++this.counter);
     *     this.onTouched();
     *   }
     * }
     * ```
     */
    var FormControlSuperclass = /** @class */ (function (_super) {
        __extends(FormControlSuperclass, _super);
        function FormControlSuperclass() {
            var _this = _super.apply(this, __spread(arguments)) || this;
            /** Call this to emit a new value when it changes. */
            _this.emitOutgoingValue = noop;
            /** Call this to "commit" a change, traditionally done e.g. on blur. */
            _this.onTouched = noop;
            /** You can bind to this in your template as needed. */
            _this.isDisabled = false;
            return _this;
        }
        /** Called as angular propagates value changes to this `ControlValueAccessor`. You normally do not need to use it. */
        FormControlSuperclass.prototype.writeValue = function (value) {
            this.handleIncomingValue(value);
            this.changeDetectorRef.markForCheck();
        };
        /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
        FormControlSuperclass.prototype.registerOnChange = function (fn) {
            this.emitOutgoingValue = fn;
        };
        /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */
        FormControlSuperclass.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */
        FormControlSuperclass.prototype.setDisabledState = function (isDisabled) {
            this.isDisabled = isDisabled;
            this.changeDetectorRef.markForCheck();
        };
        return FormControlSuperclass;
    }(DirectiveSuperclass));
    FormControlSuperclass.decorators = [
        { type: i0.Directive }
    ];

    var WrappedFormControlSuperclass = /** @class */ (function (_super) {
        __extends(WrappedFormControlSuperclass, _super);
        function WrappedFormControlSuperclass(injector) {
            var _this = _super.call(this, injector) || this;
            _this.formControl = new forms.FormControl();
            _this.subscribeTo(_this.formControl.valueChanges, function (value) {
                _this.emitOutgoingValue(_this.innerToOuter(value));
            });
            _this.formControl.markAsTouched = function () {
                _this.onTouched();
            };
            return _this;
        }
        /** Called as angular propagates values changes to this `ControlValueAccessor`. You normally do not need to use it. */
        WrappedFormControlSuperclass.prototype.handleIncomingValue = function (value) {
            this.formControl.setValue(this.outerToInner(value), { emitEvent: false });
        };
        /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */
        WrappedFormControlSuperclass.prototype.setDisabledState = function (isDisabled) {
            if (isDisabled) {
                this.formControl.disable({ emitEvent: false });
            }
            else {
                this.formControl.enable({ emitEvent: false });
            }
            _super.prototype.setDisabledState.call(this, this.isDisabled);
        };
        /** Override this to modify a value coming from the outside to the format needed within this component. */
        WrappedFormControlSuperclass.prototype.outerToInner = function (value) {
            return value;
        };
        /** Override this to modify a value coming from within this component to the format expected on the outside. */
        WrappedFormControlSuperclass.prototype.innerToOuter = function (value) {
            return value;
        };
        return WrappedFormControlSuperclass;
    }(FormControlSuperclass));
    WrappedFormControlSuperclass.decorators = [
        { type: i0.Directive }
    ];
    WrappedFormControlSuperclass.ctorParameters = function () { return [
        { type: i0.Injector }
    ]; };

    /*
     * Public API Surface of angular-base
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.AUTH_CONFIG = AUTH_CONFIG;
    exports.AccessbilityModule = AccessbilityModule;
    exports.AccessbilityService = AccessbilityService;
    exports.ApplicationProblemType = ApplicationProblemType;
    exports.AuthGuard = AuthGuard;
    exports.Authentication = Authentication;
    exports.AuthenticationService = AuthenticationService;
    exports.Authorization = Authorization;
    exports.AuthorizationService = AuthorizationService;
    exports.BlockUiInterceptor = BlockUiInterceptor;
    exports.BlockUiService = BlockUiService;
    exports.CepPipe = CepPipe;
    exports.CleanFormNotification = CleanFormNotification;
    exports.ClipboardDirective = ClipboardDirective;
    exports.ClipboardModule = ClipboardModule;
    exports.ClipboardService = ClipboardService;
    exports.CnpjPipe = CnpjPipe;
    exports.CommonMaskModule = CommonMaskModule;
    exports.CommonMaskService = CommonMaskService;
    exports.CpfPipe = CpfPipe;
    exports.DirectivesModule = DirectivesModule;
    exports.ErrorModule = ErrorModule;
    exports.ErrorProvider = ErrorProvider;
    exports.ErrorService = ErrorService;
    exports.ErrorStackProviderService = ErrorStackProviderService;
    exports.ErrorStackService = ErrorStackService;
    exports.FieldFormNotification = FieldFormNotification;
    exports.FormControlSuperclass = FormControlSuperclass;
    exports.FormNotification = FormNotification;
    exports.FormNotificationBaseModule = FormNotificationBaseModule;
    exports.FormNotificationComponentSuperclass = FormNotificationComponentSuperclass;
    exports.FormNotificationErrorProvider = FormNotificationErrorProvider;
    exports.FormNotificationProvider = FormNotificationProvider;
    exports.FormNotificationService = FormNotificationService;
    exports.GENERIC_ERRORS = GENERIC_ERRORS;
    exports.HasRoleDirective = HasRoleDirective;
    exports.HideWhileLoginComponent = HideWhileLoginComponent;
    exports.HttpApplicationProblemErrorService = HttpApplicationProblemErrorService;
    exports.HttpGenericErrorService = HttpGenericErrorService;
    exports.HttpGenericErrorType = HttpGenericErrorType;
    exports.JWTAuthInterceptor = JWTAuthInterceptor;
    exports.JWTTokenService = JWTTokenService;
    exports.LimitPipe = LimitPipe;
    exports.LoginSuccessComponent = LoginSuccessComponent;
    exports.LogoutDirective = LogoutDirective;
    exports.NotAuthenticatedErrorProvider = NotAuthenticatedErrorProvider;
    exports.NotificationProvider = NotificationProvider;
    exports.NotificationService = NotificationService;
    exports.OnlyNumbersDirective = OnlyNumbersDirective;
    exports.PipeModule = PipeModule;
    exports.RegexPipe = RegexPipe;
    exports.SecurityModule = SecurityModule;
    exports.Token = Token;
    exports.UnmaskDirective = UnmaskDirective;
    exports.UserDirective = UserDirective;
    exports.VersionTagComponent = VersionTagComponent;
    exports.VersionTagModule = VersionTagModule;
    exports.WrappedFormControlSuperclass = WrappedFormControlSuperclass;
    exports.bootstrapSecurity = bootstrapSecurity;
    exports.isAuthenticated = isAuthenticated;
    exports.noop = noop;
    exports.provideValueAccessor = provideValueAccessor;
    exports.redirect = redirect;
    exports.ɵb = VERSIONTAG_CONFIG;
    exports.ɵc = FormNotificationInterceptor;
    exports.ɵd = DirectiveSuperclass;
    exports.ɵe = InjectableSuperclass;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=nuvem-angular-base.umd.js.map
