import { Directive, ElementRef, Input } from '@angular/core';
import { NgControl } from '@angular/forms';
/**
 *
 * UnmaskDirective diretiva para remoção de mascaras de valores numericos
 * @class
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/forms';
export class UnmaskDirective {
    /**
     * constructor method
     * @param {ElementRef} elementRef
     * @param {NgControl} model
     * @constructor
     */
    constructor(elementRef, model) {
        this.elementRef = elementRef;
        this.model = model;
    }
    /**
     * Metodo executado no carregamento da diretiva, executa verificação do valor e remove as mascaras baseado em um aexpressão regular
     * @returns void
     */
    ngOnInit() {
        this.subscriber = this.model.control.valueChanges.subscribe(() => {
            const newValue = this.elementRef.nativeElement.value.replace(new RegExp(this.appUnmask), '');
            this.model.control.setValue(newValue, {
                emitEvent: false,
                emitModelToViewChange: false,
                emitViewToModelChange: false
            });
        });
    }
    /**
     * ngOnDestroy method
     * @returns void
     */
    ngOnDestroy() {
        this.subscriber.unsubscribe();
    }
}
UnmaskDirective.ɵfac = function UnmaskDirective_Factory(t) { return new (t || UnmaskDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.NgControl)); };
UnmaskDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: UnmaskDirective, selectors: [["", "unmask", ""]], inputs: { appUnmask: "appUnmask" } });
UnmaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgControl }
];
UnmaskDirective.propDecorators = {
    appUnmask: [{ type: Input }]
};
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(UnmaskDirective, [{
        type: Directive,
        args: [{
                selector: '[unmask]'
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.NgControl }]; }, { appUnmask: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidW5tYXNrLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1iYXNlL3NyYy9saWIvZGlyZWN0aXZlcy91bm1hc2suZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFVLEtBQUssRUFBYSxNQUFNLGVBQWUsQ0FBQztBQUNoRixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFJSCxNQUFNLE9BQU8sZUFBZTtBQUFHLElBYzNCO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsSUFBSSxZQUFvQixVQUFzQixFQUFVLEtBQWdCO0FBQUksUUFBcEQsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLFFBQVMsVUFBSyxHQUFMLEtBQUssQ0FBVztBQUFDLElBQUcsQ0FBQztBQUM3RSxJQUNJO0FBQ0o7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJLFFBQVE7QUFBSyxRQUNULElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FDdkQsR0FBRyxFQUFFO0FBQ2pCLFlBQWdCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzdHLFlBQWdCLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLFFBQVEsQ0FDdkIsUUFBUSxFQUNSO0FBQ3BCLGdCQUF3QixTQUFTLEVBQUUsS0FBSztBQUN4QyxnQkFBd0IscUJBQXFCLEVBQUUsS0FBSztBQUNwRCxnQkFBd0IscUJBQXFCLEVBQUUsS0FBSztBQUNwRCxhQUFxQixDQUNKLENBQUM7QUFDbEIsUUFBWSxDQUFDLENBQ0osQ0FBQztBQUNWLElBQUksQ0FBQztBQUNMLElBQ0k7QUFDSjtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksV0FBVztBQUNmLFFBQVEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUN0QyxJQUFJLENBQUM7QUFDTDsyQ0FwREMsU0FBUyxTQUFDLGtCQUNQLFFBQVEsRUFBRSxVQUFVLGNBQ3ZCO2dKQUNJO0FBQUM7QUFBeUMsWUFYM0IsVUFBVTtBQUFJLFlBQ3pCLFNBQVM7QUFBRztBQUFHO0FBSWpCLHdCQVlGLEtBQUs7QUFBSTs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgRWxlbWVudFJlZiwgT25Jbml0LCBJbnB1dCwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5cbi8qKlxuICpcbiAqIFVubWFza0RpcmVjdGl2ZSBkaXJldGl2YSBwYXJhIHJlbW/Dp8OjbyBkZSBtYXNjYXJhcyBkZSB2YWxvcmVzIG51bWVyaWNvc1xuICogQGNsYXNzXG4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW3VubWFza10nXG59KVxuZXhwb3J0IGNsYXNzIFVubWFza0RpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIC8qKlxuICAgICAqIFByb3ByaWVkYWRlIGEgcGFyYSByZWFsaXphciBhIGZvcm1hdGHDp8OjbyBleHByZXNzw6NvIHJlZ3VsYXJcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBhcHBVbm1hc2tcbiAgICAgKi9cbiAgICBASW5wdXQoKSBhcHBVbm1hc2s6IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIENyaWEgY2FuYWwgZGUgZXNjdXRhIHBhcmEgYSBkaXJldGl2YVxuICAgICAqIEB0eXBlIHtTdWJzY3JpcHRpb259IHN1YnNjcmliZXJcbiAgICAgKi9cbiAgICBwcml2YXRlIHN1YnNjcmliZXI7XG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3RvciBtZXRob2RcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRSZWZ9IGVsZW1lbnRSZWZcbiAgICAgKiBAcGFyYW0ge05nQ29udHJvbH0gbW9kZWxcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHByaXZhdGUgbW9kZWw6IE5nQ29udHJvbCkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRvZG8gZXhlY3V0YWRvIG5vIGNhcnJlZ2FtZW50byBkYSBkaXJldGl2YSwgZXhlY3V0YSB2ZXJpZmljYcOnw6NvIGRvIHZhbG9yIGUgcmVtb3ZlIGFzIG1hc2NhcmFzIGJhc2VhZG8gZW0gdW0gYWV4cHJlc3PDo28gcmVndWxhclxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gdGhpcy5tb2RlbC5jb250cm9sLnZhbHVlQ2hhbmdlcy5zdWJzY3JpYmUoXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZS5yZXBsYWNlKG5ldyBSZWdFeHAodGhpcy5hcHBVbm1hc2spLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlbC5jb250cm9sLnNldFZhbHVlKFxuICAgICAgICAgICAgICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdEV2ZW50OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtaXRNb2RlbFRvVmlld0NoYW5nZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0Vmlld1RvTW9kZWxDaGFuZ2U6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIG5nT25EZXN0cm95IG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHZvaWRcbiAgICAgKi9cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxufVxuIl19