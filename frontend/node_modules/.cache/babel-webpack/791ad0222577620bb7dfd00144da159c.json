{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar Element = require('../core/core.element');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n  legend: {\n    display: true,\n    position: 'top',\n    fullWidth: true,\n    reverse: false,\n    weight: 1000,\n    // a callback that will handle\n    onClick: function onClick(e, legendItem) {\n      var index = legendItem.datasetIndex;\n      var ci = this.chart;\n      var meta = ci.getDatasetMeta(index); // See controller.isDatasetVisible comment\n\n      meta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null; // We hid a dataset ... rerender the chart\n\n      ci.update();\n    },\n    onHover: null,\n    labels: {\n      boxWidth: 40,\n      padding: 10,\n      // Generates labels shown in the legend\n      // Valid properties to return:\n      // text : text to display\n      // fillStyle : fill of coloured box\n      // strokeStyle: stroke of coloured box\n      // hidden : if this legend item refers to a hidden item\n      // lineCap : cap style for line\n      // lineDash\n      // lineDashOffset :\n      // lineJoin :\n      // lineWidth :\n      generateLabels: function generateLabels(chart) {\n        var data = chart.data;\n        return helpers.isArray(data.datasets) ? data.datasets.map(function (dataset, i) {\n          return {\n            text: dataset.label,\n            fillStyle: !helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0],\n            hidden: !chart.isDatasetVisible(i),\n            lineCap: dataset.borderCapStyle,\n            lineDash: dataset.borderDash,\n            lineDashOffset: dataset.borderDashOffset,\n            lineJoin: dataset.borderJoinStyle,\n            lineWidth: dataset.borderWidth,\n            strokeStyle: dataset.borderColor,\n            pointStyle: dataset.pointStyle,\n            // Below is extra data used for toggling the datasets\n            datasetIndex: i\n          };\n        }, this) : [];\n      }\n    }\n  },\n  legendCallback: function legendCallback(chart) {\n    var text = [];\n    text.push('<ul class=\"' + chart.id + '-legend\">');\n\n    for (var i = 0; i < chart.data.datasets.length; i++) {\n      text.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\n      if (chart.data.datasets[i].label) {\n        text.push(chart.data.datasets[i].label);\n      }\n\n      text.push('</li>');\n    }\n\n    text.push('</ul>');\n    return text.join('');\n  }\n});\n\nmodule.exports = function (Chart) {\n  var layout = Chart.layoutService;\n  var noop = helpers.noop;\n  /**\n   * Helper function to get the box width based on the usePointStyle option\n   * @param labelopts {Object} the label options on the legend\n   * @param fontSize {Number} the label font size\n   * @return {Number} width of the color box area\n   */\n\n  function getBoxWidth(labelOpts, fontSize) {\n    return labelOpts.usePointStyle ? fontSize * Math.SQRT2 : labelOpts.boxWidth;\n  }\n\n  Chart.Legend = Element.extend({\n    initialize: function initialize(config) {\n      helpers.extend(this, config); // Contains hit boxes for each dataset (in dataset order)\n\n      this.legendHitBoxes = []; // Are we in doughnut mode which has a different data type\n\n      this.doughnutMode = false;\n    },\n    // These methods are ordered by lifecycle. Utilities then follow.\n    // Any function defined here is inherited by all legend types.\n    // Any function can be extended by the legend type\n    beforeUpdate: noop,\n    update: function update(maxWidth, maxHeight, margins) {\n      var me = this; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = margins; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Labels\n\n      me.beforeBuildLabels();\n      me.buildLabels();\n      me.afterBuildLabels(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: noop,\n    //\n    beforeSetDimensions: noop,\n    setDimensions: function setDimensions() {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0; // Reset minSize\n\n      me.minSize = {\n        width: 0,\n        height: 0\n      };\n    },\n    afterSetDimensions: noop,\n    //\n    beforeBuildLabels: noop,\n    buildLabels: function buildLabels() {\n      var me = this;\n      var labelOpts = me.options.labels || {};\n      var legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n      if (labelOpts.filter) {\n        legendItems = legendItems.filter(function (item) {\n          return labelOpts.filter(item, me.chart.data);\n        });\n      }\n\n      if (me.options.reverse) {\n        legendItems.reverse();\n      }\n\n      me.legendItems = legendItems;\n    },\n    afterBuildLabels: noop,\n    //\n    beforeFit: noop,\n    fit: function fit() {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var display = opts.display;\n      var ctx = me.ctx;\n      var globalDefault = defaults.global;\n      var valueOrDefault = helpers.valueOrDefault;\n      var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n      var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n      var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n      var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily); // Reset hit boxes\n\n      var hitboxes = me.legendHitBoxes = [];\n      var minSize = me.minSize;\n      var isHorizontal = me.isHorizontal();\n\n      if (isHorizontal) {\n        minSize.width = me.maxWidth; // fill all the width\n\n        minSize.height = display ? 10 : 0;\n      } else {\n        minSize.width = display ? 10 : 0;\n        minSize.height = me.maxHeight; // fill all the height\n      } // Increase sizes here\n\n\n      if (display) {\n        ctx.font = labelFont;\n\n        if (isHorizontal) {\n          // Labels\n          // Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n          var lineWidths = me.lineWidths = [0];\n          var totalHeight = me.legendItems.length ? fontSize + labelOpts.padding : 0;\n          ctx.textAlign = 'left';\n          ctx.textBaseline = 'top';\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var width = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;\n\n            if (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n              totalHeight += fontSize + labelOpts.padding;\n              lineWidths[lineWidths.length] = me.left;\n            } // Store the hitbox width and height here. Final position will be updated in `draw`\n\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: width,\n              height: fontSize\n            };\n            lineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n          });\n          minSize.height += totalHeight;\n        } else {\n          var vPadding = labelOpts.padding;\n          var columnWidths = me.columnWidths = [];\n          var totalWidth = labelOpts.padding;\n          var currentColWidth = 0;\n          var currentColHeight = 0;\n          var itemHeight = fontSize + vPadding;\n          helpers.each(me.legendItems, function (legendItem, i) {\n            var boxWidth = getBoxWidth(labelOpts, fontSize);\n            var itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width; // If too tall, go to new column\n\n            if (currentColHeight + itemHeight > minSize.height) {\n              totalWidth += currentColWidth + labelOpts.padding;\n              columnWidths.push(currentColWidth); // previous column width\n\n              currentColWidth = 0;\n              currentColHeight = 0;\n            } // Get max width\n\n\n            currentColWidth = Math.max(currentColWidth, itemWidth);\n            currentColHeight += itemHeight; // Store the hitbox width and height here. Final position will be updated in `draw`\n\n            hitboxes[i] = {\n              left: 0,\n              top: 0,\n              width: itemWidth,\n              height: fontSize\n            };\n          });\n          totalWidth += currentColWidth;\n          columnWidths.push(currentColWidth);\n          minSize.width += totalWidth;\n        }\n      }\n\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n    afterFit: noop,\n    // Shared Methods\n    isHorizontal: function isHorizontal() {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    // Actually draw the legend on the canvas\n    draw: function draw() {\n      var me = this;\n      var opts = me.options;\n      var labelOpts = opts.labels;\n      var globalDefault = defaults.global;\n      var lineDefault = globalDefault.elements.line;\n      var legendWidth = me.width;\n      var lineWidths = me.lineWidths;\n\n      if (opts.display) {\n        var ctx = me.ctx;\n        var valueOrDefault = helpers.valueOrDefault;\n        var fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n        var fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n        var fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n        var fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n        var labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n        var cursor; // Canvas setup\n\n        ctx.textAlign = 'left';\n        ctx.textBaseline = 'middle';\n        ctx.lineWidth = 0.5;\n        ctx.strokeStyle = fontColor; // for strikethrough effect\n\n        ctx.fillStyle = fontColor; // render in correct colour\n\n        ctx.font = labelFont;\n        var boxWidth = getBoxWidth(labelOpts, fontSize);\n        var hitboxes = me.legendHitBoxes; // current position\n\n        var drawLegendBox = function drawLegendBox(x, y, legendItem) {\n          if (isNaN(boxWidth) || boxWidth <= 0) {\n            return;\n          } // Set the ctx for the box\n\n\n          ctx.save();\n          ctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n          ctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n          ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n          ctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n          ctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n          ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n          var isLineWidthZero = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0;\n\n          if (ctx.setLineDash) {\n            // IE 9 and 10 do not support line dash\n            ctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n          }\n\n          if (opts.labels && opts.labels.usePointStyle) {\n            // Recalculate x and y for drawPoint() because its expecting\n            // x and y to be center of figure (instead of top left)\n            var radius = fontSize * Math.SQRT2 / 2;\n            var offSet = radius / Math.SQRT2;\n            var centerX = x + offSet;\n            var centerY = y + offSet; // Draw pointStyle as legend symbol\n\n            helpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n          } else {\n            // Draw box as legend symbol\n            if (!isLineWidthZero) {\n              ctx.strokeRect(x, y, boxWidth, fontSize);\n            }\n\n            ctx.fillRect(x, y, boxWidth, fontSize);\n          }\n\n          ctx.restore();\n        };\n\n        var fillText = function fillText(x, y, legendItem, textWidth) {\n          var halfFontSize = fontSize / 2;\n          var xLeft = boxWidth + halfFontSize + x;\n          var yMiddle = y + halfFontSize;\n          ctx.fillText(legendItem.text, xLeft, yMiddle);\n\n          if (legendItem.hidden) {\n            // Strikethrough the text if hidden\n            ctx.beginPath();\n            ctx.lineWidth = 2;\n            ctx.moveTo(xLeft, yMiddle);\n            ctx.lineTo(xLeft + textWidth, yMiddle);\n            ctx.stroke();\n          }\n        }; // Horizontal\n\n\n        var isHorizontal = me.isHorizontal();\n\n        if (isHorizontal) {\n          cursor = {\n            x: me.left + (legendWidth - lineWidths[0]) / 2,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        } else {\n          cursor = {\n            x: me.left + labelOpts.padding,\n            y: me.top + labelOpts.padding,\n            line: 0\n          };\n        }\n\n        var itemHeight = fontSize + labelOpts.padding;\n        helpers.each(me.legendItems, function (legendItem, i) {\n          var textWidth = ctx.measureText(legendItem.text).width;\n          var width = boxWidth + fontSize / 2 + textWidth;\n          var x = cursor.x;\n          var y = cursor.y;\n\n          if (isHorizontal) {\n            if (x + width >= legendWidth) {\n              y = cursor.y += itemHeight;\n              cursor.line++;\n              x = cursor.x = me.left + (legendWidth - lineWidths[cursor.line]) / 2;\n            }\n          } else if (y + itemHeight > me.bottom) {\n            x = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n            y = cursor.y = me.top + labelOpts.padding;\n            cursor.line++;\n          }\n\n          drawLegendBox(x, y, legendItem);\n          hitboxes[i].left = x;\n          hitboxes[i].top = y; // Fill the actual label\n\n          fillText(x, y, legendItem, textWidth);\n\n          if (isHorizontal) {\n            cursor.x += width + labelOpts.padding;\n          } else {\n            cursor.y += itemHeight;\n          }\n        });\n      }\n    },\n\n    /**\n     * Handle an event\n     * @private\n     * @param {IEvent} event - The event to handle\n     * @return {Boolean} true if a change occured\n     */\n    handleEvent: function handleEvent(e) {\n      var me = this;\n      var opts = me.options;\n      var type = e.type === 'mouseup' ? 'click' : e.type;\n      var changed = false;\n\n      if (type === 'mousemove') {\n        if (!opts.onHover) {\n          return;\n        }\n      } else if (type === 'click') {\n        if (!opts.onClick) {\n          return;\n        }\n      } else {\n        return;\n      } // Chart event already has relative position in it\n\n\n      var x = e.x;\n      var y = e.y;\n\n      if (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n        // See if we are touching one of the dataset boxes\n        var lh = me.legendHitBoxes;\n\n        for (var i = 0; i < lh.length; ++i) {\n          var hitBox = lh[i];\n\n          if (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n            // Touching an element\n            if (type === 'click') {\n              // use e.native for backwards compatibility\n              opts.onClick.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            } else if (type === 'mousemove') {\n              // use e.native for backwards compatibility\n              opts.onHover.call(me, e.native, me.legendItems[i]);\n              changed = true;\n              break;\n            }\n          }\n        }\n      }\n\n      return changed;\n    }\n  });\n\n  function createNewLegendAndAttach(chart, legendOpts) {\n    var legend = new Chart.Legend({\n      ctx: chart.ctx,\n      options: legendOpts,\n      chart: chart\n    });\n    layout.configure(chart, legend, legendOpts);\n    layout.addBox(chart, legend);\n    chart.legend = legend;\n  }\n\n  return {\n    id: 'legend',\n    beforeInit: function beforeInit(chart) {\n      var legendOpts = chart.options.legend;\n\n      if (legendOpts) {\n        createNewLegendAndAttach(chart, legendOpts);\n      }\n    },\n    beforeUpdate: function beforeUpdate(chart) {\n      var legendOpts = chart.options.legend;\n      var legend = chart.legend;\n\n      if (legendOpts) {\n        helpers.mergeIf(legendOpts, defaults.global.legend);\n\n        if (legend) {\n          layout.configure(chart, legend, legendOpts);\n          legend.options = legendOpts;\n        } else {\n          createNewLegendAndAttach(chart, legendOpts);\n        }\n      } else if (legend) {\n        layout.removeBox(chart, legend);\n        delete chart.legend;\n      }\n    },\n    afterEvent: function afterEvent(chart, e) {\n      var legend = chart.legend;\n\n      if (legend) {\n        legend.handleEvent(e);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/basis/TCC/codificacao/frontend/node_modules/chart.js/src/plugins/plugin.legend.js"],"names":["defaults","require","Element","helpers","_set","legend","display","position","fullWidth","reverse","weight","onClick","e","legendItem","index","datasetIndex","ci","chart","meta","getDatasetMeta","hidden","data","datasets","update","onHover","labels","boxWidth","padding","generateLabels","isArray","map","dataset","i","text","label","fillStyle","backgroundColor","isDatasetVisible","lineCap","borderCapStyle","lineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","borderWidth","strokeStyle","borderColor","pointStyle","legendCallback","push","id","length","join","module","exports","Chart","layout","layoutService","noop","getBoxWidth","labelOpts","fontSize","usePointStyle","Math","SQRT2","Legend","extend","initialize","config","legendHitBoxes","doughnutMode","beforeUpdate","maxWidth","maxHeight","margins","me","beforeSetDimensions","setDimensions","afterSetDimensions","beforeBuildLabels","buildLabels","afterBuildLabels","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","width","left","right","height","top","bottom","paddingLeft","paddingTop","paddingRight","paddingBottom","options","legendItems","callback","filter","item","opts","ctx","globalDefault","global","valueOrDefault","defaultFontSize","fontStyle","defaultFontStyle","fontFamily","defaultFontFamily","labelFont","fontString","hitboxes","font","lineWidths","totalHeight","textAlign","textBaseline","each","measureText","vPadding","columnWidths","totalWidth","currentColWidth","currentColHeight","itemHeight","itemWidth","max","draw","lineDefault","elements","line","legendWidth","fontColor","defaultFontColor","cursor","drawLegendBox","x","y","isNaN","save","defaultColor","isLineWidthZero","setLineDash","radius","offSet","centerX","centerY","canvas","drawPoint","strokeRect","fillRect","restore","fillText","textWidth","halfFontSize","xLeft","yMiddle","beginPath","moveTo","lineTo","stroke","handleEvent","type","changed","lh","hitBox","call","native","createNewLegendAndAttach","legendOpts","configure","addBox","beforeInit","mergeIf","removeBox","afterEvent"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar Element = require('../core/core.element');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tlegend: {\n\t\tdisplay: true,\n\t\tposition: 'top',\n\t\tfullWidth: true,\n\t\treverse: false,\n\t\tweight: 1000,\n\n\t\t// a callback that will handle\n\t\tonClick: function(e, legendItem) {\n\t\t\tvar index = legendItem.datasetIndex;\n\t\t\tvar ci = this.chart;\n\t\t\tvar meta = ci.getDatasetMeta(index);\n\n\t\t\t// See controller.isDatasetVisible comment\n\t\t\tmeta.hidden = meta.hidden === null ? !ci.data.datasets[index].hidden : null;\n\n\t\t\t// We hid a dataset ... rerender the chart\n\t\t\tci.update();\n\t\t},\n\n\t\tonHover: null,\n\n\t\tlabels: {\n\t\t\tboxWidth: 40,\n\t\t\tpadding: 10,\n\t\t\t// Generates labels shown in the legend\n\t\t\t// Valid properties to return:\n\t\t\t// text : text to display\n\t\t\t// fillStyle : fill of coloured box\n\t\t\t// strokeStyle: stroke of coloured box\n\t\t\t// hidden : if this legend item refers to a hidden item\n\t\t\t// lineCap : cap style for line\n\t\t\t// lineDash\n\t\t\t// lineDashOffset :\n\t\t\t// lineJoin :\n\t\t\t// lineWidth :\n\t\t\tgenerateLabels: function(chart) {\n\t\t\t\tvar data = chart.data;\n\t\t\t\treturn helpers.isArray(data.datasets) ? data.datasets.map(function(dataset, i) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttext: dataset.label,\n\t\t\t\t\t\tfillStyle: (!helpers.isArray(dataset.backgroundColor) ? dataset.backgroundColor : dataset.backgroundColor[0]),\n\t\t\t\t\t\thidden: !chart.isDatasetVisible(i),\n\t\t\t\t\t\tlineCap: dataset.borderCapStyle,\n\t\t\t\t\t\tlineDash: dataset.borderDash,\n\t\t\t\t\t\tlineDashOffset: dataset.borderDashOffset,\n\t\t\t\t\t\tlineJoin: dataset.borderJoinStyle,\n\t\t\t\t\t\tlineWidth: dataset.borderWidth,\n\t\t\t\t\t\tstrokeStyle: dataset.borderColor,\n\t\t\t\t\t\tpointStyle: dataset.pointStyle,\n\n\t\t\t\t\t\t// Below is extra data used for toggling the datasets\n\t\t\t\t\t\tdatasetIndex: i\n\t\t\t\t\t};\n\t\t\t\t}, this) : [];\n\t\t\t}\n\t\t}\n\t},\n\n\tlegendCallback: function(chart) {\n\t\tvar text = [];\n\t\ttext.push('<ul class=\"' + chart.id + '-legend\">');\n\t\tfor (var i = 0; i < chart.data.datasets.length; i++) {\n\t\t\ttext.push('<li><span style=\"background-color:' + chart.data.datasets[i].backgroundColor + '\"></span>');\n\t\t\tif (chart.data.datasets[i].label) {\n\t\t\t\ttext.push(chart.data.datasets[i].label);\n\t\t\t}\n\t\t\ttext.push('</li>');\n\t\t}\n\t\ttext.push('</ul>');\n\t\treturn text.join('');\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tvar layout = Chart.layoutService;\n\tvar noop = helpers.noop;\n\n\t/**\n\t * Helper function to get the box width based on the usePointStyle option\n\t * @param labelopts {Object} the label options on the legend\n\t * @param fontSize {Number} the label font size\n\t * @return {Number} width of the color box area\n\t */\n\tfunction getBoxWidth(labelOpts, fontSize) {\n\t\treturn labelOpts.usePointStyle ?\n\t\t\tfontSize * Math.SQRT2 :\n\t\t\tlabelOpts.boxWidth;\n\t}\n\n\tChart.Legend = Element.extend({\n\n\t\tinitialize: function(config) {\n\t\t\thelpers.extend(this, config);\n\n\t\t\t// Contains hit boxes for each dataset (in dataset order)\n\t\t\tthis.legendHitBoxes = [];\n\n\t\t\t// Are we in doughnut mode which has a different data type\n\t\t\tthis.doughnutMode = false;\n\t\t},\n\n\t\t// These methods are ordered by lifecycle. Utilities then follow.\n\t\t// Any function defined here is inherited by all legend types.\n\t\t// Any function can be extended by the legend type\n\n\t\tbeforeUpdate: noop,\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = margins;\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\t\t\t// Labels\n\t\t\tme.beforeBuildLabels();\n\t\t\tme.buildLabels();\n\t\t\tme.afterBuildLabels();\n\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\t\t},\n\t\tafterUpdate: noop,\n\n\t\t//\n\n\t\tbeforeSetDimensions: noop,\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\n\t\t\t// Reset minSize\n\t\t\tme.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\t\t},\n\t\tafterSetDimensions: noop,\n\n\t\t//\n\n\t\tbeforeBuildLabels: noop,\n\t\tbuildLabels: function() {\n\t\t\tvar me = this;\n\t\t\tvar labelOpts = me.options.labels || {};\n\t\t\tvar legendItems = helpers.callback(labelOpts.generateLabels, [me.chart], me) || [];\n\n\t\t\tif (labelOpts.filter) {\n\t\t\t\tlegendItems = legendItems.filter(function(item) {\n\t\t\t\t\treturn labelOpts.filter(item, me.chart.data);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (me.options.reverse) {\n\t\t\t\tlegendItems.reverse();\n\t\t\t}\n\n\t\t\tme.legendItems = legendItems;\n\t\t},\n\t\tafterBuildLabels: noop,\n\n\t\t//\n\n\t\tbeforeFit: noop,\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar display = opts.display;\n\n\t\t\tvar ctx = me.ctx;\n\n\t\t\tvar globalDefault = defaults.global;\n\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\n\t\t\t// Reset hit boxes\n\t\t\tvar hitboxes = me.legendHitBoxes = [];\n\n\t\t\tvar minSize = me.minSize;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.width = me.maxWidth; // fill all the width\n\t\t\t\tminSize.height = display ? 10 : 0;\n\t\t\t} else {\n\t\t\t\tminSize.width = display ? 10 : 0;\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Increase sizes here\n\t\t\tif (display) {\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// Labels\n\n\t\t\t\t\t// Width of each line of legend boxes. Labels wrap onto multiple lines when there are too many to fit on one\n\t\t\t\t\tvar lineWidths = me.lineWidths = [0];\n\t\t\t\t\tvar totalHeight = me.legendItems.length ? fontSize + (labelOpts.padding) : 0;\n\n\t\t\t\t\tctx.textAlign = 'left';\n\t\t\t\t\tctx.textBaseline = 'top';\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\tif (lineWidths[lineWidths.length - 1] + width + labelOpts.padding >= me.width) {\n\t\t\t\t\t\t\ttotalHeight += fontSize + (labelOpts.padding);\n\t\t\t\t\t\t\tlineWidths[lineWidths.length] = me.left;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: width,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tlineWidths[lineWidths.length - 1] += width + labelOpts.padding;\n\t\t\t\t\t});\n\n\t\t\t\t\tminSize.height += totalHeight;\n\n\t\t\t\t} else {\n\t\t\t\t\tvar vPadding = labelOpts.padding;\n\t\t\t\t\tvar columnWidths = me.columnWidths = [];\n\t\t\t\t\tvar totalWidth = labelOpts.padding;\n\t\t\t\t\tvar currentColWidth = 0;\n\t\t\t\t\tvar currentColHeight = 0;\n\t\t\t\t\tvar itemHeight = fontSize + vPadding;\n\n\t\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\t\t\tvar itemWidth = boxWidth + (fontSize / 2) + ctx.measureText(legendItem.text).width;\n\n\t\t\t\t\t\t// If too tall, go to new column\n\t\t\t\t\t\tif (currentColHeight + itemHeight > minSize.height) {\n\t\t\t\t\t\t\ttotalWidth += currentColWidth + labelOpts.padding;\n\t\t\t\t\t\t\tcolumnWidths.push(currentColWidth); // previous column width\n\n\t\t\t\t\t\t\tcurrentColWidth = 0;\n\t\t\t\t\t\t\tcurrentColHeight = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Get max width\n\t\t\t\t\t\tcurrentColWidth = Math.max(currentColWidth, itemWidth);\n\t\t\t\t\t\tcurrentColHeight += itemHeight;\n\n\t\t\t\t\t\t// Store the hitbox width and height here. Final position will be updated in `draw`\n\t\t\t\t\t\thitboxes[i] = {\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\twidth: itemWidth,\n\t\t\t\t\t\t\theight: fontSize\n\t\t\t\t\t\t};\n\t\t\t\t\t});\n\n\t\t\t\t\ttotalWidth += currentColWidth;\n\t\t\t\t\tcolumnWidths.push(currentColWidth);\n\t\t\t\t\tminSize.width += totalWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\t\tafterFit: noop,\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\n\t\t// Actually draw the legend on the canvas\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar labelOpts = opts.labels;\n\t\t\tvar globalDefault = defaults.global;\n\t\t\tvar lineDefault = globalDefault.elements.line;\n\t\t\tvar legendWidth = me.width;\n\t\t\tvar lineWidths = me.lineWidths;\n\n\t\t\tif (opts.display) {\n\t\t\t\tvar ctx = me.ctx;\n\t\t\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\t\t\tvar fontColor = valueOrDefault(labelOpts.fontColor, globalDefault.defaultFontColor);\n\t\t\t\tvar fontSize = valueOrDefault(labelOpts.fontSize, globalDefault.defaultFontSize);\n\t\t\t\tvar fontStyle = valueOrDefault(labelOpts.fontStyle, globalDefault.defaultFontStyle);\n\t\t\t\tvar fontFamily = valueOrDefault(labelOpts.fontFamily, globalDefault.defaultFontFamily);\n\t\t\t\tvar labelFont = helpers.fontString(fontSize, fontStyle, fontFamily);\n\t\t\t\tvar cursor;\n\n\t\t\t\t// Canvas setup\n\t\t\t\tctx.textAlign = 'left';\n\t\t\t\tctx.textBaseline = 'middle';\n\t\t\t\tctx.lineWidth = 0.5;\n\t\t\t\tctx.strokeStyle = fontColor; // for strikethrough effect\n\t\t\t\tctx.fillStyle = fontColor; // render in correct colour\n\t\t\t\tctx.font = labelFont;\n\n\t\t\t\tvar boxWidth = getBoxWidth(labelOpts, fontSize);\n\t\t\t\tvar hitboxes = me.legendHitBoxes;\n\n\t\t\t\t// current position\n\t\t\t\tvar drawLegendBox = function(x, y, legendItem) {\n\t\t\t\t\tif (isNaN(boxWidth) || boxWidth <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Set the ctx for the box\n\t\t\t\t\tctx.save();\n\n\t\t\t\t\tctx.fillStyle = valueOrDefault(legendItem.fillStyle, globalDefault.defaultColor);\n\t\t\t\t\tctx.lineCap = valueOrDefault(legendItem.lineCap, lineDefault.borderCapStyle);\n\t\t\t\t\tctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, lineDefault.borderDashOffset);\n\t\t\t\t\tctx.lineJoin = valueOrDefault(legendItem.lineJoin, lineDefault.borderJoinStyle);\n\t\t\t\t\tctx.lineWidth = valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth);\n\t\t\t\t\tctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, globalDefault.defaultColor);\n\t\t\t\t\tvar isLineWidthZero = (valueOrDefault(legendItem.lineWidth, lineDefault.borderWidth) === 0);\n\n\t\t\t\t\tif (ctx.setLineDash) {\n\t\t\t\t\t\t// IE 9 and 10 do not support line dash\n\t\t\t\t\t\tctx.setLineDash(valueOrDefault(legendItem.lineDash, lineDefault.borderDash));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (opts.labels && opts.labels.usePointStyle) {\n\t\t\t\t\t\t// Recalculate x and y for drawPoint() because its expecting\n\t\t\t\t\t\t// x and y to be center of figure (instead of top left)\n\t\t\t\t\t\tvar radius = fontSize * Math.SQRT2 / 2;\n\t\t\t\t\t\tvar offSet = radius / Math.SQRT2;\n\t\t\t\t\t\tvar centerX = x + offSet;\n\t\t\t\t\t\tvar centerY = y + offSet;\n\n\t\t\t\t\t\t// Draw pointStyle as legend symbol\n\t\t\t\t\t\thelpers.canvas.drawPoint(ctx, legendItem.pointStyle, radius, centerX, centerY);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Draw box as legend symbol\n\t\t\t\t\t\tif (!isLineWidthZero) {\n\t\t\t\t\t\t\tctx.strokeRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tctx.fillRect(x, y, boxWidth, fontSize);\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.restore();\n\t\t\t\t};\n\t\t\t\tvar fillText = function(x, y, legendItem, textWidth) {\n\t\t\t\t\tvar halfFontSize = fontSize / 2;\n\t\t\t\t\tvar xLeft = boxWidth + halfFontSize + x;\n\t\t\t\t\tvar yMiddle = y + halfFontSize;\n\n\t\t\t\t\tctx.fillText(legendItem.text, xLeft, yMiddle);\n\n\t\t\t\t\tif (legendItem.hidden) {\n\t\t\t\t\t\t// Strikethrough the text if hidden\n\t\t\t\t\t\tctx.beginPath();\n\t\t\t\t\t\tctx.lineWidth = 2;\n\t\t\t\t\t\tctx.moveTo(xLeft, yMiddle);\n\t\t\t\t\t\tctx.lineTo(xLeft + textWidth, yMiddle);\n\t\t\t\t\t\tctx.stroke();\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// Horizontal\n\t\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + ((legendWidth - lineWidths[0]) / 2),\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tcursor = {\n\t\t\t\t\t\tx: me.left + labelOpts.padding,\n\t\t\t\t\t\ty: me.top + labelOpts.padding,\n\t\t\t\t\t\tline: 0\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tvar itemHeight = fontSize + labelOpts.padding;\n\t\t\t\thelpers.each(me.legendItems, function(legendItem, i) {\n\t\t\t\t\tvar textWidth = ctx.measureText(legendItem.text).width;\n\t\t\t\t\tvar width = boxWidth + (fontSize / 2) + textWidth;\n\t\t\t\t\tvar x = cursor.x;\n\t\t\t\t\tvar y = cursor.y;\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tif (x + width >= legendWidth) {\n\t\t\t\t\t\t\ty = cursor.y += itemHeight;\n\t\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t\t\tx = cursor.x = me.left + ((legendWidth - lineWidths[cursor.line]) / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (y + itemHeight > me.bottom) {\n\t\t\t\t\t\tx = cursor.x = x + me.columnWidths[cursor.line] + labelOpts.padding;\n\t\t\t\t\t\ty = cursor.y = me.top + labelOpts.padding;\n\t\t\t\t\t\tcursor.line++;\n\t\t\t\t\t}\n\n\t\t\t\t\tdrawLegendBox(x, y, legendItem);\n\n\t\t\t\t\thitboxes[i].left = x;\n\t\t\t\t\thitboxes[i].top = y;\n\n\t\t\t\t\t// Fill the actual label\n\t\t\t\t\tfillText(x, y, legendItem, textWidth);\n\n\t\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t\tcursor.x += width + (labelOpts.padding);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcursor.y += itemHeight;\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Handle an event\n\t\t * @private\n\t\t * @param {IEvent} event - The event to handle\n\t\t * @return {Boolean} true if a change occured\n\t\t */\n\t\thandleEvent: function(e) {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar type = e.type === 'mouseup' ? 'click' : e.type;\n\t\t\tvar changed = false;\n\n\t\t\tif (type === 'mousemove') {\n\t\t\t\tif (!opts.onHover) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else if (type === 'click') {\n\t\t\t\tif (!opts.onClick) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Chart event already has relative position in it\n\t\t\tvar x = e.x;\n\t\t\tvar y = e.y;\n\n\t\t\tif (x >= me.left && x <= me.right && y >= me.top && y <= me.bottom) {\n\t\t\t\t// See if we are touching one of the dataset boxes\n\t\t\t\tvar lh = me.legendHitBoxes;\n\t\t\t\tfor (var i = 0; i < lh.length; ++i) {\n\t\t\t\t\tvar hitBox = lh[i];\n\n\t\t\t\t\tif (x >= hitBox.left && x <= hitBox.left + hitBox.width && y >= hitBox.top && y <= hitBox.top + hitBox.height) {\n\t\t\t\t\t\t// Touching an element\n\t\t\t\t\t\tif (type === 'click') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onClick.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (type === 'mousemove') {\n\t\t\t\t\t\t\t// use e.native for backwards compatibility\n\t\t\t\t\t\t\topts.onHover.call(me, e.native, me.legendItems[i]);\n\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn changed;\n\t\t}\n\t});\n\n\tfunction createNewLegendAndAttach(chart, legendOpts) {\n\t\tvar legend = new Chart.Legend({\n\t\t\tctx: chart.ctx,\n\t\t\toptions: legendOpts,\n\t\t\tchart: chart\n\t\t});\n\n\t\tlayout.configure(chart, legend, legendOpts);\n\t\tlayout.addBox(chart, legend);\n\t\tchart.legend = legend;\n\t}\n\n\treturn {\n\t\tid: 'legend',\n\n\t\tbeforeInit: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t}\n\t\t},\n\n\t\tbeforeUpdate: function(chart) {\n\t\t\tvar legendOpts = chart.options.legend;\n\t\t\tvar legend = chart.legend;\n\n\t\t\tif (legendOpts) {\n\t\t\t\thelpers.mergeIf(legendOpts, defaults.global.legend);\n\n\t\t\t\tif (legend) {\n\t\t\t\t\tlayout.configure(chart, legend, legendOpts);\n\t\t\t\t\tlegend.options = legendOpts;\n\t\t\t\t} else {\n\t\t\t\t\tcreateNewLegendAndAttach(chart, legendOpts);\n\t\t\t\t}\n\t\t\t} else if (legend) {\n\t\t\t\tlayout.removeBox(chart, legend);\n\t\t\t\tdelete chart.legend;\n\t\t\t}\n\t\t},\n\n\t\tafterEvent: function(chart, e) {\n\t\t\tvar legend = chart.legend;\n\t\t\tif (legend) {\n\t\t\t\tlegend.handleEvent(e);\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}