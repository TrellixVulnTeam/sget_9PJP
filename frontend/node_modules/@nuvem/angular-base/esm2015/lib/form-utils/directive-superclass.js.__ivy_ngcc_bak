import { ChangeDetectorRef, Injector, Directive } from "@angular/core";
import { Subject } from "rxjs";
import { filter, map, startWith } from "rxjs/operators";
import { InjectableSuperclass } from "./injectable-superclass";
/**
 * Extend this when creating a directive (including a component, which is a kind of directive) to gain access to the helpers demonstrated below. **Warning:** You _must_ include a constructor in your subclass.
 *
 * ```ts
 * @Component({
 *   selector: "s-color-text",
 *   template: `
 *     <span [style.background]="color">{{ color }}</span>
 *   `,
 *   // note that `bindToInstance()` works even with OnPush change detection
 *   changeDetection: ChangeDetectionStrategy.OnPush,
 * })
 *  class ColorTextComponent extends DirectiveSuperclass {
 *   @Input() prefix?: string;
 *   @Input() prefix2?: string;
 *   color!: string;
 *
 *   // Even if you don't need extra arguments injector, you must still include a constructor. It is required for angular to provide `Injector`.
 *   constructor(
 *     @Inject("color$") color$: Observable<string>,
 *     injector: Injector,
 *   ) {
 *     super(injector);
 *
 *     // combine everything to calculate `color` and keep it up to date
 *     this.bindToInstance(
 *       "color",
 *       combineLatest(
 *         this.getInput$("prefix"),
 *         this.getInput$("prefix2"),
 *         color$,
 *       ).pipe(map((parts) => parts.filter((p) => p).join(""))),
 *     );
 *   }
 * }
 * ```
 */
export class DirectiveSuperclass extends InjectableSuperclass {
    constructor(injector) {
        super();
        /**
         *  Emits the set of `@Input()` property names that change during each call to `ngOnChanges()`.
         */
        this.inputChanges$ = new Subject();
        this.changeDetectorRef = injector.get(ChangeDetectorRef);
    }
    ngOnChanges(changes) {
        this.inputChanges$.next(new Set(Object.getOwnPropertyNames(changes)));
    }
    /**
     * @return an observable of the values for one of this directive's `@Input()` properties
     */
    getInput$(key) {
        return this.inputChanges$.pipe(filter((keys) => keys.has(key)), startWith(undefined), map(() => this[key]));
    }
    /**
     * Binds an observable to one of this directive's instance variables. When the observable emits the instance variable will be updated, and change detection will be triggered to propagate any changes. Use this an an alternative to repeating `| async` multiple times in your template.
     */
    bindToInstance(key, value$) {
        this.subscribeTo(value$, (value) => {
            this[key] = value;
            this.changeDetectorRef.markForCheck();
        });
    }
}
DirectiveSuperclass.decorators = [
    { type: Directive }
];
DirectiveSuperclass.ctorParameters = () => [
    { type: Injector }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGlyZWN0aXZlLXN1cGVyY2xhc3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWJhc2Uvc3JjL2xpYi9mb3JtLXV0aWxzL2RpcmVjdGl2ZS1zdXBlcmNsYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxRQUFRLEVBQWlCLFNBQVMsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN0RixPQUFPLEVBQWMsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3hELE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHlCQUF5QixDQUFDO0FBRS9EOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FvQ0c7QUFFSCxNQUFNLE9BQWdCLG1CQUFvQixTQUFRLG9CQUFvQjtJQVNsRSxZQUFZLFFBQWtCO1FBQzFCLEtBQUssRUFBRSxDQUFDO1FBUlo7O1dBRUc7UUFDSCxrQkFBYSxHQUFHLElBQUksT0FBTyxFQUFPLENBQUM7UUFNL0IsSUFBSSxDQUFDLGlCQUFpQixHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsaUJBQWlCLENBQUMsQ0FBQztJQUM3RCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQXNCO1FBQzlCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUNuQixJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFzQixDQUFDLENBQ3BFLENBQUM7SUFDTixDQUFDO0lBRUQ7O09BRUc7SUFDSCxTQUFTLENBQXVCLEdBQU07UUFDbEMsT0FBTyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FDMUIsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEVBQy9CLFNBQVMsQ0FBQyxTQUFTLENBQUMsRUFDcEIsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUN2QixDQUFDO0lBQ04sQ0FBQztJQUVEOztPQUVHO0lBQ0gsY0FBYyxDQUF1QixHQUFNLEVBQUUsTUFBMkI7UUFDcEUsSUFBSSxDQUFDLFdBQVcsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMvQixJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQ2xCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMxQyxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7OztZQXhDSixTQUFTOzs7WUExQ2tCLFFBQVEiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDaGFuZ2VEZXRlY3RvclJlZiwgSW5qZWN0b3IsIFNpbXBsZUNoYW5nZXMsIERpcmVjdGl2ZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0IH0gZnJvbSBcInJ4anNcIjtcbmltcG9ydCB7IGZpbHRlciwgbWFwLCBzdGFydFdpdGggfSBmcm9tIFwicnhqcy9vcGVyYXRvcnNcIjtcbmltcG9ydCB7IEluamVjdGFibGVTdXBlcmNsYXNzIH0gZnJvbSBcIi4vaW5qZWN0YWJsZS1zdXBlcmNsYXNzXCI7XG5cbi8qKlxuICogRXh0ZW5kIHRoaXMgd2hlbiBjcmVhdGluZyBhIGRpcmVjdGl2ZSAoaW5jbHVkaW5nIGEgY29tcG9uZW50LCB3aGljaCBpcyBhIGtpbmQgb2YgZGlyZWN0aXZlKSB0byBnYWluIGFjY2VzcyB0byB0aGUgaGVscGVycyBkZW1vbnN0cmF0ZWQgYmVsb3cuICoqV2FybmluZzoqKiBZb3UgX211c3RfIGluY2x1ZGUgYSBjb25zdHJ1Y3RvciBpbiB5b3VyIHN1YmNsYXNzLlxuICpcbiAqIGBgYHRzXG4gKiBAQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6IFwicy1jb2xvci10ZXh0XCIsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPHNwYW4gW3N0eWxlLmJhY2tncm91bmRdPVwiY29sb3JcIj57eyBjb2xvciB9fTwvc3Bhbj5cbiAqICAgYCxcbiAqICAgLy8gbm90ZSB0aGF0IGBiaW5kVG9JbnN0YW5jZSgpYCB3b3JrcyBldmVuIHdpdGggT25QdXNoIGNoYW5nZSBkZXRlY3Rpb25cbiAqICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gKiB9KVxuICogIGNsYXNzIENvbG9yVGV4dENvbXBvbmVudCBleHRlbmRzIERpcmVjdGl2ZVN1cGVyY2xhc3Mge1xuICogICBASW5wdXQoKSBwcmVmaXg/OiBzdHJpbmc7XG4gKiAgIEBJbnB1dCgpIHByZWZpeDI/OiBzdHJpbmc7XG4gKiAgIGNvbG9yITogc3RyaW5nO1xuICpcbiAqICAgLy8gRXZlbiBpZiB5b3UgZG9uJ3QgbmVlZCBleHRyYSBhcmd1bWVudHMgaW5qZWN0b3IsIHlvdSBtdXN0IHN0aWxsIGluY2x1ZGUgYSBjb25zdHJ1Y3Rvci4gSXQgaXMgcmVxdWlyZWQgZm9yIGFuZ3VsYXIgdG8gcHJvdmlkZSBgSW5qZWN0b3JgLlxuICogICBjb25zdHJ1Y3RvcihcbiAqICAgICBASW5qZWN0KFwiY29sb3IkXCIpIGNvbG9yJDogT2JzZXJ2YWJsZTxzdHJpbmc+LFxuICogICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAqICAgKSB7XG4gKiAgICAgc3VwZXIoaW5qZWN0b3IpO1xuICpcbiAqICAgICAvLyBjb21iaW5lIGV2ZXJ5dGhpbmcgdG8gY2FsY3VsYXRlIGBjb2xvcmAgYW5kIGtlZXAgaXQgdXAgdG8gZGF0ZVxuICogICAgIHRoaXMuYmluZFRvSW5zdGFuY2UoXG4gKiAgICAgICBcImNvbG9yXCIsXG4gKiAgICAgICBjb21iaW5lTGF0ZXN0KFxuICogICAgICAgICB0aGlzLmdldElucHV0JChcInByZWZpeFwiKSxcbiAqICAgICAgICAgdGhpcy5nZXRJbnB1dCQoXCJwcmVmaXgyXCIpLFxuICogICAgICAgICBjb2xvciQsXG4gKiAgICAgICApLnBpcGUobWFwKChwYXJ0cykgPT4gcGFydHMuZmlsdGVyKChwKSA9PiBwKS5qb2luKFwiXCIpKSksXG4gKiAgICAgKTtcbiAqICAgfVxuICogfVxuICogYGBgXG4gKi9cbkBEaXJlY3RpdmUoKVxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIERpcmVjdGl2ZVN1cGVyY2xhc3MgZXh0ZW5kcyBJbmplY3RhYmxlU3VwZXJjbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiAgRW1pdHMgdGhlIHNldCBvZiBgQElucHV0KClgIHByb3BlcnR5IG5hbWVzIHRoYXQgY2hhbmdlIGR1cmluZyBlYWNoIGNhbGwgdG8gYG5nT25DaGFuZ2VzKClgLlxuICAgICAqL1xuICAgIGlucHV0Q2hhbmdlcyQgPSBuZXcgU3ViamVjdDxhbnk+KCk7XG5cbiAgICBwcm90ZWN0ZWQgY2hhbmdlRGV0ZWN0b3JSZWY6IENoYW5nZURldGVjdG9yUmVmO1xuXG4gICAgY29uc3RydWN0b3IoaW5qZWN0b3I6IEluamVjdG9yKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3JSZWYgPSBpbmplY3Rvci5nZXQoQ2hhbmdlRGV0ZWN0b3JSZWYpO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbnB1dENoYW5nZXMkLm5leHQoXG4gICAgICAgICAgICBuZXcgU2V0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGNoYW5nZXMpIGFzIEFycmF5PGtleW9mIHRoaXM+KSxcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIGFuIG9ic2VydmFibGUgb2YgdGhlIHZhbHVlcyBmb3Igb25lIG9mIHRoaXMgZGlyZWN0aXZlJ3MgYEBJbnB1dCgpYCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZ2V0SW5wdXQkPEsgZXh0ZW5kcyBrZXlvZiB0aGlzPihrZXk6IEspOiBPYnNlcnZhYmxlPHRoaXNbS10+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRDaGFuZ2VzJC5waXBlKFxuICAgICAgICAgICAgZmlsdGVyKChrZXlzKSA9PiBrZXlzLmhhcyhrZXkpKSxcbiAgICAgICAgICAgIHN0YXJ0V2l0aCh1bmRlZmluZWQpLFxuICAgICAgICAgICAgbWFwKCgpID0+IHRoaXNba2V5XSksXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQmluZHMgYW4gb2JzZXJ2YWJsZSB0byBvbmUgb2YgdGhpcyBkaXJlY3RpdmUncyBpbnN0YW5jZSB2YXJpYWJsZXMuIFdoZW4gdGhlIG9ic2VydmFibGUgZW1pdHMgdGhlIGluc3RhbmNlIHZhcmlhYmxlIHdpbGwgYmUgdXBkYXRlZCwgYW5kIGNoYW5nZSBkZXRlY3Rpb24gd2lsbCBiZSB0cmlnZ2VyZWQgdG8gcHJvcGFnYXRlIGFueSBjaGFuZ2VzLiBVc2UgdGhpcyBhbiBhbiBhbHRlcm5hdGl2ZSB0byByZXBlYXRpbmcgYHwgYXN5bmNgIG11bHRpcGxlIHRpbWVzIGluIHlvdXIgdGVtcGxhdGUuXG4gICAgICovXG4gICAgYmluZFRvSW5zdGFuY2U8SyBleHRlbmRzIGtleW9mIHRoaXM+KGtleTogSywgdmFsdWUkOiBPYnNlcnZhYmxlPHRoaXNbS10+KSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlVG8odmFsdWUkLCAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19