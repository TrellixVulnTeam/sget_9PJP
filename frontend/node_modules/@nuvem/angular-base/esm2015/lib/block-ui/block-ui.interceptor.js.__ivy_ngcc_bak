import { HttpResponse } from '@angular/common/http';
import { Injectable } from "@angular/core";
import { tap } from 'rxjs/operators';
import { BlockUiService } from './block-ui.service';
import * as i0 from "@angular/core";
import * as i1 from "./block-ui.service";
/**
 * Class BlockUiInterceptor
 * @class
 */
export class BlockUiInterceptor {
    /**
     * constructor method
     * @constructor
     * @param {BlockUiService} service
     */
    constructor(service) {
        this.service = service;
    }
    /**
     * intercept method
     * @public
     * @param {HttpRequest<any>} req
     * @param {HttpHandler} next
     * @return Observable<HttpEvent<any>>
     */
    intercept(req, next) {
        if (this.isMutation(req.method)) {
            this.service.show();
        }
        return next.handle(req).pipe(tap((event) => {
            if (event instanceof HttpResponse) {
                this.service.hide();
            }
        }, (err) => {
            this.service.hide();
        }));
    }
    /**
     * isMutation method
     * @private
     * @param {string} method
     * @return boolean
     */
    isMutation(method) {
        const mutationsMethods = [
            'DELETE',
            'PATCH',
            'POST',
            'PUT'
        ];
        return mutationsMethods.indexOf(method) !== -1;
    }
}
BlockUiInterceptor.ɵprov = i0.ɵɵdefineInjectable({ factory: function BlockUiInterceptor_Factory() { return new BlockUiInterceptor(i0.ɵɵinject(i1.BlockUiService)); }, token: BlockUiInterceptor, providedIn: "root" });
BlockUiInterceptor.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
BlockUiInterceptor.ctorParameters = () => [
    { type: BlockUiService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmxvY2stdWkuaW50ZXJjZXB0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWJhc2Uvc3JjL2xpYi9ibG9jay11aS9ibG9jay11aS5pbnRlcmNlcHRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQXVDLFlBQVksRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpGLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7O0FBRXBEOzs7R0FHRztBQUlILE1BQU0sT0FBTyxrQkFBa0I7SUFFM0I7Ozs7T0FJRztJQUNILFlBQW9CLE9BQXVCO1FBQXZCLFlBQU8sR0FBUCxPQUFPLENBQWdCO0lBQUcsQ0FBQztJQUUvQzs7Ozs7O09BTUc7SUFDSCxTQUFTLENBQUMsR0FBcUIsRUFBRSxJQUFpQjtRQUU5QyxJQUFJLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzdCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDdkI7UUFFRCxPQUFPLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUMsSUFBSSxDQUN4QixHQUFHLENBQ0MsQ0FBQyxLQUFxQixFQUFFLEVBQUU7WUFDdEIsSUFBSSxLQUFLLFlBQVksWUFBWSxFQUFFO2dCQUMvQixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO2FBQ3ZCO1FBQ0wsQ0FBQyxFQUNELENBQUMsR0FBUSxFQUFFLEVBQUU7WUFDVCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ3hCLENBQUMsQ0FDSixDQUNKLENBQUM7SUFDTixDQUFDO0lBQ0Q7Ozs7O09BS0c7SUFDSyxVQUFVLENBQUMsTUFBYztRQUM3QixNQUFNLGdCQUFnQixHQUFHO1lBQ3JCLFFBQVE7WUFDUixPQUFPO1lBQ1AsTUFBTTtZQUNOLEtBQUs7U0FDUixDQUFDO1FBRUYsT0FBTyxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDbkQsQ0FBQzs7OztZQXJESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQVJRLGNBQWMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBIdHRwRXZlbnQsIEh0dHBIYW5kbGVyLCBIdHRwUmVxdWVzdCwgSHR0cFJlc3BvbnNlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSHR0cEludGVyY2VwdG9yIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uL2h0dHAnO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCI7XG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCbG9ja1VpU2VydmljZSB9IGZyb20gJy4vYmxvY2stdWkuc2VydmljZSc7XG5cbi8qKlxuICogQ2xhc3MgQmxvY2tVaUludGVyY2VwdG9yXG4gKiBAY2xhc3NcbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBCbG9ja1VpSW50ZXJjZXB0b3IgaW1wbGVtZW50cyBIdHRwSW50ZXJjZXB0b3Ige1xuXG4gICAgLyoqXG4gICAgICogY29uc3RydWN0b3IgbWV0aG9kXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtCbG9ja1VpU2VydmljZX0gc2VydmljZSBcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHNlcnZpY2U6IEJsb2NrVWlTZXJ2aWNlKSB7fVxuXG4gICAgLyoqXG4gICAgICogaW50ZXJjZXB0IG1ldGhvZFxuICAgICAqIEBwdWJsaWMgXG4gICAgICogQHBhcmFtIHtIdHRwUmVxdWVzdDxhbnk+fSByZXFcbiAgICAgKiBAcGFyYW0ge0h0dHBIYW5kbGVyfSBuZXh0XG4gICAgICogQHJldHVybiBPYnNlcnZhYmxlPEh0dHBFdmVudDxhbnk+PlxuICAgICAqL1xuICAgIGludGVyY2VwdChyZXE6IEh0dHBSZXF1ZXN0PGFueT4sIG5leHQ6IEh0dHBIYW5kbGVyKTogT2JzZXJ2YWJsZTxIdHRwRXZlbnQ8YW55Pj4ge1xuXG4gICAgICAgIGlmICh0aGlzLmlzTXV0YXRpb24ocmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2VydmljZS5zaG93KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dC5oYW5kbGUocmVxKS5waXBlKFxuICAgICAgICAgICAgdGFwKFxuICAgICAgICAgICAgICAgIChldmVudDogSHR0cEV2ZW50PGFueT4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlcnZpY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZXJyOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXJ2aWNlLmhpZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGlzTXV0YXRpb24gbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc011dGF0aW9uKG1ldGhvZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGNvbnN0IG11dGF0aW9uc01ldGhvZHMgPSBbXG4gICAgICAgICAgICAnREVMRVRFJyxcbiAgICAgICAgICAgICdQQVRDSCcsXG4gICAgICAgICAgICAnUE9TVCcsXG4gICAgICAgICAgICAnUFVUJ1xuICAgICAgICBdO1xuXG4gICAgICAgIHJldHVybiBtdXRhdGlvbnNNZXRob2RzLmluZGV4T2YobWV0aG9kKSAhPT0gLTE7XG4gICAgfVxufVxuIl19