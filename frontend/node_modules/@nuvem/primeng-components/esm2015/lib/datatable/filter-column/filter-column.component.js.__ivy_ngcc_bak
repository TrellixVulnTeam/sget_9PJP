import { Component, EventEmitter, Output, Input } from '@angular/core';
import { Subject } from 'rxjs';
import { debounceTime } from 'rxjs/operators';
export class FilterColumn {
    constructor() {
        this.listaOriginal = [];
        this.lista = [];
        this.labelDefaultImplementation = false;
        this.updateFiltro = false;
        this.customFilterOptions = {};
        this.template = 'filter_text';
        this.outputEvent = new EventEmitter();
        this.debouncer = new Subject();
        this.resultado = [];
        this.listaFields = [];
    }
    ngOnInit() {
        this.debouncer
            .pipe(debounceTime((this.tableType === 'memory') ? 300 : 1000))
            .subscribe((value) => this.outputEvent.emit(value));
        this.template = `filter_${this.filterType}`;
    }
    ngOnChanges(changes) {
        if (this.checkChanges(changes, 'listaOriginal')) {
            this.preencherFields();
        }
    }
    checkChanges(changes, property) {
        return changes[property] && changes[property].previousValue != changes[property].currentValue;
    }
    /**
     * Método para propagar o evento de filtragem
     * @param event filtro
     */
    filtrar(event) {
        this.debouncer.next(this.filtro);
    }
    /**
     * Preenche os itens que serão exibidos no multiselect, removendo duplicidades
     */
    preencherFields() {
        this.listaFields = [];
        this.listaOriginal.filter(pi => pi[this.field] !== null).forEach(row => {
            let item = { label: row[this.field], value: row[this.field] };
            if (!this.verificarSeExisteField(item)) {
                this.listaFields.push(item);
            }
        });
    }
    /**
     *
     * @param field Verifica duplicidade de fields nas opções de seleção
     */
    verificarSeExisteField(field) {
        return this.listaFields.some(item => {
            return item.value == field.value;
        });
    }
    /**
     * Caso o usuaŕio não forneça uma lista para o options, será criada uma lista com
     * os valores presentes na tabela
     */
    getCustomFilterOptions() {
        if (this.customFilterOptions.hasOwnProperty(this.field)) {
            return this.customFilterOptions[this.field];
        }
        return this.listaFields;
    }
}
FilterColumn.decorators = [
    { type: Component, args: [{
                selector: 'basis-filter-column',
                template: "<div [ngSwitch]=\"filterType\" >\n    <div *ngSwitchCase=\"'text'\">\n        <div class=\"p-g form-group\">\n            <div class=\"p-md-12\">\n                <span class=\"p-float-label\">\n                    <input type=\"text\" pInputText (input)=\"filtrar($event)\" [(ngModel)]=\"filtro\" [style]=\"{width: '100%'}\">\n                    <label>{{ (header) ? header : 'Filtro' }}</label>\n                </span>\n            </div>\n        </div>\n    </div>\n    <div *ngSwitchCase=\"'select'\">\n        <div class=\"p-g form-group\">\n            <div class=\"p-md-12\">\n                <p-multiSelect\n                    [options]=\"getCustomFilterOptions()\"\n                    [defaultLabel]=\"(header)? header: '&nbsp;'\"\n                    [optionLabel]=\"'label'\"\n                    appendTo=\"body\"\n                    [ngModelOptions]=\"{standalone: true}\"\n                    (onChange)=\"filtrar($event)\"\n                    [(ngModel)]=\"filtro\"\n                    [style]=\"{'width':'100%', 'vertical-align':'top'}\">\n                </p-multiSelect>\n            </div>\n        </div>\n    </div>\n</div>\n"
            },] }
];
FilterColumn.ctorParameters = () => [];
FilterColumn.propDecorators = {
    listaOriginal: [{ type: Input }],
    lista: [{ type: Input }],
    field: [{ type: Input }],
    header: [{ type: Input }],
    labelDefaultImplementation: [{ type: Input }],
    labelDefaultName: [{ type: Input }],
    updateFiltro: [{ type: Input }],
    filterType: [{ type: Input }],
    tableType: [{ type: Input }],
    customFilterOptions: [{ type: Input }],
    template: [{ type: Input }],
    outputEvent: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLWNvbHVtbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9wcmltZW5nLWNvbXBvbmVudHMvc3JjL2xpYi9kYXRhdGFibGUvZmlsdGVyLWNvbHVtbi9maWx0ZXItY29sdW1uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFtQyxNQUFNLGVBQWUsQ0FBQztBQUN4RyxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQU05QyxNQUFNLE9BQU8sWUFBWTtJQWtDckI7UUFoQ1Msa0JBQWEsR0FBVSxFQUFFLENBQUM7UUFFMUIsVUFBSyxHQUFVLEVBQUUsQ0FBQztRQU1sQiwrQkFBMEIsR0FBWSxLQUFLLENBQUM7UUFJNUMsaUJBQVksR0FBWSxLQUFLLENBQUM7UUFNOUIsd0JBQW1CLEdBQVcsRUFBRSxDQUFDO1FBRWpDLGFBQVEsR0FBRyxhQUFhLENBQUM7UUFFeEIsZ0JBQVcsR0FBRyxJQUFJLFlBQVksRUFBRSxDQUFDO1FBRW5DLGNBQVMsR0FBaUIsSUFBSSxPQUFPLEVBQU8sQ0FBQztRQUlyRCxjQUFTLEdBQVUsRUFBRSxDQUFDO1FBRWQsZ0JBQVcsR0FBVSxFQUFFLENBQUM7SUFFaEIsQ0FBQztJQUVqQixRQUFRO1FBQ0osSUFBSSxDQUFDLFNBQVM7YUFDVCxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsS0FBSyxRQUFRLENBQUMsQ0FBQSxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUM3RCxTQUFTLENBQUMsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFFeEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxVQUFVLElBQUksQ0FBQyxVQUFVLEVBQUUsQ0FBQztJQUNoRCxDQUFDO0lBRUQsV0FBVyxDQUFDLE9BQTZDO1FBQ3JELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsZUFBZSxDQUFDLEVBQUU7WUFDN0MsSUFBSSxDQUFDLGVBQWUsRUFBRSxDQUFDO1NBQzFCO0lBQ0wsQ0FBQztJQUVELFlBQVksQ0FBQyxPQUE2QyxFQUFFLFFBQVE7UUFDaEUsT0FBTyxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLGFBQWEsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsWUFBWSxDQUFDO0lBQ2xHLENBQUM7SUFFRDs7O09BR0c7SUFDSCxPQUFPLENBQUMsS0FBSztRQUNULElBQUksQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxlQUFlO1FBQ1gsSUFBSSxDQUFDLFdBQVcsR0FBRyxFQUFFLENBQUM7UUFDdEIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUNuRSxJQUFJLElBQUksR0FBRyxFQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxFQUFDLENBQUM7WUFDNUQsSUFBSSxDQUFDLElBQUksQ0FBQyxzQkFBc0IsQ0FBQyxJQUFJLENBQUMsRUFBRTtnQkFDcEMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDL0I7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7SUFFRDs7O09BR0c7SUFDSCxzQkFBc0IsQ0FBQyxLQUFLO1FBQ3hCLE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEMsT0FBTyxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssQ0FBQyxLQUFLLENBQUM7UUFDckMsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsc0JBQXNCO1FBQ2xCLElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLGNBQWMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLEVBQUU7WUFDckQsT0FBTyxJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQy9DO1FBRUQsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzVCLENBQUM7OztZQW5HSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLHFCQUFxQjtnQkFDL0IsOG9DQUE2QzthQUNoRDs7Ozs0QkFHSSxLQUFLO29CQUVMLEtBQUs7b0JBRUwsS0FBSztxQkFFTCxLQUFLO3lDQUVMLEtBQUs7K0JBRUwsS0FBSzsyQkFFTCxLQUFLO3lCQUVMLEtBQUs7d0JBRUwsS0FBSztrQ0FFTCxLQUFLO3VCQUVMLEtBQUs7MEJBRUwsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBPdXRwdXQsIElucHV0LCBPbkNoYW5nZXMsIFNpbXBsZUNoYW5nZSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBkZWJvdW5jZVRpbWUgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYmFzaXMtZmlsdGVyLWNvbHVtbicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2ZpbHRlci1jb2x1bW4uY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIEZpbHRlckNvbHVtbiBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25Jbml0IHtcblxuICAgIEBJbnB1dCgpIGxpc3RhT3JpZ2luYWw6IGFueVtdID0gW107XG5cbiAgICBASW5wdXQoKSBsaXN0YTogYW55W10gPSBbXTtcblxuICAgIEBJbnB1dCgpIGZpZWxkOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKSBoZWFkZXI6IHN0cmluZztcblxuICAgIEBJbnB1dCgpIGxhYmVsRGVmYXVsdEltcGxlbWVudGF0aW9uOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBASW5wdXQoKSBsYWJlbERlZmF1bHROYW1lOiBzdHJpbmc7XG5cbiAgICBASW5wdXQoKSB1cGRhdGVGaWx0cm86IGJvb2xlYW4gPSBmYWxzZTtcblxuICAgIEBJbnB1dCgpIGZpbHRlclR5cGU6IHN0cmluZztcblxuICAgIEBJbnB1dCgpIHRhYmxlVHlwZTogc3RyaW5nO1xuXG4gICAgQElucHV0KCkgY3VzdG9tRmlsdGVyT3B0aW9uczogT2JqZWN0ID0ge307XG5cbiAgICBASW5wdXQoKSB0ZW1wbGF0ZSA9ICdmaWx0ZXJfdGV4dCc7XG5cbiAgICBAT3V0cHV0KCkgb3V0cHV0RXZlbnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBwcml2YXRlIGRlYm91bmNlcjogU3ViamVjdDxhbnk+ID0gbmV3IFN1YmplY3Q8YW55PigpO1xuXG4gICAgZmlsdHJvOiBhbnk7XG5cbiAgICByZXN1bHRhZG86IGFueVtdID0gW107XG5cbiAgICBwcml2YXRlIGxpc3RhRmllbGRzOiBhbnlbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IoKSB7IH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlclxuICAgICAgICAgICAgLnBpcGUoZGVib3VuY2VUaW1lKCh0aGlzLnRhYmxlVHlwZSA9PT0gJ21lbW9yeScpPyAzMDAgOiAxMDAwKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKHZhbHVlKSA9PiB0aGlzLm91dHB1dEV2ZW50LmVtaXQodmFsdWUpKTtcblxuICAgICAgICB0aGlzLnRlbXBsYXRlID0gYGZpbHRlcl8ke3RoaXMuZmlsdGVyVHlwZX1gO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IHsgW3Byb3BOYW1lOiBzdHJpbmddOiBTaW1wbGVDaGFuZ2UgfSkge1xuICAgICAgICBpZiAodGhpcy5jaGVja0NoYW5nZXMoY2hhbmdlcywgJ2xpc3RhT3JpZ2luYWwnKSkge1xuICAgICAgICAgICAgdGhpcy5wcmVlbmNoZXJGaWVsZHMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoZWNrQ2hhbmdlcyhjaGFuZ2VzOiB7IFtwcm9wTmFtZTogc3RyaW5nXTogU2ltcGxlQ2hhbmdlIH0sIHByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBjaGFuZ2VzW3Byb3BlcnR5XSAmJiBjaGFuZ2VzW3Byb3BlcnR5XS5wcmV2aW91c1ZhbHVlICE9IGNoYW5nZXNbcHJvcGVydHldLmN1cnJlbnRWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNw6l0b2RvIHBhcmEgcHJvcGFnYXIgbyBldmVudG8gZGUgZmlsdHJhZ2VtXG4gICAgICogQHBhcmFtIGV2ZW50IGZpbHRyb1xuICAgICAqL1xuICAgIGZpbHRyYXIoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5kZWJvdW5jZXIubmV4dCh0aGlzLmZpbHRybyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJlZW5jaGUgb3MgaXRlbnMgcXVlIHNlcsOjbyBleGliaWRvcyBubyBtdWx0aXNlbGVjdCwgcmVtb3ZlbmRvIGR1cGxpY2lkYWRlc1xuICAgICAqL1xuICAgIHByZWVuY2hlckZpZWxkcygpIHtcbiAgICAgICAgdGhpcy5saXN0YUZpZWxkcyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RhT3JpZ2luYWwuZmlsdGVyKHBpID0+IHBpW3RoaXMuZmllbGRdICE9PSBudWxsKS5mb3JFYWNoKHJvdyA9PiB7XG4gICAgICAgICAgICBsZXQgaXRlbSA9IHtsYWJlbDogcm93W3RoaXMuZmllbGRdLCB2YWx1ZTogcm93W3RoaXMuZmllbGRdfTtcbiAgICAgICAgICAgIGlmICghdGhpcy52ZXJpZmljYXJTZUV4aXN0ZUZpZWxkKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0YUZpZWxkcy5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWVsZCBWZXJpZmljYSBkdXBsaWNpZGFkZSBkZSBmaWVsZHMgbmFzIG9ww6fDtWVzIGRlIHNlbGXDp8Ojb1xuICAgICAqL1xuICAgIHZlcmlmaWNhclNlRXhpc3RlRmllbGQoZmllbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdGFGaWVsZHMuc29tZShpdGVtID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLnZhbHVlID09IGZpZWxkLnZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXNvIG8gdXN1YcWVaW8gbsOjbyBmb3JuZcOnYSB1bWEgbGlzdGEgcGFyYSBvIG9wdGlvbnMsIHNlcsOhIGNyaWFkYSB1bWEgbGlzdGEgY29tXG4gICAgICogb3MgdmFsb3JlcyBwcmVzZW50ZXMgbmEgdGFiZWxhXG4gICAgICovXG4gICAgZ2V0Q3VzdG9tRmlsdGVyT3B0aW9ucygpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VzdG9tRmlsdGVyT3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh0aGlzLmZpZWxkKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tRmlsdGVyT3B0aW9uc1t0aGlzLmZpZWxkXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RhRmllbGRzO1xuICAgIH1cblxufVxuIl19