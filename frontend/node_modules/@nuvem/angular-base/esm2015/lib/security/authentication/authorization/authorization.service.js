import { Injectable } from '@angular/core';
import { Authorization } from './authorization';
import { Authentication } from '../authentication';
import * as i0 from "@angular/core";
import * as i1 from "../authentication";
/**
 * Serviço de autorização
 * @class
 */
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../authentication';
export class AuthorizationService extends Authorization {
    /**
     * Método construtor para a injeção do serviço de configuração AuthConfig
     * @constructor
     * @param {AuthConfig} config
     */
    constructor(authenticationService) {
        super();
        this.authenticationService = authenticationService;
    }
    /**
     * Método responsável por identificar as regras de acesso
     * @public
     * @param {any} role
     * @returns boolean
     */
    hasRole(role) {
        if (role) {
            const user = this.authenticationService.getUser();
            if (role instanceof Array) {
                return user.roles.some((userRole) => role.some((checkRole) => userRole === checkRole));
            }
            return user.roles.some((userRole) => userRole === role);
        }
        return true;
    }
}
AuthorizationService.ɵfac = function AuthorizationService_Factory(t) { return new (t || AuthorizationService)(ɵngcc0.ɵɵinject(ɵngcc1.Authentication)); };
AuthorizationService.ɵprov = i0.ɵɵdefineInjectable({ factory: function AuthorizationService_Factory() { return new AuthorizationService(i0.ɵɵinject(i1.Authentication)); }, token: AuthorizationService, providedIn: "root" });
AuthorizationService.ctorParameters = () => [
    { type: Authentication }
];
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AuthorizationService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.Authentication }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0aG9yaXphdGlvbi5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWJhc2Uvc3JjL2xpYi9zZWN1cml0eS9hdXRoZW50aWNhdGlvbi9hdXRob3JpemF0aW9uL2F1dGhvcml6YXRpb24uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNoRCxPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDbkQ7QUFHQTtBQURBO0FBQ0E7QUFBMEI7QUFDakIsR0FDTjs7O0FBSUgsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGFBQWE7QUFDdkQsSUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxJQUFJLFlBQW9CLHFCQUEyQztBQUNuRSxRQUFRLEtBQUssRUFBRSxDQUFDO0FBQ2hCLFFBRndCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBc0I7QUFBQyxJQUVoRSxDQUFDO0FBQ0wsSUFDSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLElBQUksT0FBTyxDQUFDLElBQVM7QUFBSSxRQUNqQixJQUFJLElBQUksRUFBRTtBQUNsQixZQUFZLE1BQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxPQUFPLEVBQUUsQ0FBQztBQUM5RCxZQUFZLElBQUksSUFBSSxZQUFZLEtBQUssRUFBRTtBQUN2QyxnQkFBZ0IsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxTQUFpQixFQUFFLEVBQUUsQ0FBQyxRQUFRLEtBQUssU0FBUyxDQUFDLENBQUMsQ0FBQztBQUN2SCxhQUFhO0FBQ2IsWUFBWSxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBZ0IsRUFBRSxFQUFFLENBQUMsUUFBUSxLQUFLLElBQUksQ0FBQyxDQUFDO0FBQzVFLFNBQVM7QUFDVCxRQUFRLE9BQU8sSUFBSSxDQUFDO0FBQ3BCLElBQUksQ0FBQztBQUNMO3lKQUNBO0FBQUMsK05BNUJJO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBR3dDLFlBVjNDLGNBQWM7QUFBRztPQVF0QixVQUFVLEVBQUUsTUFBTSxlQUNyQjs7Ozs7K0VBVDJCO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEF1dGhvcml6YXRpb24gfSBmcm9tICcuL2F1dGhvcml6YXRpb24nO1xuaW1wb3J0IHsgQXV0aGVudGljYXRpb24gfSBmcm9tICcuLi9hdXRoZW50aWNhdGlvbic7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnLi4vdXNlcic7XG5cbi8qKlxuICogU2VydmnDp28gZGUgYXV0b3JpemHDp8OjbyBcbiAqIEBjbGFzc1xuICovXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnLFxufSlcbmV4cG9ydCBjbGFzcyBBdXRob3JpemF0aW9uU2VydmljZSBleHRlbmRzIEF1dGhvcml6YXRpb24ge1xuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyBjb25zdHJ1dG9yIHBhcmEgYSBpbmplw6fDo28gZG8gc2VydmnDp28gZGUgY29uZmlndXJhw6fDo28gQXV0aENvbmZpZ1xuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXV0aENvbmZpZ30gY29uZmlnXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhdXRoZW50aWNhdGlvblNlcnZpY2U6IEF1dGhlbnRpY2F0aW9uPFVzZXI+KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTcOpdG9kbyByZXNwb25zw6F2ZWwgcG9yIGlkZW50aWZpY2FyIGFzIHJlZ3JhcyBkZSBhY2Vzc29cbiAgICAgKiBAcHVibGljXG4gICAgICogQHBhcmFtIHthbnl9IHJvbGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFuXG4gICAgICovXG4gICAgaGFzUm9sZShyb2xlOiBhbnkpOiBib29sZWFuIHtcbiAgICAgICAgaWYgKHJvbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSB0aGlzLmF1dGhlbnRpY2F0aW9uU2VydmljZS5nZXRVc2VyKCk7XG4gICAgICAgICAgICBpZiAocm9sZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gcm9sZS5zb21lKChjaGVja1JvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IGNoZWNrUm9sZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVzZXIucm9sZXMuc29tZSgodXNlclJvbGU6IHN0cmluZykgPT4gdXNlclJvbGUgPT09IHJvbGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxufVxuIl19