{"ast":null,"code":"/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar elements = require('../elements/index');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n  plugins: {\n    filler: {\n      propagate: true\n    }\n  }\n});\n\nmodule.exports = function () {\n  var mappers = {\n    dataset: function dataset(source) {\n      var index = source.fill;\n      var chart = source.chart;\n      var meta = chart.getDatasetMeta(index);\n      var visible = meta && chart.isDatasetVisible(index);\n      var points = visible && meta.dataset._children || [];\n      var length = points.length || 0;\n      return !length ? null : function (point, i) {\n        return i < length && points[i]._view || null;\n      };\n    },\n    boundary: function boundary(source) {\n      var boundary = source.boundary;\n      var x = boundary ? boundary.x : null;\n      var y = boundary ? boundary.y : null;\n      return function (point) {\n        return {\n          x: x === null ? point.x : x,\n          y: y === null ? point.y : y\n        };\n      };\n    }\n  }; // @todo if (fill[0] === '#')\n\n  function decodeFill(el, index, count) {\n    var model = el._model || {};\n    var fill = model.fill;\n    var target;\n\n    if (fill === undefined) {\n      fill = !!model.backgroundColor;\n    }\n\n    if (fill === false || fill === null) {\n      return false;\n    }\n\n    if (fill === true) {\n      return 'origin';\n    }\n\n    target = parseFloat(fill, 10);\n\n    if (isFinite(target) && Math.floor(target) === target) {\n      if (fill[0] === '-' || fill[0] === '+') {\n        target = index + target;\n      }\n\n      if (target === index || target < 0 || target >= count) {\n        return false;\n      }\n\n      return target;\n    }\n\n    switch (fill) {\n      // compatibility\n      case 'bottom':\n        return 'start';\n\n      case 'top':\n        return 'end';\n\n      case 'zero':\n        return 'origin';\n      // supported boundaries\n\n      case 'origin':\n      case 'start':\n      case 'end':\n        return fill;\n      // invalid fill values\n\n      default:\n        return false;\n    }\n  }\n\n  function computeBoundary(source) {\n    var model = source.el._model || {};\n    var scale = source.el._scale || {};\n    var fill = source.fill;\n    var target = null;\n    var horizontal;\n\n    if (isFinite(fill)) {\n      return null;\n    } // Backward compatibility: until v3, we still need to support boundary values set on\n    // the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n    // controllers might still use it (e.g. the Smith chart).\n\n\n    if (fill === 'start') {\n      target = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n    } else if (fill === 'end') {\n      target = model.scaleTop === undefined ? scale.top : model.scaleTop;\n    } else if (model.scaleZero !== undefined) {\n      target = model.scaleZero;\n    } else if (scale.getBasePosition) {\n      target = scale.getBasePosition();\n    } else if (scale.getBasePixel) {\n      target = scale.getBasePixel();\n    }\n\n    if (target !== undefined && target !== null) {\n      if (target.x !== undefined && target.y !== undefined) {\n        return target;\n      }\n\n      if (typeof target === 'number' && isFinite(target)) {\n        horizontal = scale.isHorizontal();\n        return {\n          x: horizontal ? target : null,\n          y: horizontal ? null : target\n        };\n      }\n    }\n\n    return null;\n  }\n\n  function resolveTarget(sources, index, propagate) {\n    var source = sources[index];\n    var fill = source.fill;\n    var visited = [index];\n    var target;\n\n    if (!propagate) {\n      return fill;\n    }\n\n    while (fill !== false && visited.indexOf(fill) === -1) {\n      if (!isFinite(fill)) {\n        return fill;\n      }\n\n      target = sources[fill];\n\n      if (!target) {\n        return false;\n      }\n\n      if (target.visible) {\n        return fill;\n      }\n\n      visited.push(fill);\n      fill = target.fill;\n    }\n\n    return false;\n  }\n\n  function createMapper(source) {\n    var fill = source.fill;\n    var type = 'dataset';\n\n    if (fill === false) {\n      return null;\n    }\n\n    if (!isFinite(fill)) {\n      type = 'boundary';\n    }\n\n    return mappers[type](source);\n  }\n\n  function isDrawable(point) {\n    return point && !point.skip;\n  }\n\n  function drawArea(ctx, curve0, curve1, len0, len1) {\n    var i;\n\n    if (!len0 || !len1) {\n      return;\n    } // building first area curve (normal)\n\n\n    ctx.moveTo(curve0[0].x, curve0[0].y);\n\n    for (i = 1; i < len0; ++i) {\n      helpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n    } // joining the two area curves\n\n\n    ctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y); // building opposite area curve (reverse)\n\n    for (i = len1 - 1; i > 0; --i) {\n      helpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n    }\n  }\n\n  function doFill(ctx, points, mapper, view, color, loop) {\n    var count = points.length;\n    var span = view.spanGaps;\n    var curve0 = [];\n    var curve1 = [];\n    var len0 = 0;\n    var len1 = 0;\n    var i, ilen, index, p0, p1, d0, d1;\n    ctx.beginPath();\n\n    for (i = 0, ilen = count + !!loop; i < ilen; ++i) {\n      index = i % count;\n      p0 = points[index]._view;\n      p1 = mapper(p0, index, view);\n      d0 = isDrawable(p0);\n      d1 = isDrawable(p1);\n\n      if (d0 && d1) {\n        len0 = curve0.push(p0);\n        len1 = curve1.push(p1);\n      } else if (len0 && len1) {\n        if (!span) {\n          drawArea(ctx, curve0, curve1, len0, len1);\n          len0 = len1 = 0;\n          curve0 = [];\n          curve1 = [];\n        } else {\n          if (d0) {\n            curve0.push(p0);\n          }\n\n          if (d1) {\n            curve1.push(p1);\n          }\n        }\n      }\n    }\n\n    drawArea(ctx, curve0, curve1, len0, len1);\n    ctx.closePath();\n    ctx.fillStyle = color;\n    ctx.fill();\n  }\n\n  return {\n    id: 'filler',\n    afterDatasetsUpdate: function afterDatasetsUpdate(chart, options) {\n      var count = (chart.data.datasets || []).length;\n      var propagate = options.propagate;\n      var sources = [];\n      var meta, i, el, source;\n\n      for (i = 0; i < count; ++i) {\n        meta = chart.getDatasetMeta(i);\n        el = meta.dataset;\n        source = null;\n\n        if (el && el._model && el instanceof elements.Line) {\n          source = {\n            visible: chart.isDatasetVisible(i),\n            fill: decodeFill(el, i, count),\n            chart: chart,\n            el: el\n          };\n        }\n\n        meta.$filler = source;\n        sources.push(source);\n      }\n\n      for (i = 0; i < count; ++i) {\n        source = sources[i];\n\n        if (!source) {\n          continue;\n        }\n\n        source.fill = resolveTarget(sources, i, propagate);\n        source.boundary = computeBoundary(source);\n        source.mapper = createMapper(source);\n      }\n    },\n    beforeDatasetDraw: function beforeDatasetDraw(chart, args) {\n      var meta = args.meta.$filler;\n\n      if (!meta) {\n        return;\n      }\n\n      var ctx = chart.ctx;\n      var el = meta.el;\n      var view = el._view;\n      var points = el._children || [];\n      var mapper = meta.mapper;\n      var color = view.backgroundColor || defaults.global.defaultColor;\n\n      if (mapper && color && points.length) {\n        helpers.canvas.clipArea(ctx, chart.chartArea);\n        doFill(ctx, points, mapper, view, color, el._loop);\n        helpers.canvas.unclipArea(ctx);\n      }\n    }\n  };\n};","map":{"version":3,"sources":["/home/basis/TCC/codificacao/frontend/node_modules/chart.js/src/plugins/plugin.filler.js"],"names":["defaults","require","elements","helpers","_set","plugins","filler","propagate","module","exports","mappers","dataset","source","index","fill","chart","meta","getDatasetMeta","visible","isDatasetVisible","points","_children","length","point","i","_view","boundary","x","y","decodeFill","el","count","model","_model","target","undefined","backgroundColor","parseFloat","isFinite","Math","floor","computeBoundary","scale","_scale","horizontal","scaleBottom","bottom","scaleTop","top","scaleZero","getBasePosition","getBasePixel","isHorizontal","resolveTarget","sources","visited","indexOf","push","createMapper","type","isDrawable","skip","drawArea","ctx","curve0","curve1","len0","len1","moveTo","canvas","lineTo","doFill","mapper","view","color","loop","span","spanGaps","ilen","p0","p1","d0","d1","beginPath","closePath","fillStyle","id","afterDatasetsUpdate","options","data","datasets","Line","$filler","beforeDatasetDraw","args","global","defaultColor","clipArea","chartArea","_loop","unclipArea"],"mappings":"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","sourcesContent":["/**\n * Plugin based on discussion from the following Chart.js issues:\n * @see https://github.com/chartjs/Chart.js/issues/2380#issuecomment-279961569\n * @see https://github.com/chartjs/Chart.js/issues/2440#issuecomment-256461897\n */\n\n'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('global', {\n\tplugins: {\n\t\tfiller: {\n\t\t\tpropagate: true\n\t\t}\n\t}\n});\n\nmodule.exports = function() {\n\n\tvar mappers = {\n\t\tdataset: function(source) {\n\t\t\tvar index = source.fill;\n\t\t\tvar chart = source.chart;\n\t\t\tvar meta = chart.getDatasetMeta(index);\n\t\t\tvar visible = meta && chart.isDatasetVisible(index);\n\t\t\tvar points = (visible && meta.dataset._children) || [];\n\t\t\tvar length = points.length || 0;\n\n\t\t\treturn !length ? null : function(point, i) {\n\t\t\t\treturn (i < length && points[i]._view) || null;\n\t\t\t};\n\t\t},\n\n\t\tboundary: function(source) {\n\t\t\tvar boundary = source.boundary;\n\t\t\tvar x = boundary ? boundary.x : null;\n\t\t\tvar y = boundary ? boundary.y : null;\n\n\t\t\treturn function(point) {\n\t\t\t\treturn {\n\t\t\t\t\tx: x === null ? point.x : x,\n\t\t\t\t\ty: y === null ? point.y : y,\n\t\t\t\t};\n\t\t\t};\n\t\t}\n\t};\n\n\t// @todo if (fill[0] === '#')\n\tfunction decodeFill(el, index, count) {\n\t\tvar model = el._model || {};\n\t\tvar fill = model.fill;\n\t\tvar target;\n\n\t\tif (fill === undefined) {\n\t\t\tfill = !!model.backgroundColor;\n\t\t}\n\n\t\tif (fill === false || fill === null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (fill === true) {\n\t\t\treturn 'origin';\n\t\t}\n\n\t\ttarget = parseFloat(fill, 10);\n\t\tif (isFinite(target) && Math.floor(target) === target) {\n\t\t\tif (fill[0] === '-' || fill[0] === '+') {\n\t\t\t\ttarget = index + target;\n\t\t\t}\n\n\t\t\tif (target === index || target < 0 || target >= count) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn target;\n\t\t}\n\n\t\tswitch (fill) {\n\t\t// compatibility\n\t\tcase 'bottom':\n\t\t\treturn 'start';\n\t\tcase 'top':\n\t\t\treturn 'end';\n\t\tcase 'zero':\n\t\t\treturn 'origin';\n\t\t// supported boundaries\n\t\tcase 'origin':\n\t\tcase 'start':\n\t\tcase 'end':\n\t\t\treturn fill;\n\t\t// invalid fill values\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction computeBoundary(source) {\n\t\tvar model = source.el._model || {};\n\t\tvar scale = source.el._scale || {};\n\t\tvar fill = source.fill;\n\t\tvar target = null;\n\t\tvar horizontal;\n\n\t\tif (isFinite(fill)) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// Backward compatibility: until v3, we still need to support boundary values set on\n\t\t// the model (scaleTop, scaleBottom and scaleZero) because some external plugins and\n\t\t// controllers might still use it (e.g. the Smith chart).\n\n\t\tif (fill === 'start') {\n\t\t\ttarget = model.scaleBottom === undefined ? scale.bottom : model.scaleBottom;\n\t\t} else if (fill === 'end') {\n\t\t\ttarget = model.scaleTop === undefined ? scale.top : model.scaleTop;\n\t\t} else if (model.scaleZero !== undefined) {\n\t\t\ttarget = model.scaleZero;\n\t\t} else if (scale.getBasePosition) {\n\t\t\ttarget = scale.getBasePosition();\n\t\t} else if (scale.getBasePixel) {\n\t\t\ttarget = scale.getBasePixel();\n\t\t}\n\n\t\tif (target !== undefined && target !== null) {\n\t\t\tif (target.x !== undefined && target.y !== undefined) {\n\t\t\t\treturn target;\n\t\t\t}\n\n\t\t\tif (typeof target === 'number' && isFinite(target)) {\n\t\t\t\thorizontal = scale.isHorizontal();\n\t\t\t\treturn {\n\t\t\t\t\tx: horizontal ? target : null,\n\t\t\t\t\ty: horizontal ? null : target\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tfunction resolveTarget(sources, index, propagate) {\n\t\tvar source = sources[index];\n\t\tvar fill = source.fill;\n\t\tvar visited = [index];\n\t\tvar target;\n\n\t\tif (!propagate) {\n\t\t\treturn fill;\n\t\t}\n\n\t\twhile (fill !== false && visited.indexOf(fill) === -1) {\n\t\t\tif (!isFinite(fill)) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\ttarget = sources[fill];\n\t\t\tif (!target) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (target.visible) {\n\t\t\t\treturn fill;\n\t\t\t}\n\n\t\t\tvisited.push(fill);\n\t\t\tfill = target.fill;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tfunction createMapper(source) {\n\t\tvar fill = source.fill;\n\t\tvar type = 'dataset';\n\n\t\tif (fill === false) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (!isFinite(fill)) {\n\t\t\ttype = 'boundary';\n\t\t}\n\n\t\treturn mappers[type](source);\n\t}\n\n\tfunction isDrawable(point) {\n\t\treturn point && !point.skip;\n\t}\n\n\tfunction drawArea(ctx, curve0, curve1, len0, len1) {\n\t\tvar i;\n\n\t\tif (!len0 || !len1) {\n\t\t\treturn;\n\t\t}\n\n\t\t// building first area curve (normal)\n\t\tctx.moveTo(curve0[0].x, curve0[0].y);\n\t\tfor (i = 1; i < len0; ++i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve0[i - 1], curve0[i]);\n\t\t}\n\n\t\t// joining the two area curves\n\t\tctx.lineTo(curve1[len1 - 1].x, curve1[len1 - 1].y);\n\n\t\t// building opposite area curve (reverse)\n\t\tfor (i = len1 - 1; i > 0; --i) {\n\t\t\thelpers.canvas.lineTo(ctx, curve1[i], curve1[i - 1], true);\n\t\t}\n\t}\n\n\tfunction doFill(ctx, points, mapper, view, color, loop) {\n\t\tvar count = points.length;\n\t\tvar span = view.spanGaps;\n\t\tvar curve0 = [];\n\t\tvar curve1 = [];\n\t\tvar len0 = 0;\n\t\tvar len1 = 0;\n\t\tvar i, ilen, index, p0, p1, d0, d1;\n\n\t\tctx.beginPath();\n\n\t\tfor (i = 0, ilen = (count + !!loop); i < ilen; ++i) {\n\t\t\tindex = i % count;\n\t\t\tp0 = points[index]._view;\n\t\t\tp1 = mapper(p0, index, view);\n\t\t\td0 = isDrawable(p0);\n\t\t\td1 = isDrawable(p1);\n\n\t\t\tif (d0 && d1) {\n\t\t\t\tlen0 = curve0.push(p0);\n\t\t\t\tlen1 = curve1.push(p1);\n\t\t\t} else if (len0 && len1) {\n\t\t\t\tif (!span) {\n\t\t\t\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\t\t\t\t\tlen0 = len1 = 0;\n\t\t\t\t\tcurve0 = [];\n\t\t\t\t\tcurve1 = [];\n\t\t\t\t} else {\n\t\t\t\t\tif (d0) {\n\t\t\t\t\t\tcurve0.push(p0);\n\t\t\t\t\t}\n\t\t\t\t\tif (d1) {\n\t\t\t\t\t\tcurve1.push(p1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdrawArea(ctx, curve0, curve1, len0, len1);\n\n\t\tctx.closePath();\n\t\tctx.fillStyle = color;\n\t\tctx.fill();\n\t}\n\n\treturn {\n\t\tid: 'filler',\n\n\t\tafterDatasetsUpdate: function(chart, options) {\n\t\t\tvar count = (chart.data.datasets || []).length;\n\t\t\tvar propagate = options.propagate;\n\t\t\tvar sources = [];\n\t\t\tvar meta, i, el, source;\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tmeta = chart.getDatasetMeta(i);\n\t\t\t\tel = meta.dataset;\n\t\t\t\tsource = null;\n\n\t\t\t\tif (el && el._model && el instanceof elements.Line) {\n\t\t\t\t\tsource = {\n\t\t\t\t\t\tvisible: chart.isDatasetVisible(i),\n\t\t\t\t\t\tfill: decodeFill(el, i, count),\n\t\t\t\t\t\tchart: chart,\n\t\t\t\t\t\tel: el\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\tmeta.$filler = source;\n\t\t\t\tsources.push(source);\n\t\t\t}\n\n\t\t\tfor (i = 0; i < count; ++i) {\n\t\t\t\tsource = sources[i];\n\t\t\t\tif (!source) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tsource.fill = resolveTarget(sources, i, propagate);\n\t\t\t\tsource.boundary = computeBoundary(source);\n\t\t\t\tsource.mapper = createMapper(source);\n\t\t\t}\n\t\t},\n\n\t\tbeforeDatasetDraw: function(chart, args) {\n\t\t\tvar meta = args.meta.$filler;\n\t\t\tif (!meta) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar ctx = chart.ctx;\n\t\t\tvar el = meta.el;\n\t\t\tvar view = el._view;\n\t\t\tvar points = el._children || [];\n\t\t\tvar mapper = meta.mapper;\n\t\t\tvar color = view.backgroundColor || defaults.global.defaultColor;\n\n\t\t\tif (mapper && color && points.length) {\n\t\t\t\thelpers.canvas.clipArea(ctx, chart.chartArea);\n\t\t\t\tdoFill(ctx, points, mapper, view, color, el._loop);\n\t\t\t\thelpers.canvas.unclipArea(ctx);\n\t\t\t}\n\t\t}\n\t};\n};\n"]},"metadata":{},"sourceType":"script"}