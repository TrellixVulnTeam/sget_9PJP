{"version":3,"file":"form-control-superclass.d.ts","sources":["form-control-superclass.d.ts"],"names":[],"mappings":"AAAA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA","sourcesContent":["import { Type } from \"@angular/core\";\nimport { ControlValueAccessor } from \"@angular/forms\";\nimport { DirectiveSuperclass } from \"./directive-superclass\";\nexport declare function noop(): void;\n/**\n * Use in the `providers` of a component that implements `ControlValueAccessor` to reduce some boilerplate.\n *\n * ```ts\n * @Component({ providers: [provideValueAccessor(MyFormControl)] }\n * class MyFormControl extends BaseFormControl {\n *   // ...\n * }\n * ```\n */\nexport declare function provideValueAccessor(type: Type<any>): {\n    provide: import(\"@angular/core\").InjectionToken<readonly ControlValueAccessor[]>;\n    useExisting: Type<any>;\n    multi: boolean;\n};\n/**\n * Extend this when creating a form control to reduce some boilerplate. **Warning:** You _must_ include a constructor in your subclass.\n *\n * This example allows 2-way binding to a number via `[(ngModel)]`, `[formControl]`, or any other technique that leverages the `ControlValueAccessor` interface.\n * ```ts\n * @Component({\n *   template: `\n *     <button (click)=\"increment()\" [disabled]=\"isDisabled\">{{ counter }}</button>\n *   `,\n *   providers: [provideValueAccessor(CounterComponent)],\n * })\n * class CounterComponent extends FormControlSuperclass<number> {\n *   counter = 0;\n *\n *   // This looks unnecessary, but is required for Angular to provide `Injector`\n *   constructor(injector: Injector) {\n *     super(injector);\n *   }\n *\n *   handleIncomingValue(value: number) {\n *     this.counter = value;\n *   }\n *\n *   increment() {\n *     this.emitOutgoingValue(++this.counter);\n *     this.onTouched();\n *   }\n * }\n * ```\n */\nexport declare abstract class FormControlSuperclass<T> extends DirectiveSuperclass implements ControlValueAccessor {\n    /** Call this to emit a new value when it changes. */\n    emitOutgoingValue: (value: T) => void;\n    /** Call this to \"commit\" a change, traditionally done e.g. on blur. */\n    onTouched: typeof noop;\n    /** You can bind to this in your template as needed. */\n    isDisabled: boolean;\n    /** Implement this to handle a new value coming in from outside. */\n    abstract handleIncomingValue(value: T): void;\n    /** Called as angular propagates value changes to this `ControlValueAccessor`. You normally do not need to use it. */\n    writeValue(value: T): void;\n    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */\n    registerOnChange(fn: (value: T) => void): void;\n    /** Called as angular sets up the binding to this `ControlValueAccessor`. You normally do not need to use it. */\n    registerOnTouched(fn: VoidFunction): void;\n    /** Called as angular propagates disabled changes to this `ControlValueAccessor`. You normally do not need to use it. */\n    setDisabledState(isDisabled: boolean): void;\n}\n"]}